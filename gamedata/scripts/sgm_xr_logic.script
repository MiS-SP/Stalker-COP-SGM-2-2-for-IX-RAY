xr_logic.pick_section_from_condlist = function(actor, npc, condlist)
	local rval = nil -- math.random(100)
	local newsect = nil
	local infop_conditions_met
	--/ SGM in
	if condlist ~= nil then
		for n, cond in pairs(condlist) do
			infop_conditions_met = true -- изначально считаем, что все условия переключения удовлетворены
			for inum, infop in pairs(cond.infop_check) do
				if infop.prob then
					if not rval then
						rval = math.random(100)
					end
					if infop.prob < rval then
						infop_conditions_met = false -- инфопоршен есть, но он не должен присутствовать
						break
					end
				elseif infop.func then
					--printf("_bp: infop.func = %s", infop.func)
					if not xr_conditions[infop.func] then
						if type(npc.name) == "function" then
							abort("object '%s': pick_section_from_condlist: function '%s' is " ..
								"not defined in xr_conditions.script", npc:name(), infop.func)
						else
							abort("object '%s': pick_section_from_condlist: function '%s' is " ..
								"not defined in xr_conditions.script", tostring(npc.name), infop.func)
						end
					end
					--if xr_conditions[infop.func](actor, npc) then
					if infop.params then
						if xr_conditions[infop.func](actor, npc, infop.params) then
							if not infop.expected then
								infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
								break
							end
						else
							if infop.expected then
								infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
								break
							end
						end
					else
						if xr_conditions[infop.func](actor, npc) then
							if not infop.expected then
								infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
								break
							end
						else
							if infop.expected then
								infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
								break
							end
						end
					end
				elseif has_alife_info(infop.name) then
					if not infop.required then
						--'printf("FAILED: actor has infop '%s', which is NOT needed [%s]", infop.name, tostring(has_alife_info(infop.name)))
						infop_conditions_met = false -- инфопоршен есть, но он не должен присутствовать
						break
					else
						--'printf("PASSED: actor has infop '%s', which is needed [%s]", infop.name, tostring(has_alife_info(infop.name)))
					end
				else
					if infop.required then
						--'printf("FAILED: actor has NO infop '%s', which is needed [%s]", infop.name, tostring(has_alife_info(infop.name)))
						infop_conditions_met = false -- инфопоршена нет, но он нужен
						break
					else
						--'printf("PASSED: actor has NO infop '%s', which is not needed [%s]", infop.name, tostring(has_alife_info(infop.name)))
					end
				end
			end
			--printf("_bp: infop_cond_met = %s", utils.to_str(infop_conditions_met))
			if infop_conditions_met then
				-- Условия выполнены. Независимо от того, задана ли секция, нужно проставить требуемые
				-- infoportions:
				for inum, infop in pairs(cond.infop_set) do
					if db.actor == nil then
						abort("TRYING TO SET INFOS THEN ACTOR IS NIL")
					end
					if infop.func then
						if not xr_effects[infop.func] then
							abort("object '%s': pick_section_from_condlist: function '%s' is " ..
								"not defined in xr_effects.script", if_then_else(npc, npc:name(), "nil"), infop.func)
						end
						if infop.params then
							xr_effects[infop.func](actor, npc, infop.params)
						else
							xr_effects[infop.func](actor, npc)
						end
					elseif infop.required then
						if sgm_g.dont_has_alife_info(infop.name) then
							db.actor:give_info_portion(infop.name)
						end
					else
						if has_alife_info(infop.name) then
							db.actor:disable_info_portion(infop.name)
						end
					end
				end
				if cond.section == "never" then
					return nil
				else
					return cond.section
				end
			end
		end
	end
	--/ SGM out
	return nil
end

xr_logic.try_switch_to_another_section = function(npc, st, actor)
	local l = st.logic
	local npc_id = npc:id()
	if not actor then
		abort("try_switch_to_another_section(): error in implementation of scheme '%s': actor is nil", st.scheme)
		return
	end
	if not l then
		abort("Can't find script switching information in storage, scheme '%s'", db.storage[npc:id()].active_scheme)
	end
	local switched = false
	for n, c in pairs(l) do
		--printf("_bp: %d: %s", time_global(), c.name)
		if cond_name(c.name, "on_actor_dist_le") then
			--printf("_bp: dist=%d (need <= %d), see_actor: %s", distance_between(actor, npc), c.v1, utils.to_str(see_actor(npc)))
			if see_actor(npc) and distance_between(actor, npc) <= c.v1 then
				--printf("_bp: conditions met")
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
			--/ SGM in
		elseif cond_name(c.name, "on_actor_see") then
			if see_actor(npc) and (c.v1 == true or c.v1 == "true") then
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
			--/ SGM out
		elseif cond_name(c.name, "on_actor_dist_le_nvis") then
			if distance_between(actor, npc) <= c.v1 then
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
		elseif cond_name(c.name, "on_actor_dist_ge") then
			--printf("_bp: dist=%d (need <= %d), see_actor: %s", distance_between(actor, npc), c.v1, utils.to_str(see_actor(npc)))
			-- ТУТ УМЫШЛЕННО >, А НЕ >=, потому что оно составляет пару с on_actor_dist_le, где <=
			if see_actor(npc) and distance_between(actor, npc) > c.v1 then
				--printf("_bp: conditions met")
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
		elseif cond_name(c.name, "on_actor_dist_ge_nvis") then
			-- ТУТ УМЫШЛЕННО >, А НЕ >=, потому что оно составляет пару с on_actor_dist_le_nvis, где <=
			if distance_between(actor, npc) > c.v1 then
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
		elseif cond_name(c.name, "on_signal") then
			--printf("_bp: on_signal (c.v1 = %s)", c.v1)
			if st.signals and st.signals[c.v1] then
				--printf("_bp: on_signal (c.v1 = %s) signalled [%s]", c.v1, npc:name())
				--printf("_bp: signalled")
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
			--/ SGM in
		elseif cond_name(c.name, "shooter_switch") then
			if st.switchs and st.switchs[c.v1] then
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
		elseif cond_name(c.name, "on_patrol_path") then
			if st.patrol_signals and st.patrol_signals[c.v1] then
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
			--/ SGM out
			-- FIXME: не дублировать тут имена, оставить один on_info, но добавлять несколько его экземпляров в список
		elseif cond_name(c.name, "on_info") then
			switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
		elseif cond_name(c.name, "on_timer") then
			--printf("_bp: on_timer: %d >= %d", time_global(),
			--	db.storage[npc_id].activation_time + c.v1)
			if time_global() >= db.storage[npc_id].activation_time + c.v1 then
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
			-- GAMETIME added by Stohe.
		elseif cond_name(c.name, "on_game_timer") then
			if game.get_game_time():diffSec(db.storage[npc_id].activation_game_time) >= c.v1 then
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
		elseif cond_name(c.name, "on_actor_in_zone") then
			if utils.npc_in_zone(actor, db.zone_by_name[c.v1]) then
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
		elseif cond_name(c.name, "on_actor_not_in_zone") then
			if not utils.npc_in_zone(actor, db.zone_by_name[c.v1]) then
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
		elseif cond_name(c.name, "on_npc_in_zone") then
			if utils.npc_in_zone(level.object_by_id(c.npc_id), db.zone_by_name[c.v2]) then
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
		elseif cond_name(c.name, "on_npc_not_in_zone") then
			if not utils.npc_in_zone(level.object_by_id(c.npc_id), db.zone_by_name[c.v2]) then
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
		elseif cond_name(c.name, "on_actor_inside") then
			if utils.npc_in_zone(actor, npc) then
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
		elseif cond_name(c.name, "on_actor_outside") then
			if not utils.npc_in_zone(actor, npc) then
				switched = switch_to_section(npc, st.ini, pick_section_from_condlist(actor, npc, c.condlist))
			end
		else
			abort(
				"WARNING: object '%s': try_switch_to_another_section: unknown condition '%s' encountered",
				npc:name(), c.name)
		end
		if switched == true then
			break
		end
	end
	return switched
end

xr_logic.parse_condlist = function(npc, section, field, src)
	local lst = {}
	-- 1) Разбиваем на разделенные запятыми части:
	local at, to, infop_check_lst, remainings, infop_set_lst, newsect
	local n = 1
	--/ SGM in
	if src ~= nil then
		for fld in string.gfind(src, "%s*([^,]+)%s*") do
			-- Здесь fld это набор infoportions в {} и имя секции, на которую переключиться.
			lst[n] = {}
			--printf("_bp: iter %d: fld = %s", n, fld)
			-- Выделяем список infoportions для проверки:
			at, to, infop_check_lst = string.find(fld, "{%s*(.*)%s*}")
			if infop_check_lst then
				--printf("_bp: infop_check_lst: [%s]", infop_check_lst)

				-- Выделяем оставшуюся часть поля, т.е. имя секции плюс список infoportions для установки:
				remainings = string.sub(fld, 1, at - 1) .. string.sub(fld, to + 1)
			else
				-- Список infoportions для проверки не был задан, следовательно, ничего не удаляем:
				remainings = fld
			end
			--printf("_bp: remainings: %s", remainings)
			-- Выделяем список infoportions для установки из remainings:
			at, to, infop_set_lst = string.find(remainings, "%%%s*(.*)%s*%%")
			if infop_set_lst then
				-- Выделяем оставшуюся часть поля, т.е. имя секции:
				newsect = string.sub(remainings, 1, at - 1) .. string.sub(remainings, to + 1)
			else
				-- Список infoportions для установки не был задан, следовательно, remainings и есть имя секции.
				newsect = remainings
			end
			-- И сразу trim имя секции:
			at, to, newsect = string.find(newsect, "%s*(.*)%s*")
			if not newsect then
				abort_syntax_error_in_cond(npc, section, field)
			end
			-- Имя секции теперь можно сохранить:
			lst[n].section = newsect
			lst[n].infop_check = {}
			parse_infop(lst[n].infop_check, infop_check_lst)
			lst[n].infop_set = {}
			parse_infop(lst[n].infop_set, infop_set_lst)
			n = n + 1
		end
		return lst
	else
		return
	end
	--/ SGM out
end
xr_logic.cfg_get_switch_conditions = function(ini, section, npc)
	local l = {}
	local t
	local n = 1
	if not ini:section_exist(tostring(section)) then
		return
	end
	local line_count = ini:line_count(section)
	local function add_conditions(func, cond)
		for line_number = 0, line_count - 1 do
			local result, id, value = ini:r_line(section, line_number, "", "")
			if string.find(id, "^" .. cond .. "%d*$") ~= nil then
				c = func(ini, section, id, npc)
				n = add_condition(l, n, c)
			end
		end
	end
	--/ SGM in
	add_conditions(cfg_get_string_and_condlist, "on_actor_see")
	--/ SGM out
	add_conditions(cfg_get_number_and_condlist, "on_actor_dist_le")
	add_conditions(cfg_get_number_and_condlist, "on_actor_dist_le_nvis")
	add_conditions(cfg_get_number_and_condlist, "on_actor_dist_ge")
	add_conditions(cfg_get_number_and_condlist, "on_actor_dist_ge_nvis")
	add_conditions(cfg_get_string_and_condlist, "on_signal")
	--/ SGM in
	add_conditions(cfg_get_string_and_condlist, "shooter_switch")
	add_conditions(cfg_get_string_and_condlist, "on_patrol_path")
	--/ SGM out
	add_conditions(cfg_get_condlist, "on_info")
	add_conditions(cfg_get_number_and_condlist, "on_timer")
	add_conditions(cfg_get_number_and_condlist, "on_game_timer")
	add_conditions(cfg_get_string_and_condlist, "on_actor_in_zone")
	add_conditions(cfg_get_string_and_condlist, "on_actor_not_in_zone")
	add_conditions(cfg_get_condlist, "on_actor_inside")
	add_conditions(cfg_get_condlist, "on_actor_outside")
	add_conditions(cfg_get_npc_and_zone, "on_npc_in_zone")
	add_conditions(cfg_get_npc_and_zone, "on_npc_not_in_zone")
	return l
end

xr_logic.pstor_store = function(obj, varname, val)
	--/ SGM in
	if obj == nil then return nil end
	--/ SGM out
	local npc_id = obj:id()
	if db.storage[npc_id].pstor == nil then
		db.storage[npc_id].pstor = {}
	end
	local tv = type(val)
	if val ~= nil and not pstor_is_registered_type(tv) then
		abort("xr_logic: pstor_store: not registered type '%s' encountered", tv)
	end
	--/ SGM in
	if val ~= nil and pstor_is_registered_type(tv) then
		db.storage[npc_id].pstor[varname] = val
	end
	--/ SGM out
end
xr_logic.pstor_retrieve = function(obj, varname, defval)
	--/ SGM in
	if obj == nil then return nil end
	--/ SGM out
	local npc_id = obj:id()
	if db.storage[npc_id].pstor ~= nil then
		local val = db.storage[npc_id].pstor[varname]
		if val ~= nil then
			return val
		end
	end
	if defval ~= nil then
		return defval
	end
	return nil
end

xr_logic.pstor_clear = function(obj, varname)
	local npc_id = obj:id()
	local opt = reload_params(varname)
	if db.storage[npc_id].pstor[opt] then
		db.storage[npc_id].pstor[opt] = nil
	end
end
xr_logic.reload_params = function(params)
	return params
end

--/ SGM out
