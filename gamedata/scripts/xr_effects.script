-- ----------------------------------------------------------------------------------------------------
-- Общие функции
-- ----------------------------------------------------------------------------------------------------
-- Принудительно апдейтит логику у объектов, переданных параметром. Пока работает только с НПС
function update_npc_logic(actor, object, p)
	--printf("UPDATE NPC LOGIC %s", device():time_global())
	for k, v in pairs(p) do
		local npc = get_story_object(v)
		if npc ~= nil then
			xr_motivator.update_logic(npc)
			local planner = npc:motivation_action_manager()
			planner:update()
			planner:update()
			planner:update()
			db.storage[npc:id()].state_mgr:update()
			db.storage[npc:id()].state_mgr:update()
			db.storage[npc:id()].state_mgr:update()
			db.storage[npc:id()].state_mgr:update()
			db.storage[npc:id()].state_mgr:update()
			db.storage[npc:id()].state_mgr:update()
			db.storage[npc:id()].state_mgr:update()
		end
	end
end

function update_obj_logic(actor, object, p)
	--printf("UPDATE OBJ LOGIC %s", device():time_global())
	for k, v in pairs(p) do
		local obj = get_story_object(v)
		if obj ~= nil then
			local st = db.storage[obj:id()]
			xr_logic.try_switch_to_another_section(obj, st[st.active_scheme], actor)
		end
	end
end

local ui_active_slot = 0
function disable_ui(actor, npc, p)
	if db.actor:is_talking() then
		db.actor:stop_talk()
	end
	level.show_weapon(false)
	if not p or (p and p[1] ~= "true") then
		local slot = db.actor:active_slot()
		if (slot ~= 0) then
			ui_active_slot = slot
			db.actor:activate_slot(0)
		end
	end
	level.disable_input()
	level.hide_indicators_safe()
	local hud = get_hud()
	hud:HideActorMenu()
	hud:HidePdaMenu()
	disable_actor_nightvision(nil, nil)
	disable_actor_torch(nil, nil)
	--/ SGM in
	set_ui_disabled()
	--/ SGM out
end

function disable_ui_only(actor, npc)
	if db.actor:is_talking() then
		db.actor:stop_talk()
	end
	level.show_weapon(false)
	if not p or (p and p[1] ~= "true") then
		local slot = db.actor:active_slot()
		if (slot ~= 0) then
			ui_active_slot = slot
			db.actor:activate_slot(0)
		end
	end
	level.disable_input()
	level.hide_indicators_safe()
	local hud = get_hud()
	hud:HideActorMenu()
	hud:HidePdaMenu()
	--/ SGM in
	set_ui_disabled()
	--/ SGM out
end

function enable_ui(actor, npc, p)
	if not p or (p and p[1] ~= "true") then
		if ui_active_slot ~= 0 and db.actor:item_in_slot(ui_active_slot) ~= nil then
			db.actor:activate_slot(ui_active_slot)
		end
	end
	ui_active_slot = 0
	level.show_weapon(true)
	level.enable_input()
	level.show_indicators()
	enable_actor_nightvision(nil, nil)
	enable_actor_torch(nil, nil)
	--/ SGM in
	db.actor:disable_info_portion("game_disable_ui")
	if (sgm_g.dont_has_alife_info("pri_a28_cam_started")) or has_alife_info("pri_a28_actor_in_zone_stay") then
		set_ui_worked()
	end
	--/ SGM out
end

local cam_effector_playing_object_id = nil
function run_cam_effector(actor, npc, p)
	if p[1] then
		local loop, num = false, (1000 + math.random(100))
		if p[2] and type(p[2]) == "number" and p[2] > 0 then
			num = p[2]
		end
		if p[3] and p[3] == "true" then
			loop = true
		end
		--level.add_pp_effector(p[1] .. ".ppe", num, loop)
		level.add_cam_effector("camera_effects\\" .. p[1] .. ".anm", num, loop, "xr_effects.cam_effector_callback")
		cam_effector_playing_object_id = npc:id()
	end
end

function stop_cam_effector(actor, npc, p)
	if p[1] and type(p[1]) == "number" and p[1] > 0 then
		level.remove_cam_effector(p[1])
	end
end

function run_cam_effector_global(actor, npc, p)
	local num = 1000 + math.random(100)
	if p[2] and type(p[2]) == "number" and p[2] > 0 then
		num = p[2]
	end
	local fov = device().fov
	if p[3] ~= nil and type(p[3]) == "number" then
		fov = p[3]
	end
	level.add_cam_effector2("camera_effects\\" .. p[1] .. ".anm", num, false, "xr_effects.cam_effector_callback", fov)
	cam_effector_playing_object_id = npc:id()
end

function cam_effector_callback()
	if cam_effector_playing_object_id == nil then
		printf("cam_eff:callback1!")
		return
	end
	local st = db.storage[cam_effector_playing_object_id]
	if st == nil or st.active_scheme == nil then
		printf("cam_eff:callback2!")
		return
	end

	if st[st.active_scheme].signals == nil then
		printf("cam_eff:callback3!")
		return
	end
	st[st.active_scheme].signals["cameff_end"] = true
end

function run_postprocess(actor, npc, p)
	if (p[1]) then
		if (system_ini():section_exist(p[1])) then
			local num = 2000 + math.random(100)
			if (p[2] and type(p[2]) == "number" and p[2] > 0) then
				num = p[2]
			end
			printf("adding complex effector [%s], id [%s], from [%s]", p[1], tostring(p[2]), tostring(npc:name()))
			level.add_complex_effector(p[1], num)
		else
			abort("Complex effector section is no set! [%s]", tostring(p[1]))
		end
	end
end

function stop_postprocess(actor, npc, p)
	if (p[1] and type(p[1]) == "number" and p[1] > 0) then
		printf("removing complex effector id [%s] from [%s]", tostring(p[1]), tostring(npc:name()))
		level.remove_complex_effector(p[1])
	end
end

function run_tutorial(actor, npc, p)
	printf("run tutorial called")
	--/ SGM in
	sgm_callbacks.on_run_tutorial(p[1])
	--/ SGM out
end

--[[
function run_tutorial_if_newbie(actor, npc, p)
	if has_alife_info("esc_trader_newbie") then
		game.start_tutorial(p[1])
	end
end
]] --

function jup_b32_place_scanner(actor, npc)
	for i = 1, 5 do
		if xr_conditions.actor_in_zone(actor, npc, { "jup_b32_sr_scanner_place_" .. i })
			and sgm_g.dont_has_alife_info("jup_b32_scanner_" .. i .. "_placed") then
			db.actor:give_info_portion("jup_b32_scanner_" .. i .. "_placed")
			db.actor:give_info_portion("jup_b32_tutorial_done")
			remove_item(actor, npc, { "jup_b32_scanner_device" })
			spawn_object(actor, nil, { "jup_b32_ph_scanner", "jup_b32_scanner_place_" .. i })
		end
	end
end

function jup_b32_pda_check(actor, npc)
	pda.change_anomalies_names()
end

function pri_b306_generator_start(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "pri_b306_sr_generator" }) then
		give_info("pri_b306_lift_generator_used")
	end
end

function jup_b206_get_plant(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "jup_b206_sr_quest_line" }) then
		give_info("jup_b206_anomalous_grove_has_plant")
		give_actor(actor, npc, { "jup_b206_plant" })
		destroy_object(actor, npc, { "story", "jup_b206_plant_ph" })
	end
end

function pas_b400_switcher(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "pas_b400_sr_switcher" }) then
		give_info("pas_b400_switcher_use")
	end
end

function jup_b209_place_scanner(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "jup_b209_hypotheses" }) then
		scenario_autosave(db.actor, nil, { "st_save_jup_b209_placed_mutant_scanner" })
		db.actor:give_info_portion("jup_b209_scanner_placed")
		remove_item(actor, npc, { "jup_b209_monster_scanner" })
		spawn_object(actor, nil, { "jup_b209_ph_scanner", "jup_b209_scanner_place_point" })
	end
end

function jup_b9_heli_1_searching(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "jup_b9_heli_1" })
	then
		db.actor:give_info_portion("jup_b9_heli_1_searching")
	end
end

function pri_a18_use_idol(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "pri_a18_use_idol_restrictor" })
	then
		db.actor:give_info_portion("pri_a18_run_cam")
	end
end

function jup_b8_heli_4_searching(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "jup_b8_heli_4" })
	then
		db.actor:give_info_portion("jup_b8_heli_4_searching")
	end
end

function jup_b10_ufo_searching(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "jup_b10_ufo_restrictor" })
	then
		db.actor:give_info_portion("jup_b10_ufo_memory_started")
		give_actor(db.actor, nil, { "jup_b10_ufo_memory" })
	end
end

function zat_b101_heli_5_searching(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "zat_b101_heli_5" })
	then
		db.actor:give_info_portion("zat_b101_heli_5_searching")
	end
end

function zat_b28_heli_3_searching(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "zat_b28_heli_3" })
	then
		db.actor:give_info_portion("zat_b28_heli_3_searching")
	end
end

function zat_b100_heli_2_searching(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "zat_b100_heli_2" }) then
		db.actor:give_info_portion("zat_b100_heli_2_searching")
	end
end

function teleport_actor(actor, npc, p)
	local point = patrol(p[1])
	local dir
	if p[2] ~= nil then
		local look = patrol(p[2])
		dir = -look:point(0):sub(point:point(0)):getH()
		db.actor:set_actor_direction(dir)
	end
	for k, v in pairs(db.no_weap_zones) do
		local zone = db.zone_by_name[k]
		if utils.npc_in_zone(db.actor, zone) then
			db.no_weap_zones[k] = true
		end
	end
	if npc and npc:name() ~= nil then
		printf("teleporting actor from [%s]", tostring(npc:name()))
	end
	db.actor:set_actor_position(point:point(0))
end

local function reset_animation(npc)
	local state_mgr = db.storage[npc:id()].state_mgr
	if state_mgr == nil then
		return
	end
	local planner = npc:motivation_action_manager()

	state_mgr.animation:set_state(nil, true)
	state_mgr.animation:set_control()
	state_mgr.animstate:set_state(nil, true)
	state_mgr.animstate:set_control()

	state_mgr:set_state("idle", nil, nil, nil, { fast_set = true })

	--	planner:update()
	--	planner:update()
	--	planner:update()

	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()

	npc:set_body_state(move.standing)
	npc:set_mental_state(anim.free)
end


function teleport_npc(actor, npc, p)
	local patrol_point = p[1]
	local patrol_point_index = p[2] or 0
	if patrol_point == nil then
		abort("Wrong parameters in 'teleport_npc' function!!!")
	end
	local position = patrol(patrol_point):point(patrol_point_index)
	reset_animation(npc)

	npc:set_npc_position(position)
end

function teleport_npc_by_story_id(actor, npc, p)
	local story_id = p[1]
	local patrol_point = p[2]
	local patrol_point_index = p[3] or 0
	if story_id == nil or patrol_point == nil then
		abort("Wrong parameters in 'teleport_npc_by_story_id' function!!!")
	end
	local position = patrol(tostring(patrol_point)):point(patrol_point_index)
	local npc_id = get_story_object_id(story_id)
	if npc_id == nil then
		abort("There is no story object with id [%s]", story_id)
	end
	local cl_object = level.object_by_id(npc_id)
	if cl_object then
		reset_animation(cl_object)
		cl_object:set_npc_position(position)
	else
		alife():object(npc_id).position = position
	end
end

function teleport_squad(actor, npc, p)
	local squad_story_id = p[1]
	local patrol_point = p[2]
	local patrol_point_index = p[3] or 0
	if squad_story_id == nil or patrol_point == nil then
		abort("Wrong parameters in 'teleport_squad' function!!!")
	end
	local position = patrol(patrol_point):point(patrol_point_index)
	local squad = get_story_squad(squad_story_id)
	if squad == nil then
		abort("There is no squad with story id [%s]", squad_story_id)
	end
	squad:set_squad_position(position)
end

function jup_teleport_actor(actor, npc)
	local point_in = patrol("jup_b16_teleport_in"):point(0)
	local point_out = patrol("jup_b16_teleport_out"):point(0)
	local actor_position = actor:position()
	local out_position = vector():set(actor_position.x - point_in.x + point_out.x,
		actor_position.y - point_in.y + point_out.y, actor_position.z - point_in.z + point_out.z)
	db.actor:set_actor_position(out_position)
end

-----------------------------------------------------------------------------
--[[
local drop_point, drop_object = 0, 0
local function drop_object_item(item)
	drop_object:drop_item_and_teleport(item, drop_point)
end

function drop_actor_inventory(actor, npc, p)
	if p[1] then
		drop_point  = patrol(p[1]):point(0)
		drop_object = actor
		actor:inventory_for_each(drop_object_item)
	end
end


-- FIXME: drop_npc_inventory doesn't work
function drop_npc_inventory(actor, npc, p)
	if p[1] then
		drop_point  = patrol(p[1]):point(0)
		drop_object = npc
		npc:inventory_for_each(drop_object_item)
	end
end

function drop_npc_item(actor, npc, p)
	if p[1] then
		local item = npc:object(p[1])
		if item then
			npc:drop_item(item)
		end
	end
end

function drop_npc_items(actor, npc, p)
	local item = 0
	for i, v in pairs(p) do
		item = npc:object(v)
		if item then
			npc:drop_item(item)
		end
	end
end
]] --

function give_items(actor, npc, p)
	local pos, lv_id, gv_id, npc_id = npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id()
	for i, v in pairs(p) do
		alife():create(v, pos, lv_id, gv_id, npc_id)
	end
end

function give_item(actor, npc, p)
	if p[2] ~= nil then
		npc_id = get_story_object_id(p[2])
	else
		npc_id = npc:id()
	end
	npc = alife():object(npc_id)
	local pos, lv_id, gv_id, npc_id = npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id
	alife():create(p[1], pos, lv_id, gv_id, npc_id)
end

function play_particle_on_path(actor, npc, p)
	local name = p[1]
	local path = p[2]
	local point_prob = p[3]
	if name == nil or path == nil then
		return
	end
	if point_prob == nil then
		point_prob = 100
	end

	local path = patrol(path)
	local count = path:count()
	for a = 0, count - 1, 1 do
		local particle = particles_object(name)
		if math.random(100) <= point_prob then
			particle:play_at_pos(path:point(a))
		end
	end
end

-----------------------------------------------------------------------------
--[[
send_tip(news_id:sender:sender_id)
		1. news_id
		2. sender*
		3. sender_id*
		* - not necessary
--]]
function send_tip(actor, npc, p)
	--/ SGM in
	news_manager.send_tip(actor, p[1], nil, p[2], p[4], p[5], p[3])
	--/ SGM out
end

--[[
Дать сталкеру небольшой пинок. Например чтоб скинуть его с возвышения.
параметры: actor, npc, p[direction,bone,power,impulse,reverse=false]
		1. direction - если строка, то считается, что это имя пути и в сторону
				первой точки производится толчек. Если же это число, то оно
				рассматривается как story_id персонажа от которого должен поступить хит.
		2. bone - строка. Имя кости, по которой наносится удар.
		3. power - сила удара
		4. impulse - импульс
		5. reverse (true/false) - изменение направления удара. по умолчанию false
--]]
function hit_npc(actor, npc, p)
	local h = hit()
	local rev = p[6] and p[6] == 'true'
	h.draftsman = npc
	h.type = hit.wound
	if p[1] ~= "self" then
		local hitter = get_story_object(p[1])
		if not hitter then return end
		if rev then
			h.draftsman = hitter
			h.direction = hitter:position():sub(npc:position())
		else
			h.direction = npc:position():sub(hitter:position())
		end
	else
		if rev then
			h.draftsman = nil
			h.direction = npc:position():sub(patrol(p[2]):point(0))
		else
			h.direction = patrol(p[2]):point(0):sub(npc:position())
		end
	end
	h:bone(p[3])
	h.power = p[4]
	h.impulse = p[5]
	printf("HIT EFFECT: (%s, %s,%d,%d) health(%s)", npc:name(), p[2], h.power, h.impulse, npc.health)
	npc:hit(h)
end

--[[
Дать обьекту, заданному story_id, хит.
параметры: actor, npc, p[sid,bone,power,impulse,hit_src=npc:position()]
		1. sid - story_id обьекта, по которому наносится хит.
		2. bone - строка. Имя кости, по которой наносится удар.
		3. power - сила удара
		4. impulse - импульс
		5. hit_src - если число, то рассматривается как story_id обьекта, со стороны
				которого наносится хит (он же является и инициатором хита), иначе это
				точка (waypoint), из которой по объекту наносится хит.
				Если не задано, то берется позиция обьекта, из которого была вызвана
				данная функция.
--]]
function hit_obj(actor, npc, p)
	local h = hit()
	local obj = get_story_object(p[1])
	local sid = nil

	if not obj then
		--    abort("HIT_OBJ [%s]. Target object does not exist", npc:name())
		return
	end

	h:bone(p[2])
	h.power = p[3]
	h.impulse = p[4]

	if p[5] then
		sid = get_story_object(sid)
		if sid then
			h.direction = vector():sub(sid:position(), obj:position())
		end
		if not sid then
			h.direction = vector():sub(patrol(p[5]):point(0), obj:position())
		end
	else
		h.direction = vector():sub(npc:position(), obj:position())
	end
	h.draftsman = sid or npc
	h.type = hit.wound
	obj:hit(h)
end

--[[
function hit_obj_chemical(actor, npc, p)
	local h = hit()
	local obj = get_story_object(p[1])
	local sid = nil

	if not obj then
--    abort("HIT_OBJ [%s]. Target object does not exist", npc:name())
		return
	end

	h:bone(p[2])
	h.power = p[3]
	h.impulse = p[4]

	if p[5] then
		sid = get_story_object(sid)
		if sid then
			h.direction = vector():sub(sid:position(), obj:position())
		end
		if not sid then
			h.direction = vector():sub(patrol(p[5]):point(0), obj:position())
		end
	else
		h.direction = vector():sub(npc:position(), obj:position())
	end

	h.draftsman = sid or npc
	h.type = hit.chemical_burn
	obj:hit(h)
end

function hit_obj_fire_wound(actor, npc, p)
	local h = hit()
	local obj = get_story_object(p[1])
	local sid = nil

	if not obj then
--    abort("HIT_OBJ [%s]. Target object does not exist", npc:name())
		return
	end

	h:bone(p[2])
	h.power = p[3]
	h.impulse = p[4]

	if p[5] then
		sid = get_story_object(sid)
		if sid then
			h.direction = vector():sub(sid:position(), obj:position())
		end
		if not sid then
			h.direction = vector():sub(patrol(p[5]):point(0), obj:position())
		end
	else
		h.direction = vector():sub(npc:position(), obj:position())
	end

	h.draftsman = sid or npc
	h.type = hit.fire_wound
	obj:hit(h)
end
]] --
--[[
Дать сталкеру небольшой пинок после смерти. Аналогично предыдущему, только направление хита теперь
вычисляется через убийцу. Поэтому параметра direction нет.
параметры: actor, npc, p[bone,power,impulse]
FIXME: killer:position() isn't working
--]]
function hit_by_killer(actor, npc, p)
	if not npc then return end
	local t = db.storage[npc:id()].death
	if t == nil or t.killer == -1 then return end
	local killer = db.storage[t.killer]
	if killer == nil then return end
	local p1, p2
	p1 = npc:position()
	p2 = killer:position()
	local h = hit()
	h.draftsman = npc
	h.type = hit.wound
	h.direction = utils.vector_copy_by_val(p1):sub(p2)
	h.bone = p[1]
	h.power = p[2]
	h.impulse = p[3]
	npc:hit(h)
end

function hit_npc_from_actor(actor, npc, p)
	local h = hit()
	local sid = nil
	h.draftsman = actor
	h.type = hit.wound

	if p and p[1] then
		sid = get_story_object(p[1])
		if sid then
			h.direction = actor:position():sub(sid:position())
		end
		if not sid then
			h.direction = actor:position():sub(npc:position())
		end
	else
		h.direction = actor:position():sub(npc:position())
		sid = npc
	end

	h:bone("bip01_spine")
	h.power = 0.001
	h.impulse = 0.001
	sid:hit(h)
end

--[[
-- Хитует нпс от нпс, если задан один параметр (стори айди), то нпс с таким стори айди хитнет нпс у которого вызвали эту функцию.
-- если задано 2 стори айди , то нпс с 1-ым стори айди хитнет нпс со 2-ым стори айди.
function hit_npc_from_npc(actor, npc, p)
	if p == nil then abort("Invalid parameter in function 'hit_npc_from_npc'!!!!") end
	local h = hit()
	local hitted_npc = npc
	h.draftsman = get_story_object(p[1])
	if p[2] ~= nil then
		hitted_npc = get_story_object(p[2])
	end
	h.type = hit.wound
	h.direction = h.draftsman:position():sub(hitted_npc:position())
	h:bone("bip01_spine")
	h.power = 0.03
	h.impulse = 0.03
	hitted_npc:hit(h)
end

function hit_actor(actor, npc, p)
	local h = hit()
	h.direction = vector():set(0,0,0)
	h.draftsman = actor
	h.type = hit.shock
	h:bone("bip01_spine")
	h.power = (p and p[1] and tonumber(p[1])) or 0.001
	h.impulse = 0.001
	actor:hit(h)
end
]] --

function restore_health(actor, npc)
	--printf("HEALTH RESTORE")
	npc.health = 1
end

function make_enemy(actor, npc, p)
	if p == nil then abort("Invalid parameter in function 'hit_npc_from_npc'!!!!") end
	local h = hit()
	local hitted_npc = npc
	h.draftsman = get_story_object(p[1])
	if p[2] ~= nil then
		hitted_npc = get_story_object(p[2])
	end
	h.type = hit.wound
	h.direction = h.draftsman:position():sub(hitted_npc:position())
	h:bone("bip01_spine")
	h.power = 0.03
	h.impulse = 0.03
	hitted_npc:hit(h)
end

function sniper_fire_mode(actor, npc, p)
	if p[1] == "true" then
		--printf("SNIPER FIRE MODE ON")
		npc:sniper_fire_mode(true)
	else
		--printf("SNIPER FIRE MODE OFF")
		npc:sniper_fire_mode(false)
	end
end

function kill_npc(actor, npc, p)
	if p and p[1] then
		npc = get_story_object(p[1])
	end
	if npc ~= nil and npc:alive() then
		npc:kill(npc)
	end
end

function remove_npc(actor, npc, p)
	if p and p[1] then
		npc_id = get_story_object_id(p[1])
	end
	--/ SGM in
	if npc_id ~= nil and alife():object(npc_id) then
		sgm_g.clear_mod_params_for_npc(npc_id)
		alife():release(alife():object(npc_id), true)
	end
	--/ SGM out
end

-- прибавить к указанному счётчику актёра 1
function inc_counter(actor, npc, p)
	if p and p[1] then
		local inc_value = p[2] or 1
		local new_value = xr_logic.pstor_retrieve(actor, p[1], 0) + inc_value
		if npc and npc:name() then
			printf("inc_counter '%s'  to value [%s], by [%s]", p[1], tostring(new_value), tostring(npc:name()))
		end
		xr_logic.pstor_store(actor, p[1], new_value)
	end
end

function dec_counter(actor, npc, p)
	if p and p[1] then
		local dec_value = p[2] or 1
		local new_value = xr_logic.pstor_retrieve(actor, p[1], 0) - dec_value
		if new_value < 0 then
			new_value = 0
		end
		xr_logic.pstor_store(actor, p[1], new_value)
		if npc and npc:name() then
			printf("dec_counter [%s] value [%s] by [%s]", p[1], xr_logic.pstor_retrieve(actor, p[1], 0),
				tostring(npc:name()))
		end
	end
end

function set_counter(actor, npc, p)
	if p and p[1] then
		local count = p[2] or 0
		xr_logic.pstor_store(actor, p[1], count)
	end
end

------------------------------------------------------------------------------------------------------------------------
-- постпроцесс и влияние удара в морду
function actor_punch(npc)
	if db.actor:position():distance_to_sqr(npc:position()) > 4 then
		return
	end

	set_inactivate_input_time(30)
	level.add_cam_effector("camera_effects\\fusker.anm", 999, false, "")

	local active_slot = db.actor:active_slot()
	if active_slot ~= 2 and
		active_slot ~= 3
	then
		return
	end

	local active_item = db.actor:active_item()
	if active_item then
		db.actor:drop_item(active_item)
	end
end

-- забывание обиды
function clearAbuse(npc)
	printf("CLEAR_ABUSE")
	xr_abuse.clear_abuse(npc)
end

function turn_off_underpass_lamps(actor, npc)
	local lamps_table = {
		["pas_b400_lamp_start_flash"] = true,
		["pas_b400_lamp_start_red"] = true,
		["pas_b400_lamp_elevator_green"] = true,
		["pas_b400_lamp_elevator_flash"] = true,
		["pas_b400_lamp_elevator_green_1"] = true,
		["pas_b400_lamp_elevator_flash_1"] = true,
		["pas_b400_lamp_track_green"] = true,
		["pas_b400_lamp_track_flash"] = true,
		["pas_b400_lamp_downstairs_green"] = true,
		["pas_b400_lamp_downstairs_flash"] = true,
		["pas_b400_lamp_tunnel_green"] = true,
		["pas_b400_lamp_tunnel_flash"] = true,
		["pas_b400_lamp_tunnel_green_1"] = true,
		["pas_b400_lamp_tunnel_flash_1"] = true,
		["pas_b400_lamp_control_down_green"] = true,
		["pas_b400_lamp_control_down_flash"] = true,
		["pas_b400_lamp_control_up_green"] = true,
		["pas_b400_lamp_control_up_flash"] = true,
		["pas_b400_lamp_hall_green"] = true,
		["pas_b400_lamp_hall_flash"] = true,
		["pas_b400_lamp_way_green"] = true,
		["pas_b400_lamp_way_flash"] = true,
	}
	local obj
	for k, v in pairs(lamps_table) do
		obj = get_story_object(k)

		if obj then
			obj:get_hanging_lamp():turn_off()
		else
			printf("function 'turn_off_underpass_lamps' lamp [%s] does not exist", tostring(k))
			--abort("function 'turn_off_underpass_lamps' lamp [%s] does not exist", tostring(k))
		end
	end
end

---Выключение динамической лампочки (hanging_lamp)
function turn_off(actor, npc, p)
	local obj
	for k, v in pairs(p) do
		obj = get_story_object(v)

		if not obj then
			abort("TURN_OFF. Target object with story_id [%s] does not exist", v)
			return
		end
		obj:get_hanging_lamp():turn_off()
		--printf("TURN_OFF. Target object with story_id [%s] turned off.", v)
	end
end

function turn_off_object(actor, npc)
	npc:get_hanging_lamp():turn_off()
end

---Включение динамической лампочки (hanging_lamp)
function turn_on(actor, npc, p)
	local obj
	for k, v in pairs(p) do
		obj = get_story_object(v)

		if not obj then
			abort("TURN_ON [%s]. Target object does not exist", npc:name())
			return
		end
		obj:get_hanging_lamp():turn_on()
	end
end

---Включение и запуск динамической лампочки (hanging_lamp)
function turn_on_and_force(actor, npc, p)
	local obj = get_story_object(p[1])
	if not obj then
		abort("TURN_ON_AND_FORCE. Target object does not exist")
		return
	end
	if p[2] == nil then p[2] = 55 end
	if p[3] == nil then p[3] = 14000 end
	obj:set_const_force(vector():set(0, 1, 0), p[2], p[3])
	obj:start_particles("weapons\\light_signal", "link")
	obj:get_hanging_lamp():turn_on()
end

---Выключение динамической лампочки и партиклов (hanging_lamp)
function turn_off_and_force(actor, npc, p)
	local obj = get_story_object(p[1])
	if not obj then
		abort("TURN_OFF [%s]. Target object does not exist", npc:name())
		return
	end
	obj:stop_particles("weapons\\light_signal", "link")
	obj:get_hanging_lamp():turn_off()
end

function turn_on_object(actor, npc)
	npc:get_hanging_lamp():turn_on()
end

function turn_off_object(actor, npc)
	npc:get_hanging_lamp():turn_off()
end

-- Вызов этой функции отключит обработчик [combat] боя для персонажа.
-- Используется в случаях, когда все необходимые действия, такие как переключение на другую секцию,
-- уже выполнены, и повторно выполнять их во время боя нельзя (а условия секции [combat] проверяются на каждом
-- апдейте, когда персонаж в бою, если, конечно, не отключены вызовом этой функции).
function disable_combat_handler(actor, npc)
	if db.storage[npc:id()].combat then
		db.storage[npc:id()].combat.enabled = false
	end

	if db.storage[npc:id()].mob_combat then
		db.storage[npc:id()].mob_combat.enabled = false
	end
end

-- Вызов этой функции отключит обработчик [combat_ignore] перехвата боя для персонажа.
function disable_combat_ignore_handler(actor, npc)
	if db.storage[npc:id()].combat_ignore then
		db.storage[npc:id()].combat_ignore.enabled = false
	end
end

-------------------------------------------------------------------------------------
-- Функции для работы с вертолётами
-------------------------------------------------------------------------------------
--[[
function heli_set_enemy_actor(actor, npc)
	local st = db.storage[npc:id()]
	if not st.combat.enemy_id and actor:alive() then
		st.combat.enemy_id = actor:id()
		heli_snd.play_snd( st, heli_snd.snd_see_enemy, 1 )
	end
end

function heli_set_enemy(actor, npc, p)
	local st  = db.storage[npc:id()]
	local obj = get_story_object( p[1] )
	if not st.combat.enemy_id and obj:alive() then
		st.combat.enemy_id = obj:id()
		heli_snd.play_snd( st, heli_snd.snd_see_enemy, 1 )
	end
end

function heli_clear_enemy(actor, npc)
	db.storage[npc:id()].combat:forget_enemy()
end
]] --

function heli_start_flame(actor, npc)
	bind_heli.heli_start_flame(npc)
end

function heli_die(actor, npc)
	bind_heli.heli_die(npc)
end

--'-----------------------------------------------------------------------------------
--' Функции для работы с погодными эффектами
--'-----------------------------------------------------------------------------------

-- Принудительная установка погодных условий
-- =set_weather(<секция погоды>:true) - установка погоды сразу, false - через некоторое время
-- Будет использоваться на старте игры Зов Припяти и в сцене jup_b15 - утро после пьянки с Зулусом
function set_weather(actor, npc, p)
	if (p[1]) then
		if (p[2] == "true") then
			level.set_weather(p[1], true)
		else
			level.set_weather(p[1], false)
		end
	end
end

--[[
function update_weather(actor, npc, p)
	if p and p[1] then
		if p[1] == "true" then
			level_weathers.get_weather_manager():select_weather(true)
		elseif p[1] == "false" then
			level_weathers.get_weather_manager():select_weather(false)
		end
	end
end

function start_small_reject(actor, npc)
	level.set_weather_fx("fx_surge_day_3")
	level.add_pp_effector("vibros_p.ppe", 1974, false)
	this.aes_earthshake(npc)
end

function start_full_reject(actor, npc)
	level.set_weather_fx("fx_surge_day_3")
	level.remove_pp_effector(1974)
	level.remove_cam_effector(1975)
	level.add_cam_effector("camera_effects\\earthquake.anm", 1975, true, "")
end

function stop_full_reject(actor, npc)
	level.remove_pp_effector(1974)
	level.remove_cam_effector(1975)
end

function run_weather_pp(actor,npc, p)
	local weather_fx = p[1]
	if weather_fx == nil then
		weather_fx = "fx_surge_day_3"
	end
	level.set_weather_fx(weather_fx)
end
]] --

function game_disconnect(actor, npc)
	local c = get_console()
	c:execute("disconnect")
	--	c:execute_deferred("main_menu off")
	--	c:execute_deferred("hide")
end

function game_credits(actor, npc)
	db.gameover_credits_started = true
	game.start_tutorial("credits_seq")
end

function game_over(actor, npc)
	if db.gameover_credits_started ~= true then
		return
	end
	local c = get_console()
	printf("main_menu on console command is executed")
	c:execute("main_menu on")
end

function after_credits(actor, npc)
	get_console():execute("main_menu on")
end

function before_credits(actor, npc)
	get_console():execute("main_menu off")
end

function on_tutor_gameover_stop()
	local c = get_console()
	printf("main_menu on console command is executed")
	c:execute("main_menu on")
end

function on_tutor_gameover_quickload()
	local c = get_console()
	c:execute("load_last_save")
end

-- для смены работы
function get_stalker_for_new_job(actor, npc, p)
	xr_gulag.find_stalker_for_job(npc, p[1])
end

function switch_to_desired_job(actor, npc, p)
	xr_gulag.switch_to_desired_job(npc)
end

--[[
function death_hit(actor, npc, p)
	 local draftsman = get_story_object (p[1])
	 local hitted_obj = (p[2] ~= nil and get_story_object (p[2])) or npc
	 if draftsman == nil or hitted_obj == nil then
		return
	 end
	 local h = hit()
	 h.power = 1000
	 h.direction = hitted_obj:direction()
	 h.draftsman = draftsman
	 h.impulse = 1
	 h.type = hit.wound
	 hitted_obj:hit(h)
end
]] --

--'-----------------------------------------------------------------------------------
--' Функции для работы с подспауном
--'-----------------------------------------------------------------------------------
function spawn_object(actor, obj, p)
	--' p[1] - секция кого спаунить
	--' p[2] - имя патрульного пути где спа унить.
	local spawn_sect = p[1]
	if spawn_sect == nil then
		abort("Wrong spawn section for 'spawn_object' function %s. For object %s", tostring(spawn_sect), obj:name())
	end

	local path_name = p[2]
	if path_name == nil then
		abort("Wrong path_name for 'spawn_object' function %s. For object %s", tostring(path_name), obj:name())
	end

	if not level.patrol_path_exists(path_name) then
		abort("Path %s doesnt exist. Function 'spawn_object' for object %s ", tostring(path_name), obj:name())
	end
	local ptr = patrol(path_name)
	local index = p[3] or 0
	local yaw = p[4] or 0

	--' printf("Spawning %s at %s, %s", tostring(p[1]), tostring(p[2]), tostring(p[3]))
	local se_obj = alife():create(spawn_sect,
		ptr:point(index),
		ptr:level_vertex_id(0),
		ptr:game_vertex_id(0))
	if IsStalker(nil, se_obj:clsid()) then
		se_obj:o_torso().yaw = yaw * math.pi / 180
	elseif se_obj:clsid() == clsid.script_phys then
		se_obj:set_yaw(yaw * math.pi / 180)
	end
end

local jup_b219_position
local jup_b219_lvid
local jup_b219_gvid

function jup_b219_save_pos()
	local obj = get_story_object("jup_b219_gate_id")
	if obj and obj:position() then
		jup_b219_position = obj:position()
		jup_b219_lvid = obj:level_vertex_id()
		jup_b219_gvid = obj:game_vertex_id()
	else
		return
	end
	sobj = alife():object(obj:id())
	if sobj then
		alife():release(sobj, true)
	end
end

function jup_b219_restore_gate()
	local yaw = 0
	local spawn_sect = "jup_b219_gate"
	if jup_b219_position then
		local se_obj = alife():create(spawn_sect,
			vector():set(jup_b219_position),
			jup_b219_lvid,
			jup_b219_gvid)
		se_obj:set_yaw(yaw * math.pi / 180)
	end
end

function spawn_corpse(actor, obj, p)
	--' p[1] - секция кого спаунить
	--' p[2] - имя патрульного пути где спаунить.
	local spawn_sect = p[1]
	if spawn_sect == nil then
		abort("Wrong spawn section for 'spawn_corpse' function %s. For object %s", tostring(spawn_sect), obj:name())
	end

	local path_name = p[2]
	if path_name == nil then
		abort("Wrong path_name for 'spawn_corpse' function %s. For object %s", tostring(path_name), obj:name())
	end

	if not level.patrol_path_exists(path_name) then
		abort("Path %s doesnt exist. Function 'spawn_corpse' for object %s ", tostring(path_name), obj:name())
	end
	local ptr = patrol(path_name)
	local index = p[3] or 0

	local se_obj = alife():create(spawn_sect,
		ptr:point(index),
		ptr:level_vertex_id(0),
		ptr:game_vertex_id(0))
	se_obj:kill()
end

function spawn_object_in(actor, obj, p)
	--' p[1] - секция кого спаунить
	--' p[2] - стори айди обьекта в который спавнить
	local spawn_sect = p[1]
	if spawn_sect == nil then
		abort("Wrong spawn section for 'spawn_object' function %s. For object %s", tostring(spawn_sect), obj:name())
	end
	if p[2] == nil then
		abort("Wrong target_name for 'spawn_object_in' function %s. For object %s", tostring(target_name), obj:name())
	end
	--	local box = alife():object(target_name)
	--	if(box==nil) then

	printf("trying to find object %s", tostring(p[2]))

	local target_obj_id = get_story_object_id(p[2])
	if target_obj_id ~= nil then
		box = alife():object(target_obj_id)
		if box == nil then
			abort("There is no such object %s", p[2])
		end
		alife():create(spawn_sect, vector(), 0, 0, target_obj_id)
	else
		abort("object is nil %s", tostring(p[2]))
	end
end

function spawn_npc_in_zone(actor, obj, p)
	--' p[1] - секция кого спаунить
	--' p[2] - имя зоны в которой спаунить.
	local spawn_sect = p[1]
	if spawn_sect == nil then
		abort("Wrong spawn section for 'spawn_object' function %s. For object %s", tostring(spawn_sect), obj:name())
	end
	local zone_name = p[2]
	if zone_name == nil then
		abort("Wrong zone_name for 'spawn_object' function %s. For object %s", tostring(zone_name), obj:name())
	end
	if db.zone_by_name[zone_name] == nil then
		abort("Zone %s doesnt exist. Function 'spawn_object' for object %s ", tostring(zone_name), obj:name())
	end
	local zone = db.zone_by_name[zone_name]
	--	printf("spawn_npc_in_zone: spawning %s at zone %s, squad %s", tostring(p[1]), tostring(p[2]), tostring(p[3]))
	local spawned_obj = alife():create(spawn_sect,
		zone:position(),
		zone:level_vertex_id(),
		zone:game_vertex_id())
	spawned_obj.sim_forced_online = true
	spawned_obj.squad = 1 or p[3]
	db.script_ids[spawned_obj.id] = zone_name
end

function destroy_object(actor, obj, p)
	local sobj
	if p == nil then
		sobj = alife():object(obj:id())
	else
		if p[1] == nil or p[2] == nil then
			abort("Wrong parameters in destroy_object function!!!")
		end
		local target_str = nil
		if p[3] ~= nil then
			target_str = p[1] .. "|" .. p[2] .. "," .. p[3]
		else
			target_str = p[1] .. "|" .. p[2]
		end
		local target_position, target_id, target_init = xr_remark.init_target(obj, target_str)
		if target_id == nil then
			printf("You are trying to set non-existant target [%s] for object [%s] in section [%s]", tostring(target_str),
				tostring(obj:name()), tostring(db.storage[obj:id()].active_section))
		end
		sobj = alife():object(target_id)
	end
	if sobj == nil then
		return
	end
	printf("releasing object [" .. sobj:name() .. "]")
	alife():release(sobj, true)
end

function give_actor(actor, npc, p)
	for k, v in pairs(p) do
		alife():create(v,
			db.actor:position(),
			db.actor:level_vertex_id(),
			db.actor:game_vertex_id(),
			db.actor:id())
		news_manager.relocate_item(db.actor, "in", v)
	end
end

function activate_weapon_slot(actor, npc, p)
	db.actor:activate_slot(p[1])
end

function anim_obj_forward(actor, npc, p)
	for k, v in pairs(p) do
		if v ~= nil then
			db.anim_obj_by_name[v]:anim_forward()
		end
	end
end

function anim_obj_backward(actor, npc, p)
	if p[1] ~= nil then
		db.anim_obj_by_name[p[1]]:anim_backward()
	end
end

function anim_obj_stop(actor, npc, p)
	if p[1] ~= nil then
		db.anim_obj_by_name[p[1]]:anim_stop()
	end
end

-- Функции для работы с огненными зонами.
--[[
function turn_on_fire_zone(actor, npc, p)
	bind_campfire.fire_zones_table[ p[1] ]:turn_on()
end

function turn_off_fire_zone(actor, npc, p)
	bind_campfire.fire_zones_table[ p[1] ]:turn_off()
end
]] --
--'-----------------------------------------------------------------------------------
--' Функции для отыгрывания звука
--'-----------------------------------------------------------------------------------
function play_sound(actor, obj, p)
	local theme = p[1]
	local faction = p[2]
	local point = sim_board.get_sim_board().smarts_by_names[p[3]]
	if point ~= nil then
		point = point.id
	elseif p[3] ~= nil then
		point = p[3]
	end

	if obj and IsStalker(obj) then
		if not obj:alive() then
			abort("Stalker [%s][%s] is dead, but you wants to say something for you: [%s]!", tostring(obj:id()),
				tostring(obj:name()), p[1])
		end
	end

	xr_sound.set_sound_play(obj:id(), theme, faction, point)
end

function play_sound_by_story(actor, obj, p)
	local story_obj = get_story_object_id(p[1])
	local theme = p[2]
	local faction = p[3]
	local point = sim_board.get_sim_board().smarts_by_names[p[4]]
	if point ~= nil then
		point = point.id
	elseif p[4] ~= nil then
		point = p[4]
	end
	xr_sound.set_sound_play(story_obj, theme, faction, point)
end

function stop_sound(actor, npc)
	xr_sound.stop_sounds_by_id(npc:id())
end

function play_sound_looped(actor, obj, p)
	local theme = p[1]
	xr_sound.play_sound_looped(obj:id(), theme)
end

function stop_sound_looped(actor, obj)
	xr_sound.stop_sound_looped(obj:id())
end

function barrel_explode(actor, npc, p)
	local expl_obj = get_story_object(p[1])
	if expl_obj ~= nil then
		expl_obj:explode(0)
	end
end

--'-----------------------------------------------------------------------------------
--' Alife support
--'-----------------------------------------------------------------------------------
--[[
function start_sim(actor, obj)
	sim_board.get_sim_board():start_sim()
end

function stop_sim(actor, obj)
	sim_board.get_sim_board():stop_sim()
end

function update_faction_brain(actor, obj, p)
	if p[1] == nil then
		abort("Wrong parameters update_faction_brain")
	end
	local board = sim_board.get_sim_board()
	local player = board.players[ p[1] ]
	if player == nil then
		abort("Can't find player %s", tostring(p[1]))
	end
	player:faction_brain_update()
end
]] --

function create_squad(actor, obj, p)
	if obj ~= nil then
		printf("pl:creating_squad from obj [%s] in section [%s]", tostring(obj:name()),
			tostring(db.storage[obj:id()].active_section))
	end
	local squad_id = p[1]
	if squad_id == nil then
		abort("Wrong squad identificator [NIL] in create_squad function")
	end
	local smart_name = p[2]
	if smart_name == nil then
		abort("Wrong smart name [NIL] in create_squad function")
	end

	local ltx = sim_board.squad_ltx

	if not ltx:section_exist(squad_id) then
		abort("Wrong squad identificator [%s]. Squad descr doesnt exist.", tostring(squad_id))
	end

	local board = sim_board.get_sim_board()
	local smart = board.smarts_by_names[smart_name]
	if smart == nil then
		abort("Wrong smart_name [%s] for [%s] faction in create_squad function", tostring(smart_name),
			tostring(player_name))
	end

	local squad = board:create_squad(smart, squad_id)


	board:enter_smart(squad, smart.id)

	for k in squad:squad_members() do
		board:setup_squad_and_group(k.object)
	end

	squad:update()
end

function create_squad_member(actor, obj, p)
	local squad_member_sect = p[1]
	local story_id          = p[2]
	local position          = nil
	local level_vertex_id   = nil
	local game_vertex_id    = nil
	if story_id == nil then
		abort("Wrong squad identificator [NIL] in 'create_squad_member' function")
	end
	local board = sim_board.get_sim_board()
	local squad = get_story_squad(story_id)
	if squad ~= nil then
		local squad_smart = board.smarts[squad.smart_id].smrt
		if p[3] ~= nil then
			local spawn_point
			if p[3] == "simulation_point" then
				spawn_point = utils.cfg_get_string(sim_board.squad_ltx, squad:section_name(), "spawn_point", obj, false,
					"")
				if spawn_point == "" or spawn_point == nil then
					spawn_point = xr_logic.parse_condlist(obj, "spawn_point", "spawn_point", squad_smart.spawn_point)
				else
					spawn_point = xr_logic.parse_condlist(obj, "spawn_point", "spawn_point", spawn_point)
				end
				spawn_point = xr_logic.pick_section_from_condlist(db.actor, obj, spawn_point)
			else
				spawn_point = p[3]
			end
			position        = patrol(spawn_point):point(0)
			level_vertex_id = patrol(spawn_point):level_vertex_id(0)
			game_vertex_id  = patrol(spawn_point):game_vertex_id(0)
		else
			local commander = alife():object(squad:commander_id())
			position        = commander.position
			level_vertex_id = commander.m_level_vertex_id
			game_vertex_id  = commander.m_game_vertex_id
		end
		local new_member_id = squad:add_squad_member(squad_member_sect, position, level_vertex_id, game_vertex_id)
		squad:assign_squad_member_to_smart(new_member_id, squad_smart)
		board:setup_squad_and_group(alife():object(new_member_id))
		squad:update()
	end
end

function remove_squad(actor, obj, p)
	local story_id = p[1]
	if story_id == nil then
		abort("Wrong squad identificator [NIL] in remove_squad function")
	end
	local squad = get_story_squad(story_id)
	if squad == nil then
		assert("Wrong squad identificator [%s]. squad doesnt exist", tostring(story_id))
		return
	end
	local board = sim_board.get_sim_board()
	board:remove_squad(squad)
end

function kill_squad(actor, obj, p)
	local story_id = p[1]
	if story_id == nil then
		abort("Wrong squad identificator [NIL] in kill_squad function")
	end
	local squad = get_story_squad(story_id)
	if squad == nil then
		return
	end
	local squad_npcs = {}
	for k in squad:squad_members() do
		squad_npcs[k.id] = true
	end

	for k, v in pairs(squad_npcs) do
		local cl_obj = db.storage[k] and db.storage[k].object
		if cl_obj == nil then
			alife():object(tonumber(k)):kill()
		else
			cl_obj:kill(cl_obj)
		end
	end
end

function heal_squad(actor, obj, p)
	local story_id = p[1]
	local health_mod = 1
	if p[2] and p[2] ~= nil then
		health_mod = math.ceil(p[2] / 100)
	end
	if story_id == nil then
		abort("Wrong squad identificator [NIL] in heal_squad function")
	end
	local squad = get_story_squad(story_id)
	if squad == nil then
		return
	end
	for k in squad:squad_members() do
		local cl_obj = db.storage[k.id] and db.storage[k.id].object
		if cl_obj ~= nil then
			cl_obj.health = health_mod
		end
	end
end

--[[
function update_squad(actor, obj, p)
	local squad_id = p[1]
	if squad_id == nil then
		abort("Wrong squad identificator [NIL] in remove_squad function")
	end
	local board = sim_board.get_sim_board()
	local squad = board.squads[squad_id]
	if squad == nil then
		assert("Wrong squad identificator [%s]. squad doesnt exist", tostring(squad_id))
		return
	end
	squad:update()
end
]] --

function clear_smart_terrain(actor, obj, p)
	local smart_name = p[1]
	if smart_name == nil then
		abort("Wrong squad identificator [NIL] in clear_smart_terrain function")
	end

	local board = sim_board.get_sim_board()
	local smart = board.smarts_by_names[smart_name]
	local smart_id = smart.id
	for k, v in pairs(board.smarts[smart_id].squads) do
		if p[2] and p[2] == "false" then
			if not get_object_story_id(v.id) then
				board:exit_smart(v, smart_id)
				board:remove_squad(v)
			end
		else
			board:exit_smart(v, smart_id)
			board:remove_squad(v)
		end
	end
end

--[[
function set_actor_faction(actor, obj, p)
	if p[1] == nil then
		abort("Wrong parameters")
	end
	sim_board.get_sim_board():set_actor_community(p[1])
end
]] --
--'-----------------------------------------------------------------------------------
--' Quest support
--'-----------------------------------------------------------------------------------
function give_task(actor, obj, p)
	if p[1] == nil then
		abort("No parameter in give_task function.")
	end
	--/ SGM in
	sgm_callbacks.on_give_task(p[1])
	--/ SGM out
end

function set_active_task(actor, npc, p)
	if (p[1]) then
		local t = db.actor:get_task(tostring(p[1]), true)
		if (t) then
			db.actor:set_active_task(t)
		end
	end
end

-- Функции для работы с отношениями

function actor_friend(actor, npc)
	printf("_bp: xr_effects: actor_friend(): npc='%s': time=%d", npc:name(), time_global())
	npc:force_set_goodwill(1000, actor)
end

function actor_neutral(actor, npc)
	npc:force_set_goodwill(0, actor)
end

function actor_enemy(actor, npc)
	npc:force_set_goodwill(-1000, actor)
end

function set_squad_neutral_to_actor(actor, npc, p)
	local story_id = p[1]
	local squad = get_story_squad(story_id)
	if squad == nil then
		printf("There is no squad with id[%s]", tostring(story_id))
		return
	end
	squad:set_squad_relation("neutral")
end

function set_squad_friend_to_actor(actor, npc, p)
	local story_id = p[1]
	local squad = get_story_squad(story_id)
	if squad == nil then
		printf("There is no squad with id[%s]", tostring(story_id))
		return
	end
	squad:set_squad_relation("friend")
end

--Сделать актера врагом к отряду, передается имя отряда
function set_squad_enemy_to_actor(actor, npc, p)
	local story_id = p[1]
	local squad = get_story_squad(story_id)
	if squad == nil then
		printf("There is no squad with id[%s]", tostring(story_id))
		return
	end
	squad:set_squad_relation("enemy")
end

--[[
function set_friends(actor, npc, p)
	local npc1
	for i, v in pairs(p) do
		npc1 = get_story_object(v)
		if npc1 and npc1:alive() then
			--printf("_bp: %d:set_friends(%d)", npc:id(), npc1:id())
			npc:set_relation(game_object.friend, npc1)
			npc1:set_relation(game_object.friend, npc)
		end
	end
end

function set_enemies(actor, npc, p)
	local npc1
	for i, v in pairs(p) do
		--printf("_bp: set_enemies(%d)", v)
		npc1 = get_story_object(v)
		if npc1 and npc1:alive() then
			npc:set_relation(game_object.enemy, npc1)
			npc1:set_relation(game_object.enemy, npc)
		end
	end
end

function set_gulag_relation_actor(actor, npc, p)
	if(p[1]) and (p[2]) then
		game_relations.set_gulag_relation_actor(p[1], p[2])
	end
end

function set_factions_community(actor, npc, p)
	if(p[1]~=nil) and (p[2]~=nil) and (p[3]~=nil) then
		game_relations.set_factions_community(p[1], p[2], p[3])
	end
end

function set_squad_community_goodwill(actor, npc, p)
	if(p[1]~=nil) and (p[2]~=nil) and (p[3]~=nil) then
		game_relations.set_squad_community_goodwill(p[1], p[2], p[3])
	end
end
]] --

--sets NPC relation to actor
--set_npc_sympathy(number)
--call only from npc`s logic
function set_npc_sympathy(actor, npc, p)
	if (p[1] ~= nil) then
		game_relations.set_npc_sympathy(npc, p[1])
	end
end

--sets SQUAD relation to actor
--set_squad_goodwill(faction:number)
function set_squad_goodwill(actor, npc, p)
	if (p[1] ~= nil) and (p[2] ~= nil) then
		game_relations.set_squad_goodwill(p[1], p[2])
	end
end

function set_squad_goodwill_to_npc(actor, npc, p)
	if (p[1] ~= nil) and (p[2] ~= nil) then
		game_relations.set_squad_goodwill_to_npc(npc, p[1], p[2])
	end
end

function inc_faction_goodwill_to_actor(actor, npc, p)
	local community = p[1]
	local delta     = p[2]
	if delta and community then
		game_relations.change_factions_community_num(community, actor:id(), tonumber(delta))
	else
		abort("Wrong parameters in function 'inc_faction_goodwill_to_actor'")
	end
end

function dec_faction_goodwill_to_actor(actor, npc, p)
	local community = p[1]
	local delta     = p[2]
	if delta and community then
		game_relations.change_factions_community_num(community, actor:id(), -tonumber(delta))
	else
		abort("Wrong parameters in function 'dec_faction_goodwill_to_actor'")
	end
end

--[[
function add_custom_static(actor, npc, p)
	if p[1] ~= nil and p[2] ~= nil then
		get_hud():AddCustomStatic(p[1], true)
		get_hud():GetCustomStatic(p[1]):wnd():SetTextST(p[2])
	else
		abort("Invalid parameters in function add_custom_static!!!")
	end
end

function remove_custom_static(actor, npc, p)
	if p[1] ~= nil then
		get_hud():RemoveCustomStatic(p[1])
	else
		abort("Invalid parameters in function remove_custom_static!!!")
	end
end
]] --

function kill_actor(actor, npc)
	db.actor:kill(db.actor)
end

-----------------------------------------------------------------------
--  Treasures support
-----------------------------------------------------------------------
function give_treasure(actor, npc, p)
	if p == nil then
		abort("Required parameter is [NIL]")
	end
	for k, v in pairs(p) do
		treasure_manager.get_treasure_manager():give_treasure(v)
	end
end

--[[
function change_tsg(actor, npc, p)
	npc:change_team(p[1], p[2], p[3])
end

function exit_game(actor, npc)
	get_console():execute("quit")
end
]] --

function start_surge(actor, npc, p)
	surge_manager.start_surge(p)
end

function stop_surge(actor, npc, p)
	surge_manager.stop_surge()
end

function set_surge_mess_and_task(actor, npc, p)
	if (p) then
		surge_manager.set_surge_message(p[1])
		if (p[2]) then
			surge_manager.set_surge_task(p[2])
		end
	end
end

--[[
function enable_level_changer(actor, npc, p)
	if(p[1]~=nil) then
		local obj = get_story_object(p[1])
		if(obj) then
			if db.storage[obj:id()] and db.storage[obj:id()].s_obj then
				db.storage[obj:id()].s_obj.enabled = true
				db.storage[obj:id()].s_obj.hint = "level_changer_invitation"
			else
				return
			end
			obj:enable_level_changer(true)
			level_tasks.add_lchanger_location()
			obj:set_level_changer_invitation("level_changer_invitation")
		end
	end
end

function disable_level_changer(actor, npc, p)
	if(p[1]~=nil) then
		local obj = get_story_object(p[1])
		if(obj) then
			if not(db.storage[obj:id()] and db.storage[obj:id()].s_obj) then
				return
			end
			obj:enable_level_changer(false)
			level_tasks.del_lchanger_mapspot(tonumber(p[1]))
			db.storage[obj:id()].s_obj.enabled = false
			if(p[2]==nil) then
				obj:set_level_changer_invitation("level_changer_disabled")
				db.storage[obj:id()].s_obj.hint = "level_changer_disabled"
			else
				obj:set_level_changer_invitation(p[2])
				db.storage[obj:id()].s_obj.hint = p[2]
			end
		end
	end
end

function change_actor_community(actor, npc, p)
	if(p[1]~=nil) then
		db.actor:set_character_community(p[1], 0, 0)
	end
end

function set_faction_community_to_actor(actor, npc, p)
-- run_string xr_effects.change_actor_community(nil,nil,{"actor_dolg"})
	if(p[1]~=nil) and (p[2]~=nil) then
		local rel = 0
		if(p[2]=="enemy") then
			rel = -3000
		elseif(p[2]=="friend") then
			rel = 1000
		end
		db.actor:set_community_goodwill(p[1], rel)
	end
end

function disable_collision(actor, npc)
	npc:wounded(true)
end
function enable_collision(actor, npc)
	npc:wounded(false)
end

function disable_actor_collision(actor, npc)
	actor:wounded(true)
end
function enable_actor_collision(actor, npc)
	actor:wounded(false)
end

function relocate_actor_inventory_to_box(actor, npc, p)
	local function transfer_object_item(item)
		if item:section() ~= "wpn_binoc" and item:section() ~= "wpn_knife" and item:section() ~= "device_torch" then
			db.actor:transfer_item(item, inv_box_1)
		end
	end
	inv_box_1 = get_story_object (p[1])
	actor:inventory_for_each(transfer_object_item)
end
]] --

function set_level_faction_community(actor, npc, p)
	if (p[1] ~= nil) and (p[2] ~= nil) and (p[3] ~= nil) then
		local faction = sim_board.get_sim_board().players[p[1]]
		local goodwill = 0
		if (p[3] == "enemy") then
			goodwill = -3000
		elseif (p[3] == "friend") then
			goodwill = 1000
		end
		for k, v in pairs(faction.squads) do
			local squad_level = alife():level_name(game_graph():vertex(alife():object(v:commander_id()).m_game_vertex_id)
				:level_id())
			if (squad_level == p[2]) then
				for kk in v:squad_members() do
					local npc = kk.object
					local tbl = game_relations.temp_goodwill_table
					if (tbl.communities == nil) then
						tbl.communities = {}
					end
					if (tbl.communities[p[1]] == nil) then
						tbl.communities[p[1]] = {}
					end
					tbl.communities[p[1]][npc.id] = goodwill
					if (db.storage[npc.id] ~= nil) then
						game_relations.set_level_faction_community(db.storage[npc.id].object)
					end
				end
			end
		end
	end
end

--[[
function make_actor_visible_to_npc(actor,npc,p)
	npc:make_object_visible_somewhen(db.actor)
end
]] --

function make_actor_visible_to_squad(actor, npc, p)
	local story_id = p and p[1]
	local squad = get_story_squad(story_id)
	if squad == nil then abort("There is no squad with id[%s]", story_id) end
	for k in squad:squad_members() do
		local obj = level.object_by_id(k.id)
		if obj ~= nil then
			obj:make_object_visible_somewhen(db.actor)
		end
	end
end

function stop_sr_cutscene(actor, npc, p)
	local obj = db.storage[npc:id()]
	if (obj.active_scheme ~= nil) then
		obj[obj.active_scheme].signals["cam_effector_stop"] = true
	end
end

--[[
function reset_dialog_end_signal(actor, npc, p)
	local st = db.storage[npc:id()]
	if(st.active_scheme==nil) then
		return
	end
	if(st[st.active_scheme].signals==nil) then
		return
	end
	st[st.active_scheme].signals["dialog_end"] = nil
end

function add_map_spot(actor, npc, p)
	if(p[1]==nil) then
		abort("Story id for add map spot function is not set")
	else
		local story_id = tonumber(p[1])
		local id = id_by_sid(story_id)
		if(id==nil) then
			local obj = alife():object(p[1])
			id = obj and obj.id
		end
		if(id~=nil) then
			if(p[2]==nil) then
				p[2] = "primary_task_location"
			end
			if(p[3]==nil) then
				p[3] = "default"
			end
                        --/ SGM in
                        add_spot_on_map(id,p[2],p[3])
                        --/ SGM out
		else
			abort("Wrong story id or name [%s] for map spot function", tostring(story_id))
		end
	end
end

function remove_map_spot(actor, npc, p)
	if(p[1]==nil) then
		abort("Story id for add map spot function is not set")
	else
		local story_id = tonumber(p[1])
		local id = id_by_sid(story_id)
		if(id==nil) then
			local obj = alife():object(p[1])
			id = obj and obj.id
		end
		if(id~=nil) then
			if(p[2]==nil) then
				p[2] = "primary_task_location"
			end
                        --/ SGM in
                        sgm_g.remove_spot_on_map(id,p[2])
                        --/ SGM out
		else
			abort("Wrong story id or name [%s] for map spot function", tostring(story_id))
		end
	end
end
]] --

-- Anomal fields support
function enable_anomaly(actor, npc, p)
	if p[1] == nil then
		abort("Story id for enable_anomaly function is not set")
	end

	local obj = get_story_object(p[1])
	if not obj then
		abort("There is no object with story_id %s for enable_anomaly function", tostring(p[1]))
	end
	obj:enable_anomaly()
end

function disable_anomaly(actor, npc, p)
	if p[1] == nil then
		abort("Story id for disable_anomaly function is not set")
	end

	local obj = get_story_object(p[1])
	if not obj then
		abort("There is no object with story_id %s for disable_anomaly function", tostring(p[1]))
	end
	obj:disable_anomaly()
end

function launch_signal_rocket(actor, obj, p)
	if p == nil then
		abort("Signal rocket name is not set!")
	end
	if db.signal_light[p[1]] then
		db.signal_light[p[1]]:launch()
	else
		abort("No such signal rocket: [%s] on level", tostring(p[1]))
	end
end

--[[
function reset_faction_goodwill(actor, obj, p)
	if db.actor and p[1] then
		local board = sim_board.get_sim_board()
		local faction = board.players[ p[1] ]
		if faction then
			db.actor:set_community_goodwill(p[1], 0)
		end
	end
end
]] --

function add_cs_text(actor, npc, p)
	if p[1] then
		local hud = get_hud()
		local cs_text = hud:GetCustomStatic("text_on_screen_center")
		if cs_text then
			hud:RemoveCustomStatic("text_on_screen_center")
		end
		hud:AddCustomStatic("text_on_screen_center", true)
		cs_text = hud:GetCustomStatic("text_on_screen_center")
		cs_text:wnd():TextControl():SetText(game.translate_string(p[1]))
	end
end

function del_cs_text(actor, npc, p)
	local hud = get_hud()
	cs_text = hud:GetCustomStatic("text_on_screen_center")
	if cs_text then
		hud:RemoveCustomStatic("text_on_screen_center")
	end
end

function spawn_item_to_npc(actor, npc, p)
	local new_item = p[1]
	if p[1] then
		alife():create(new_item,
			npc:position(),
			npc:level_vertex_id(),
			npc:game_vertex_id(),
			npc:id())
	end
end

function give_money_to_npc(actor, npc, p)
	local money = p[1]
	if p[1] then
		npc:give_money(money)
	end
end

function seize_money_to_npc(actor, npc, p)
	local money = p[1]
	if p[1] then
		npc:give_money(-money)
	end
end

-- Передача предмета от непися к неписю
-- relocate_item(item_name:story_id_from:story_id_to)
function relocate_item(actor, npc, p)
	local item = p and p[1]
	local from_obj = p and get_story_object(p[2])
	local to_obj = p and get_story_object(p[3])
	if to_obj ~= nil then
		if from_obj ~= nil and from_obj:object(item) ~= nil then
			from_obj:transfer_item(from_obj:object(item), to_obj)
		else
			alife():create(item,
				to_obj:position(),
				to_obj:level_vertex_id(),
				to_obj:game_vertex_id(),
				to_obj:id())
		end
	else
		abort("Couldn't relocate item to NULL")
	end
end

-- Сделать сквады врагами, передаются два сквада set_squads_enemies(squad_name_1:squad_name_2)
function set_squads_enemies(actor, npc, p)
	if (p[1] == nil or p[2] == nil) then
		abort("Wrong parameters in function set_squad_enemies")
		return
	end

	local squad_1 = get_story_squad(p[1])
	local squad_2 = get_story_squad(p[2])

	if squad_1 == nil then
		assert("There is no squad with id[%s]", tostring(p[1]))
		return
	end
	if squad_2 == nil then
		assert("There is no squad with id[%s]", tostring(p[2]))
		return
	end

	for k in squad_1:squad_members() do
		local npc_obj_1 = db.storage[k.id] and db.storage[k.id].object
		if npc_obj_1 ~= nil then
			for kk in squad_2:squad_members() do
				local npc_obj_2 = db.storage[kk.id] and db.storage[kk.id].object
				if npc_obj_2 ~= nil then
					npc_obj_1:set_relation(game_object.enemy, npc_obj_2)
					npc_obj_2:set_relation(game_object.enemy, npc_obj_1)
					printf("set_squads_enemies: %d:set_enemy(%d)", npc_obj_1:id(), npc_obj_2:id())
				end
			end
		end
	end
end

local particles_table = {
	[1] = { particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming") },
	[2] = { particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming") },
	[3] = { particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming") },
	[4] = { particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming") },
}

function jup_b16_play_particle_and_sound(actor, npc, p)
	particles_table[p[1]].particle:play_at_pos(patrol(npc:name() .. "_particle"):point(0))
	--particles_table[p[1]].sound    :play_at_pos(actor, patrol(npc:name().."_particle"):point(0), 0, sound_object.s3d)
end

--Функция установки состояния видимости кровососа.
-- Возможный набор параметров --> story_id:visibility_state(можно вызывать откуда угодно) или visibility_state(если вызывается из кастомдаты кровососа)
--  visibility_state -->
--						0 - невидимый
--						1 - полувидимый
--						2 - полностью видимый
function set_bloodsucker_state(actor, npc, p)
	if (p and p[1]) == nil then abort("Wrong parameters in function 'set_bloodsucker_state'!!!") end
	local state = p[1]
	--/ SGM in
	if p[2] ~= nil and p[2] ~= "by_id" then
		state = p[2]
		npc = get_story_object(p[1])
	elseif p[2] == "by_id" then
		state = p[1]
		npc = level.object_by_id(npc:id())
	end
	--/ SGM out
	if npc ~= nil then
		if state == "default" then
			npc:force_visibility_state(-1)
		else
			npc:force_visibility_state(tonumber(state))
		end
	end
end

--Функция вставки предмета в определенную точку, сделал для сцены б57
function drop_object_item_on_point(actor, npc, p)
	local drop_object = db.actor:object(p[1])
	local drop_point  = patrol(p[2]):point(0)
	db.actor:drop_item_and_teleport(drop_object, drop_point)
end

--Функция отнятия предмета у игрока
function remove_item(actor, npc, p)
	if (p and p[1]) == nil then abort("Wrong parameters in function 'remove_item'!!!") end
	local item = p[1]

	local obj = db.actor:object(item)
	--/ SGM in
	if obj ~= nil and alife():object(obj:id()) then
		alife():release(alife():object(obj:id()), true)
	else
		--/abort("Actor has no such item!")
	end
	--/ SGM out
	news_manager.relocate_item(db.actor, "out", item)
end

-- Сюжетное сохранение в важных местах
function scenario_autosave(actor, npc, p)
	local save_name = p[1]

	if save_name == nil then
		abort("You are trying to use scenario_autosave without save name")
	end
	--/ SGM in
	if (sgm_g.autosave_precond() or find_in_string(save_name, "save_uni_travel")) and IsImportantSave() then
		local save_param = user_name() .. " - " .. game.translate_string(save_name)
		sgm_flags.string_savegame_type = "autosave"
		sgm_g.data_param_save_game(save_param)
		get_console():execute("save " .. save_param)
	else
		if sgm_flags.table_mod_autosaves[save_name] == nil and IsImportantSave() then
			sgm_flags.table_mod_autosaves[save_name] = true
		end
	end
	--/ SGM out
end

function zat_b29_create_random_infop(actor, npc, p)
	if p[2] == nil then
		abort("Not enough parameters for zat_b29_create_random_infop!")
	end

	local amount_needed = p[1]
	local current_infop = 0
	local total_infop = 0

	if (not amount_needed or amount_needed == nil) then
		amount_needed = 1
	end

	for k, v in pairs(p) do
		if k > 1 then
			total_infop = total_infop + 1
			disable_info(v)
		end
	end

	if amount_needed > total_infop then
		amount_needed = total_infop
	end

	for i = 1, amount_needed do
		current_infop = math.random(1, total_infop)
		for k, v in pairs(p) do
			if k > 1 then
				if (k == current_infop + 1 and (sgm_g.dont_has_alife_info(v))) then
					db.actor:give_info_portion(v)
					break
				end
			end
		end
	end
end

function give_item_b29(actor, npc, p)
	--	local story_object = p and get_story_object(p[1])
	local az_name
	local az_table = {
		"zat_b55_anomal_zone",
		"zat_b54_anomal_zone",
		"zat_b53_anomal_zone",
		"zat_b39_anomal_zone",
		"zaton_b56_anomal_zone",
	}

	for i = 16, 23 do
		if has_alife_info(dialogs_zaton.zat_b29_infop_bring_table[i]) then
			for k, v in pairs(az_table) do
				if has_alife_info(v) then
					az_name = v
					disable_info(az_name)
					break
				end
			end
			pick_artefact_from_anomaly(nil, nil, { p[1], az_name, dialogs_zaton.zat_b29_af_table[i] })
			break
		end
	end
end

function relocate_item_b29(actor, npc, p)
	local item
	for i = 16, 23 do
		if has_alife_info(dialogs_zaton.zat_b29_infop_bring_table[i]) then
			item = dialogs_zaton.zat_b29_af_table[i]
			break
		end
	end
	local from_obj = p and get_story_object(p[1])
	local to_obj = p and get_story_object(p[2])
	if to_obj ~= nil then
		if from_obj ~= nil and from_obj:object(item) ~= nil then
			from_obj:transfer_item(from_obj:object(item), to_obj)
		else
			alife():create(item,
				to_obj:position(),
				to_obj:level_vertex_id(),
				to_obj:game_vertex_id(),
				to_obj:id())
		end
	else
		abort("Couldn't relocate item to NULL")
	end
end

-- Функция ресетит секвенсную звукокую тему у непися. by peacemaker, hein, redstain
function reset_sound_npc(actor, npc, p)
	local obj_id = npc:id()
	if obj_id and xr_sound.sound_table and xr_sound.sound_table[obj_id] then
		xr_sound.sound_table[obj_id]:reset(obj_id)
	end
end

function jup_b202_inventory_box_relocate(actor, npc)
	local inv_box_out = get_story_object("jup_b202_actor_treasure")
	local inv_box_in = get_story_object("jup_b202_snag_treasure")
	local items_to_relocate = {}
	local function relocate(inv_box_out, item)
		table.insert(items_to_relocate, item)
	end
	inv_box_out:iterate_inventory_box(relocate, inv_box_out)
	for k, v in pairs(items_to_relocate) do
		inv_box_out:transfer_item(v, inv_box_in)
	end
end

function clear_box(actor, npc, p)
	if (p and p[1]) == nil then abort("Wrong parameters in function 'clear_box'!!!") end

	local inv_box = get_story_object(p[1])

	if inv_box == nil then
		abort("There is no object with story_id [%s]", tostring(p[1]))
	end

	local items_table = {}

	local function add_items(inv_box, item)
		table.insert(items_table, item)
	end
	inv_box:iterate_inventory_box(add_items, inv_box)
	for k, v in pairs(items_table) do
		--/ SGM in
		if v ~= nil and alife():object(v:id()) then
			alife():release(alife():object(v:id()), true)
		end
		--/ SGM out
	end
end

function activate_weapon(actor, npc, p)
	local object = actor:object(p[1])
	if object == nil then
		assert("Actor has no such weapon! [%s]", p[1])
	end
	if object ~= nil then
		actor:make_item_active(object)
	end
end

function set_game_time(actor, npc, p)
	local real_hours = level.get_time_hours()
	local real_minutes = level.get_time_minutes()
	local hours = tonumber(p[1])
	local minutes = tonumber(p[2])
	if p[2] == nil then
		minutes = 0
	end
	local hours_to_change = hours - real_hours
	if hours_to_change <= 0 then
		hours_to_change = hours_to_change + 24
	end
	local minutes_to_change = minutes - real_minutes
	if minutes_to_change <= 0 then
		minutes_to_change = minutes_to_change + 60
		hours_to_change = hours_to_change - 1
	elseif hours == real_hours then
		hours_to_change = hours_to_change - 24
	end
	--/ SGM in
	sgm_callbacks.on_forward_game_time(hours_to_change, minutes_to_change)
	--/ SGM out
	level.change_game_time(0, hours_to_change, minutes_to_change)
	level_weathers.get_weather_manager():forced_weather_change()
	surge_manager.get_surge_manager().time_forwarded = true
end

function forward_game_time(actor, npc, p)
	if not p then
		abort("Insufficient or invalid parameters in function 'forward_game_time'!")
	end

	local hours = tonumber(p[1])
	local minutes = tonumber(p[2])
	if p[2] == nil then
		minutes = 0
	end
	--/ SGM in
	sgm_callbacks.on_forward_game_time(hours, minutes)
	--/ SGM out
	level.change_game_time(0, hours, minutes)
	level_weathers.get_weather_manager():forced_weather_change()
	surge_manager.get_surge_manager().time_forwarded = true
	printf("forward_game_time: time forwarded on [%d][%d]", hours, minutes)
end

function stop_tutorial()
	printf("stop tutorial called")
	game.stop_tutorial()
end

function jup_b10_spawn_drunk_dead_items(actor, npc, p)
	local items_all = {
		["wpn_ak74"] = 1,
		["ammo_5.45x39_fmj"] = 5,
		["ammo_5.45x39_ap"] = 3,
		["wpn_fort"] = 1,
		["ammo_9x18_fmj"] = 3,
		["ammo_12x70_buck"] = 5,
		["ammo_11.43x23_hydro"] = 2,
		["grenade_rgd5"] = 3,
		["grenade_f1"] = 2,
		["medkit_army"] = 2,
		["medkit"] = 4,
		["bandage"] = 4,
		["antirad"] = 2,
		["vodka"] = 3,
		["energy_drink"] = 2,
		["conserva"] = 1,
		["jup_b10_ufo_memory_2"] = 1,
	}

	local items = {
		[2] = {
			["wpn_sig550_luckygun"] = 1,
		},
		[1] = {
			["ammo_5.45x39_fmj"] = 5,
			["ammo_5.45x39_ap"] = 3,
			["wpn_fort"] = 1,
			["ammo_9x18_fmj"] = 3,
			["ammo_12x70_buck"] = 5,
			["ammo_11.43x23_hydro"] = 2,
			["grenade_rgd5"] = 3,
			["grenade_f1"] = 2,
		},
		[0] = {
			["medkit_army"] = 2,
			["medkit"] = 4,
			["bandage"] = 4,
			["antirad"] = 2,
			["vodka"] = 3,
			["energy_drink"] = 2,
			["conserva"] = 1,
		},
	}

	if p and p[1] ~= nil then
		local cnt = xr_logic.pstor_retrieve(actor, "jup_b10_ufo_counter", 0)
		if cnt > 2 then return end
		for k, v in pairs(items[cnt]) do
			local target_obj_id = get_story_object_id(p[1])
			if target_obj_id ~= nil then
				box = alife():object(target_obj_id)
				if box == nil then
					abort("There is no such object %s", p[1])
				end
				for i = 1, v do
					alife():create(k, vector(), 0, 0, target_obj_id)
				end
			else
				abort("object is nil %s", tostring(p[1]))
			end
		end
	else
		for k, v in pairs(items_all) do
			for i = 1, v do
				alife():create(k,
					npc:position(),
					npc:level_vertex_id(),
					npc:game_vertex_id(),
					npc:id())
			end
		end
	end
end

function pick_artefact_from_anomaly(actor, npc, p)
	local npc
	local az_name = p and p[2]
	local af_name = p and p[3]
	local af_id
	local af_obj
	local anomal_zone = db.anomaly_by_name[az_name]

	if p and p[1] then
		--		if p[1] == "actor" then
		--			npc = db.actor
		--		else
		--			npc = get_story_object(p[1])
		--		end

		local npc_id = get_story_object_id(p[1])
		if npc_id == nil then
			abort("Couldn't relocate item to NULL in function 'pick_artefact_from_anomaly!'")
		end
		npc = alife():object(npc_id)
		if npc and (not IsStalker(npc) or not npc:alive()) then
			abort("Couldn't relocate item to NULL (dead or not stalker) in function 'pick_artefact_from_anomaly!'")
		end
	end

	if anomal_zone == nil then
		abort("No such anomal zone in function 'pick_artefact_from_anomaly!'")
	end

	if anomal_zone.spawned_count < 1 then
		printf("No artefacts in anomal zone [%s]", az_name)
		return
	end

	for k, v in pairs(anomal_zone.artefact_ways_by_id) do
		if alife():object(tonumber(k)) and af_name == alife():object(tonumber(k)):section_name() then
			af_id = tonumber(k)
			af_obj = alife():object(tonumber(k))
			break
		end
		if af_name == nil then
			af_id = tonumber(k)
			af_obj = alife():object(tonumber(k))
			af_name = af_obj:section_name()
			break
		end
	end

	if af_id == nil then
		printf("No such artefact [%s] found in anomal zone [%s]", tostring(af_name), az_name)
		return
	end

	anomal_zone:on_artefact_take(af_obj)

	alife():release(af_obj, true)

	give_item(db.actor, npc, { af_name, p[1] })
	--	alife():create(af_name,
	--		npc.position,
	--		npc.level_vertex_id,
	--		npc.game_vertex_id,
	--		npc.id)
end

function anomaly_turn_off(actor, npc, p)
	local anomal_zone = db.anomaly_by_name[p[1]]
	if anomal_zone == nil then
		abort("No such anomal zone in function 'anomaly_turn_off!'")
	end
	anomal_zone:turn_off()
end

function anomaly_turn_on(actor, npc, p)
	local anomal_zone = db.anomaly_by_name[p[1]]
	if anomal_zone == nil then
		abort("No such anomal zone in function 'anomaly_turn_on!'")
	end
	if p[2] then
		anomal_zone:turn_on(true)
	else
		anomal_zone:turn_on(false)
	end
end

function zat_b202_spawn_random_loot(actor, npc, p)
	local si_table = {}
	si_table[1] = {
		[1] = { item = { "bandage", "bandage", "bandage", "bandage", "bandage", "medkit", "medkit", "medkit", "conserva", "conserva" } },
		[2] = { item = { "medkit", "medkit", "medkit", "medkit", "medkit", "vodka", "vodka", "vodka", "kolbasa", "kolbasa" } },
		[3] = { item = { "antirad", "antirad", "antirad", "medkit", "medkit", "bandage", "kolbasa", "kolbasa", "conserva" } },
	}
	si_table[2] = {
		[1] = { item = { "grenade_f1", "grenade_f1", "grenade_f1" } },
		[2] = { item = { "grenade_rgd5", "grenade_rgd5", "grenade_rgd5", "grenade_rgd5", "grenade_rgd5" } }
	}
	si_table[3] = {
		[1] = { item = { "detector_elite" } },
		[2] = { item = { "detector_advanced" } }
	}
	si_table[4] = {
		[1] = { item = { "helm_hardhat" } },
		[2] = { item = { "helm_respirator" } }
	}
	si_table[5] = {
		[1] = { item = { "wpn_val", "ammo_9x39_ap", "ammo_9x39_ap", "ammo_9x39_ap" } },
		[2] = { item = { "wpn_spas12", "ammo_12x70_buck", "ammo_12x70_buck", "ammo_12x70_buck", "ammo_12x70_buck" } },
		[3] = { item = { "wpn_desert_eagle", "ammo_11.43x23_fmj", "ammo_11.43x23_fmj", "ammo_11.43x23_hydro", "ammo_11.43x23_hydro" } },
		[4] = { item = { "wpn_abakan", "ammo_5.45x39_ap", "ammo_5.45x39_ap" } },
		[5] = { item = { "wpn_sig550", "ammo_5.56x45_ap", "ammo_5.56x45_ap" } },
		[6] = { item = { "wpn_ak74", "ammo_5.45x39_fmj", "ammo_5.45x39_fmj" } },
		[7] = { item = { "wpn_l85", "ammo_5.56x45_ss190", "ammo_5.56x45_ss190" } }
	}
	si_table[6] = {
		[1] = { item = { "specops_outfit" } },
		[2] = { item = { "stalker_outfit" } }
	}
	weight_table = {}
	weight_table[1] = 2
	weight_table[2] = 2
	weight_table[3] = 2
	weight_table[4] = 2
	weight_table[5] = 4
	weight_table[6] = 4
	local spawned_item = {}
	local max_weight = 12
	repeat
		local n = 0
		repeat
			n = math.random(1, #weight_table)
			local prap = true
			for k, v in pairs(spawned_item) do
				if v == n then
					prap = false
					break
				end
			end
		until (prap) and ((max_weight - weight_table[n]) >= 0)
		max_weight = max_weight - weight_table[n]
		table.insert(spawned_item, n)
		local item = math.random(1, #si_table[n])
		for k, v in pairs(si_table[n][item].item) do
			spawn_object_in(actor, npc, { tostring(v), "jup_b202_snag_treasure" })
		end
	until max_weight <= 0
end

function zat_a1_tutorial_end_give(actor, npc)
	--	level.add_pp_effector("black.ppe", 1313, true) ---do not stop on r1 !
	db.actor:give_info_portion("zat_a1_tutorial_end")
end

function oasis_heal()
	local d_health = 0.005
	local d_power = 0.01
	local d_bleeding = 0.05
	local d_radiation = -0.05
	if (db.actor.health < 1) then
		db.actor.health = d_health
	end
	if (db.actor.power < 1) then
		db.actor.power = d_power
	end
	if (db.actor.radiation > 0) then
		db.actor.radiation = d_radiation
	end
	if (db.actor.bleeding > 0) then
		db.actor.bleeding = d_bleeding
	end
	db.actor.satiety = 0.01
end

--Функция принимает только одно значение, определяющее для какой групировки запускается. доступные значения [duty, freedom]
function jup_b221_play_main(actor, npc, p)
	local info_table = {}
	local main_theme
	local reply_theme
	local info_need_reply
	local reachable_theme = {}
	local theme_to_play = 0

	if (p and p[1]) == nil then
		abort("No such parameters in function 'jup_b221_play_main'")
	end
	--Составляем таблицу инфопоршинов определяющих доступность той или иной темы, определяем префиксы темы, ответа и реакции, соответственно для долга или для свободы.
	if tostring(p[1]) == "duty" then
		info_table = {
			[1] = "jup_b25_freedom_flint_gone",
			[2] = "jup_b25_flint_blame_done_to_duty",
			[3] = "jup_b4_monolith_squad_in_duty",
			[4] = "jup_a6_duty_leader_bunker_guards_work",
			[5] = "jup_a6_duty_leader_employ_work",
			[6] = "jup_b207_duty_wins"
		}
		main_theme = "jup_b221_duty_main_"
		reply_theme = "jup_b221_duty_reply_"
		info_need_reply = "jup_b221_duty_reply"
	elseif tostring(p[1]) == "freedom" then
		info_table = {
			[1] = "jup_b207_freedom_know_about_depot",
			[2] = "jup_b46_duty_founder_pda_to_freedom",
			[3] = "jup_b4_monolith_squad_in_freedom",
			[4] = "jup_a6_freedom_leader_bunker_guards_work",
			[5] = "jup_a6_freedom_leader_employ_work",
			[6] = "jup_b207_freedom_wins"
		}
		main_theme = "jup_b221_freedom_main_"
		reply_theme = "jup_b221_freedom_reply_"
		info_need_reply = "jup_b221_freedom_reply"
	else
		abort("Wrong parameters in function 'jup_b221_play_main'")
	end
	--Составляем таблицу достыпных тем(тлько номера тем).
	for k, v in pairs(info_table) do
		if (has_alife_info(v)) and (sgm_g.dont_has_alife_info(main_theme .. tostring(k) .. "_played")) then
			table.insert(reachable_theme, k)
			--			printf("jup_b221_play_main: table reachable_theme ------------------------------> [%s]", tostring(k))
		end
	end
	--Если таблица доступных тем пуста играем ответ. Если же она не пуста играем основную тему. Если играем основную тему заносим значение счетчика для повторного выполнения функции. Тему выбираем по рандому.
	if #reachable_theme ~= 0 then
		disable_info(info_need_reply)
		theme_to_play = reachable_theme[math.random(1, #reachable_theme)]
		--		printf("jup_b221_play_main: variable theme_to_play ------------------------------> [%s]", tostring(theme_to_play))
		xr_logic.pstor_store(actor, "jup_b221_played_main_theme", tostring(theme_to_play))
		db.actor:give_info_portion(main_theme .. tostring(theme_to_play) .. "_played")
		if theme_to_play ~= 0 then
			play_sound(actor, npc, { main_theme .. tostring(theme_to_play) })
		else
			abort("No such theme_to_play in function 'jup_b221_play_main'")
		end
	else
		db.actor:give_info_portion(info_need_reply)
		theme_to_play = tonumber(xr_logic.pstor_retrieve(actor, "jup_b221_played_main_theme", 0))
		if theme_to_play ~= 0 then
			play_sound(actor, npc, { reply_theme .. tostring(theme_to_play) })
		else
			abort("No such theme_to_play in function 'jup_b221_play_main'")
		end
		xr_logic.pstor_store(actor, "jup_b221_played_main_theme", "0")
	end
end

function pas_b400_play_particle(actor, npc, p)
	db.actor:start_particles("zones\\zone_acidic_idle", "bip01_head")
end

function pas_b400_stop_particle(actor, npc, p)
	db.actor:stop_particles("zones\\zone_acidic_idle", "bip01_head")
end

function damage_actor_items_on_start(actor, npc)
	local actor = db.actor

	local obj = actor:object("helm_respirator")
	if obj ~= nil then
		obj:set_condition(0.8)
	end

	obj = actor:object("stalker_outfit")
	if obj ~= nil then
		obj:set_condition(0.76)
	end
	--/ SGM in
	obj = actor:object("wpn_fort_actor")
	--/ SGM out
	if obj ~= nil then
		obj:set_condition(0.9)
	end

	obj = actor:object("wpn_ak74u")
	if obj ~= nil then
		obj:set_condition(0.7)
	end
end

function damage_pri_a17_gauss()
	local obj = get_story_object("pri_a17_gauss_rifle")
	--local obj = npc:object("pri_a17_gauss_rifle")
	if obj ~= nil then
		obj:set_condition(0.0)
	end
end

function pri_a17_hard_animation_reset(actor, npc, p)
	--db.storage[npc:id()].state_mgr:set_state("pri_a17_fall_down", nil, nil, nil, {fast_set = true})
	db.storage[npc:id()].state_mgr:set_state("pri_a17_fall_down")

	local state_mgr = db.storage[npc:id()].state_mgr
	if state_mgr ~= nil then
		state_mgr.animation:set_state(nil, true)
		state_mgr.animation:set_state("pri_a17_fall_down")
		state_mgr.animation:set_control()
	end
end

function jup_b217_hard_animation_reset(actor, npc, p)
	db.storage[npc:id()].state_mgr:set_state("jup_b217_nitro_straight")

	local state_mgr = db.storage[npc:id()].state_mgr
	if state_mgr ~= nil then
		state_mgr.animation:set_state(nil, true)
		state_mgr.animation:set_state("jup_b217_nitro_straight")
		state_mgr.animation:set_control()
	end
end

function sleep(actor, npc)
	local sleep_zones = {
		"zat_a2_sr_sleep",
		"jup_a6_sr_sleep",
		"pri_a16_sr_sleep",
		"actor_surge_hide_2",
		--/ SGM in
		"val_sleep_place_1", "val_sleep_place_2", "val_sleep_place_3", "val_sleep_place_4", "val_sleep_place_5",
		"val_sleep_place_6", "val_sleep_place_7", "val_sleep_place_8", "val_sleep_place_9", "val_sleep_place_10",
		"val_sleep_place_11",
		"mil_sleep_place_1", "mil_sleep_place_2", "mil_sleep_place_3", "mil_sleep_place_4", "mil_sleep_place_5",
		"mil_sleep_place_6", "mil_sleep_place_7", "mil_sleep_place_8", "mil_sleep_place_9",
		"esc_sleep_place_1", "esc_sleep_place_2", "esc_sleep_place_3", "esc_sleep_place_4", "esc_sleep_place_5",
		"esc_sleep_place_6", "esc_sleep_place_7",
		"mar_sleep_place_1", "mar_sleep_place_2", "mar_sleep_place_3", "mar_sleep_place_4", "mar_sleep_place_5",
		"mar_sleep_place_6",
		--/ SGM out
	}

	for k, v in pairs(sleep_zones) do
		if utils.npc_in_zone(db.actor, db.zone_by_name[v]) then
			ui_sleep_dialog.sleep()
			give_info("sleep_active")
		end
	end
end

--[[
function set_tip_to_story(actor, npc, p)
	if p == nil or p[2] == nil then
		abort("Not enough parameters in 'set_tip_to_story' function!")
	end

	local obj = get_story_object(p[1])

	if not obj then
		return
	end

	local tip = p[2]

	obj:set_tip_text(tip)
end

function clear_tip_from_story(actor, npc, p)
	if p == nil or p[1] == nil then
		abort("Not enough parameters in 'clear_tip_from_story' function!")
	end

	local obj = get_story_object(p[1])

	if not obj then
		return
	end

	obj:set_tip_text("")
end
]] --

function mech_discount(actor, npc, p)
	if (p[1]) then
		inventory_upgrades.mech_discount(tonumber(p[1]))
	end
end

function polter_actor_ignore(actor, npc, p)
	if p[1] and p[1] == "true" then
		npc:poltergeist_set_actor_ignore(true)
	elseif p[1] and p[1] == "false" then
		npc:poltergeist_set_actor_ignore(false)
	end
end

function burer_force_gravi_attack(actor, npc)
	npc:burer_set_force_gravi_attack(true)
end

function burer_force_anti_aim(actor, npc)
	npc:set_force_anti_aim(true)
end

function show_freeplay_dialog(actor, npc, p)
	if p[1] and p[2] and p[2] == "true" then
		ui_freeplay_dialog.show("message_box_yes_no", p[1])
	elseif p[1] then
		ui_freeplay_dialog.show("message_box_ok", p[1])
	end
end

--/ SGM in
local detectors = { "detector_simple", "detector_advanced", "detector_elite", "detector_scientific", "detector_omega" }
--/ SGM out
-- Только для state_mgr
function get_best_detector(npc)
	for k, v in pairs(detectors) do
		local obj = npc:object(v)
		if obj ~= nil then
			obj:enable_attachable_item(true)
			return
		end
	end
end

function hide_best_detector(npc)
	for k, v in pairs(detectors) do
		local obj = npc:object(v)
		if obj ~= nil then
			obj:enable_attachable_item(false)
			return
		end
	end
end

-- Инфопоршны для синхронизации анимации нпс с прочими действиями, и для других целей
function pri_a18_radio_start(actor, npc)
	db.actor:give_info_portion("pri_a18_radio_start")
end

function pri_a17_ice_climb_end(actor, npc)
	db.actor:give_info_portion("pri_a17_ice_climb_end")
end

function jup_b219_opening(actor, npc)
	db.actor:give_info_portion("jup_b219_opening")
end

function jup_b219_entering_underpass(actor, npc)
	db.actor:give_info_portion("jup_b219_entering_underpass")
end

function pri_a17_pray_start(actor, npc)
	db.actor:give_info_portion("pri_a17_pray_start")
end

function zat_b38_open_info(actor, npc)
	db.actor:give_info_portion("zat_b38_open_info")
end

function zat_b38_switch_info(actor, npc)
	db.actor:give_info_portion("zat_b38_switch_info")
end

function zat_b38_cop_dead(actor, npc)
	db.actor:give_info_portion("zat_b38_cop_dead")
end

function jup_b15_zulus_drink_anim_info(actor, npc)
	db.actor:give_info_portion("jup_b15_zulus_drink_anim_info")
end

function pri_a17_preacher_death(actor, npc)
	db.actor:give_info_portion("pri_a17_preacher_death")
end

function zat_b3_tech_surprise_anim_end(actor, npc)
	db.actor:give_info_portion("zat_b3_tech_surprise_anim_end")
end

function zat_b3_tech_waked_up(actor, npc)
	db.actor:give_info_portion("zat_b3_tech_waked_up")
end

function zat_b3_tech_drinked_out(actor, npc)
	db.actor:give_info_portion("zat_b3_tech_drinked_out")
end

function pri_a28_kirillov_hq_online(actor, npc)
	db.actor:give_info_portion("pri_a28_kirillov_hq_online")
end

function pri_a20_radio_start(actor, npc)
	db.actor:give_info_portion("pri_a20_radio_start")
end

function pri_a22_kovalski_speak(actor, npc)
	db.actor:give_info_portion("pri_a22_kovalski_speak")
end

function zat_b38_underground_door_open(actor, npc)
	db.actor:give_info_portion("zat_b38_underground_door_open")
end

function zat_b38_jump_tonnel_info(actor, npc)
	db.actor:give_info_portion("zat_b38_jump_tonnel_info")
end

function jup_a9_cam1_actor_anim_end(actor, npc)
	db.actor:give_info_portion("jup_a9_cam1_actor_anim_end")
end

function pri_a28_talk_ssu_video_end(actor, npc)
	db.actor:give_info_portion("pri_a28_talk_ssu_video_end")
end

function set_torch_state(actor, npc, p)
	if p == nil or p[2] == nil then
		abort("Not enough parameters in 'set_torch_state' function!")
	end

	local obj = get_story_object(p[1])

	if not obj then
		return
	end
	local torch = obj:object("device_torch")
	if torch then
		if p[2] == "on" then
			torch:enable_attachable_item(true)
		elseif p[2] == "off" then
			torch:enable_attachable_item(false)
		end
	end
end

local actor_nightvision = false
local actor_torch       = false

function disable_actor_nightvision(actor, npc)
	local nightvision = db.actor:object("device_torch")
	if nightvision:night_vision_enabled() then
		nightvision:enable_night_vision(false)
		actor_nightvision = true
	end
end

function enable_actor_nightvision(actor, npc)
	local nightvision = db.actor:object("device_torch")
	if not nightvision:night_vision_enabled() and actor_nightvision then
		nightvision:enable_night_vision(true)
		actor_nightvision = false
	end
end

function disable_actor_torch(actor, npc)
	local torch = db.actor:object("device_torch")
	if torch:torch_enabled() then
		torch:enable_torch(false)
		actor_torch = true
	end
end

function enable_actor_torch(actor, npc)
	local torch = db.actor:object("device_torch")
	if not torch:torch_enabled() and actor_torch then
		torch:enable_torch(true)
		actor_torch = false
	end
end

function create_cutscene_actor_with_weapon(actor, npc, p)
	--' p[1] - секция кого спаунить
	--' p[2] - имя патрульного пути где спаунить.
	--' p[3] - точка патрульного пути
	--' p[4] - поворот по оси Y
	--' p[5] - принудительный слот - будет работать даже при disable_ui
	local spawn_sect = p[1]
	if spawn_sect == nil then
		abort("Wrong spawn section for 'spawn_object' function %s. For object %s", tostring(spawn_sect), obj:name())
	end

	local path_name = p[2]
	if path_name == nil then
		abort("Wrong path_name for 'spawn_object' function %s. For object %s", tostring(path_name), obj:name())
	end

	if not level.patrol_path_exists(path_name) then
		abort("Path %s doesnt exist. Function 'spawn_object' for object %s ", tostring(path_name), obj:name())
	end
	local ptr = patrol(path_name)
	local index = p[3] or 0
	local yaw = p[4] or 0

	local npc = alife():create(spawn_sect, ptr:point(index), ptr:level_vertex_id(0), ptr:game_vertex_id(0))
	if IsStalker(nil, npc:clsid()) then
		npc:o_torso().yaw = yaw * math.pi / 180
	else
		npc.angle.y = yaw * math.pi / 180
	end

	local slot_override = p[5] or 0

	local slot
	local active_item

	if slot_override == 0 then
		slot = db.actor:active_slot()
		if (slot ~= 2 and slot ~= 3) then
			return
		end
		active_item = db.actor:active_item()
	else
		if db.actor:item_in_slot(slot_override) ~= nil then
			active_item = db.actor:item_in_slot(slot_override)
		else
			if db.actor:item_in_slot(3) ~= nil then
				active_item = db.actor:item_in_slot(3)
			elseif db.actor:item_in_slot(2) ~= nil then
				active_item = db.actor:item_in_slot(2)
			else
				return
			end
		end
	end

	local actor_weapon = alife():object(active_item:id())
	local section_name = actor_weapon:section_name()
	if section_name == "pri_a17_gauss_rifle" then
		section_name = "wpn_gauss"
	end

	if (active_item) then
		local new_weapon = alife():create(section_name,
			ptr:point(index),
			ptr:level_vertex_id(0),
			ptr:game_vertex_id(0),
			npc.id)
		if section_name ~= "wpn_gauss" then
			new_weapon:clone_addons(actor_weapon)
		end
	end
end

-- Заставить играть уникальные анимации сна(у кровососа)
function set_force_sleep_animation(actor, npc, p)
	local num = p[1]
	npc:force_stand_sleep_animation(tonumber(num))
end

-- Убрать уникальные анимации сна(у кровососа)
function release_force_sleep_animation(actor, npc)
	npc:release_stand_sleep_animation()
end

function zat_b33_pic_snag_container(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "zat_b33_tutor" }) then
		give_actor(actor, npc, { "zat_b33_safe_container" })
		db.actor:give_info_portion("zat_b33_find_package")
		if sgm_g.dont_has_alife_info("zat_b33_safe_container") then
			local zone = db.zone_by_name["zat_b33_tutor"]
			play_sound(actor, zone, { "pda_news" })
		end
	end
end

--Отключение воздействия вражеского нпс на индикатор видимости врага на хаде игрока.
--Исп. только из логики нпс.
function set_visual_memory_enabled(actor, npc, p)
	if (p and p[1]) and (tonumber(p[1]) >= 0) and (tonumber(p[1]) <= 1) then
		local boolval = false
		if (tonumber(p[1]) == 1) then
			boolval = true
		end
		npc:set_visual_memory_enabled(boolval)
	end
end

function disable_memory_object(actor, npc)
	local best_enemy = npc:best_enemy()
	if best_enemy then
		npc:enable_memory_object(best_enemy, false)
	end
end

function zat_b202_spawn_b33_loot(actor, npc, p)
	local info_table = {
		"zat_b33_first_item_gived",
		"zat_b33_second_item_gived",
		"zat_b33_third_item_gived",
		"zat_b33_fourth_item_gived",
		"zat_b33_fifth_item_gived"
	}
	local item_table = {}
	item_table[1] = {
		"wpn_fort_snag"
	}
	item_table[2] = {
		"medkit_scientic",
		"medkit_scientic",
		"medkit_scientic",
		"antirad",
		"antirad",
		"antirad",
		"bandage",
		"bandage",
		"bandage",
		"bandage",
		"bandage"
	}
	item_table[3] = {
		"wpn_ak74u_snag"
	}
	item_table[4] = {
		--/ SGM in
		"af_vyvert"
		--/ SGM out
	}
	item_table[5] = {
		"helm_hardhat_snag"
	}
	for k, v in pairs(info_table) do
		local obj_id
		if (k == 1) or (k == 3) then
			obj_id = "jup_b202_stalker_snag"
		else
			obj_id = "jup_b202_snag_treasure"
		end
		if sgm_g.dont_has_alife_info(tostring(v)) then
			for l, m in pairs(item_table[k]) do
				--				printf("zat_b202_spawn_b33_loot: number [%s] item [%s] to [%s]", tostring(k), tostring(m), tostring(obj_id))
				spawn_object_in(actor, npc, { tostring(m), tostring(obj_id) })
			end
		end
	end
end

function set_monster_animation(actor, npc, p)
	if not (p and p[1]) then
		abort("Wrong parameters in function 'set_monster_animation'!!!")
	end
	npc:set_override_animation(p[1])
end

function clear_monster_animation(actor, npc)
	npc:clear_override_animation()
end

local actor_position_for_restore
local actor_direction_for_restore

function save_actor_position()
	actor_position_for_restore = get_story_object("actor"):position()
	--actor_direction_for_restore = get_story_object("actor"):direction()
end

function restore_actor_position()
	--db.actor:set_actor_direction(actor_direction_for_restore)
	db.actor:set_actor_position(actor_position_for_restore)
end

function upgrade_hint(actor, npc, p)
	if (p) then
		inventory_upgrades.cur_hint = p
	end
end

function force_obj(actor, npc, p)
	local obj = get_story_object(p[1])
	if not obj then
		abort("'force_obj' Target object does not exist")
		return
	end
	if p[2] == nil then p[2] = 20 end
	if p[3] == nil then p[3] = 100 end
	obj:set_const_force(vector():set(0, 1, 0), p[2], p[3])
end

function pri_a28_check_zones()
	local story_obj_id
	local dist
	local index = 0

	local zones_tbl = {
		[1] = "pri_a28_sr_mono_add_1",
		[2] = "pri_a28_sr_mono_add_2",
		[3] = "pri_a28_sr_mono_add_3",
	}

	local info_tbl = {
		[1] = "pri_a28_wave_1_spawned",
		[2] = "pri_a28_wave_2_spawned",
		[3] = "pri_a28_wave_3_spawned",
	}

	local squad_tbl = {
		[1] = "pri_a28_heli_mono_add_1",
		[2] = "pri_a28_heli_mono_add_2",
		[3] = "pri_a28_heli_mono_add_3",
	}

	for k, v in pairs(zones_tbl) do
		story_obj_id = get_story_object_id(v)
		if story_obj_id then
			local se_obj = alife():object(story_obj_id)
			local curr_dist = se_obj.position:distance_to(db.actor:position())
			if index == 0 then
				dist = curr_dist
				index = k
			elseif dist < curr_dist then
				dist = curr_dist
				index = k
			end
		end
	end

	if index == 0 then
		abort("Found no distance or zones in func 'pri_a28_check_zones'")
	end

	if has_alife_info(info_tbl[index]) then
		for k, v in pairs(info_tbl) do
			if sgm_g.dont_has_alife_info(info_tbl[k]) then
				db.actor:give_info_portion(info_tbl[k])
			end
		end
	else
		db.actor:give_info_portion(info_tbl[index])
	end

	create_squad(db.actor, nil, { squad_tbl[index], "pri_a28_heli" })
end

function eat_vodka_script()
	if db.actor:object("vodka_script") ~= nil then
		db.actor:eat(db.actor:object("vodka_script"))
	end
end

local mat_table = {
	"jup_b200_material_1",
	"jup_b200_material_2",
	"jup_b200_material_3",
	"jup_b200_material_4",
	"jup_b200_material_5",
	"jup_b200_material_6",
	"jup_b200_material_7",
	"jup_b200_material_8",
	"jup_b200_material_9",
}

function jup_b200_count_found(actor)
	local cnt = 0

	for k, v in pairs(mat_table) do
		local material_obj = get_story_object(v)
		if material_obj then
			local parent = material_obj:parent()
			if parent then
				local parent_id = parent:id()
				if parent_id ~= 65535 and parent_id == actor:id() then
					cnt = cnt + 1
				end
			end
		end
	end

	cnt = cnt + xr_logic.pstor_retrieve(actor, "jup_b200_tech_materials_brought_counter", 0)
	xr_logic.pstor_store(actor, "jup_b200_tech_materials_found_counter", cnt)
end

---==================================================================================================---
--------------------------------------------------------------------------------------------------------
---------------------------------------(Sigerous MOD)---------------------------------------------------
--------------------------------------------------------------------------------------------------------
---==================================================================================================---
------------------------------------------------------------------------------
--                      Функции для респауна баз                            --
------------------------------------------------------------------------------
function recoil_zat_bandit_base(actor, npc)
	disable_several_info("zat_bandit_base_bodyguard_", "_death", 1, 4)
	disable_info("zat_bandit_base_west_chief_death", "zat_bandit_base_south_chief_death", "zat_bandit_base_actor_hit",
		"zat_bandit_base_hit")
end

function recoil_jup_rasvet_base(actor, npc)
	disable_several_info("jup_rasvet_base_guard_", "_death", 1, 10)
	disable_several_info("jup_rasvet_base_bodyguard_", "_death", 1, 2)
	disable_info("jup_rasvet_base_actor_hit", "jup_rasvet_base_hit")
end

function recoil_jup_killer_base_part_1(actor, npc)
	disable_several_info("jup_killer_base_patrol_", "_death", 1, 8)
	disable_info("jup_killer_base_actor_hit")
end

function recoil_jup_killer_base_part_2(actor, npc)
	disable_several_info("jup_killer_base_sentry_", "_death", 1, 20)
	disable_info("jup_killer_base_actor_hit")
end

function recoil_pri_monolit_base(actor, npc)
	disable_several_info("pri_monolit_base_guard_", "_death", 1, 10)
	disable_several_info("pri_monolit_base_sniper_", "_death", 1, 3)
	disable_several_info("pri_monolit_base_sentry_", "_death", 1, 3)
	disable_info("pri_monolit_base_actor_hit", "pri_monolit_base_hit")
end

------------------------------------------------------------------------------
--                     Функции для телохранителей                           --
------------------------------------------------------------------------------
function bodyguard_init(actor, npc)
	if sgm_g.dont_has_alife_info(npc:profile_name() .. "_init") then
		give_info(npc:profile_name() .. "_init")
		news_manager.bodyguard_tip(db.actor,
			game.translate_string("st_bodyguard_init_tip") .. " «" .. npc:character_name() .. "»", 0, "bodyguard", 10000,
			nil, "st_add_info_title")
	end
end

function bodyguard_death(actor, npc)
	if has_alife_info(npc:profile_name() .. "_pursue") then
		news_manager.bodyguard_tip(db.actor,
			game.translate_string("st_bodyguard_death_tip") ..
			" «" .. npc:character_name() .. "» - " .. game.translate_string("st_bodyguard_death2_tip"), 0, "bodyguard",
			10000, nil, "st_add_info_title")
	end
	disable_info(npc:profile_name() .. "_stand_and_fire")
	disable_info(npc:profile_name() .. "_nofire")
	disable_info(npc:profile_name() .. "_stop")
	disable_info(npc:profile_name() .. "_pursue")
end

function bodyguard_command_0(actor, npc)
	news_manager.bodyguard_tip(db.actor,
		game.translate_string("st_bodyguard_commands_tip") ..
		" «" .. npc:character_name() .. "» - " .. game.translate_string("st_bodyguard_command_0_tip"), 0, "bodyguard",
		6000, nil, "st_add_info_title")
end

function bodyguard_command_1(actor, npc)
	news_manager.bodyguard_tip(db.actor,
		game.translate_string("st_bodyguard_commands_tip") ..
		" «" .. npc:character_name() .. "» - " .. game.translate_string("st_bodyguard_command_1_tip"), 0, "bodyguard",
		6000, nil, "st_add_info_title")
end

function bodyguard_command_2(actor, npc)
	news_manager.send_tip(db.actor,
		game.translate_string("st_bodyguard_commands_tip") ..
		" «" .. npc:character_name() .. "» - " .. game.translate_string("st_bodyguard_command_2_tip"), 0, "bodyguard",
		6000, nil, "st_add_info_title")
end

function bodyguard_command_3(actor, npc)
	news_manager.send_tip(db.actor,
		game.translate_string("st_bodyguard_commands_tip") ..
		" «" .. npc:character_name() .. "» - " .. game.translate_string("st_bodyguard_command_3_tip"), 0, "bodyguard",
		6000, nil, "st_add_info_title")
end

function bodyguard_command_4(actor, npc)
	news_manager.send_tip(db.actor,
		game.translate_string("st_bodyguard_commands_tip") ..
		" «" .. npc:character_name() .. "» - " .. game.translate_string("st_bodyguard_command_4_tip"), 0, "bodyguard",
		6000, nil, "st_add_info_title")
	disable_info(npc:profile_name() .. "_stand_and_fire")
	disable_info(npc:profile_name() .. "_nofire")
	disable_info(npc:profile_name() .. "_stop")
	disable_info(npc:profile_name() .. "_release")
	disable_info(npc:profile_name() .. "_pursue")
	sgm_g.remove_spot_on_map(npc:id(), sgm_flags.spot_actor_guard)
	for k, v in pairs(xr_bodyguard.bodyguards_config) do
		if k ~= nil and npc:profile_name() == k then
			xr_effects["respawn_" .. k](actor, npc)
		end
	end
end

function respawn_zat_stalker_bodyguard(actor, npc)
	create("zat_stalker_bodyguard", 105.417, -1.338, 179.173, 1148335, 316)
	disable_info("zat_stalker_bodyguard_init", "zat_stalker_bodyguard_danger")
end

function respawn_zat_bandit_bodyguard(actor, npc)
	create("zat_bandit_bodyguard", 405.858, 39.446, -18.573, 1633413, 293)
	disable_info("zat_bandit_bodyguard_init", "zat_bandit_bodyguard_danger")
end

function respawn_jup_freedom_bodyguard(actor, npc)
	create("jup_freedom_bodyguard", -58.776, 3.487, 190.235, 621642, 368)
	disable_info("jup_freedom_bodyguard_init", "jup_freedom_bodyguard_danger")
end

function respawn_jup_army_bodyguard(actor, npc)
	create("jup_army_bodyguard", -58.776, 3.487, 190.235, 621642, 368)
	disable_info("jup_army_bodyguard_init", "jup_army_bodyguard_danger")
end

function respawn_jup_killer_bodyguard(actor, npc)
	create("jup_killer_bodyguard", 230.462, 28.146, -420.110, 1109403, 610)
	disable_info("jup_killer_bodyguard_init", "jup_killer_bodyguard_danger")
end

function respawn_pri_army_bodyguard(actor, npc)
	create("pri_army_bodyguard", 147.369, -0.095, -185.508, 377149, 708)
	disable_info("pri_army_bodyguard_init", "pri_army_bodyguard_danger")
end

function respawn_pri_monolith_bodyguard(actor, npc)
	create("pri_monolith_bodyguard", -180.116, 0.668, -348.861, 34718, 806)
	disable_info("pri_monolith_bodyguard_init", "pri_monolith_bodyguard_danger")
end

------------------------------------------------------------------------------
--                            Функции для квестов                           --
------------------------------------------------------------------------------
function zat_accompany_stalker_ambush_action(actor, npc)
	create("boar_normal", 128.99235534668, 1.4472534656525, 390.87936401367, 1187887, 134)
	create("boar_strong", 126.70880889893, 3.1739783287048, 370.45471191406, 1184330, 134)
	create("boar_normal", 88.661109924316, 8.7471570968628, 368.44290161133, 1119433, 135)
	create("boar_strong", 56.869701385498, 13.433298110962, 382.32415771484, 1059309, 137)
	create("boar_normal", 52.019958496094, 13.558873176575, 409.54943847656, 1049705, 197)
end

function zat_chimera_zagon_final_tip(actor, npc)
	--/news_manager.send_tip(db.actor,"zat_chimera_zagon_final_text",0,"chimera",5000,nil,npc:character_name()..":")
end

function zat_accompany_to_boat(actor, npc)
	if sgm_g.dont_has_alife_info("zat_accompany_to_boat_i_am_alone") then
		create("zat_accompany_to_boat_spot", 148.695, -7.344, 183.552, 1220159, 295)
		give_info("zat_accompany_to_boat_alt")
		give_info("zat_accompany_to_boat_start")
		add_task("sgm_zat_accompany_to_boat")
	end
end

function zat_duty_kanevskiy_charge(actor, npc)
	if get_global_pattern() == 1 then
		activate_detonate_charge(npc, math.random(5000, 6000), "visible_big", 576.815, 10.850, -288.893, 1841058, 220)
		create("snork_normal", 518.00732421875, 9.1930103302002, -293.25762939453, 1797434, 83)
		create("snork_normal", 524.24975585938, 18.880195617676, -338.07827758789, 1804512, 82)
		create("snork_normal", 533.1416015625, -1.9498739242554, -245.36294555664, 1814147, 220)
		create("snork_normal_hunter", 545.13287353516, -0.87468135356903, -242.7574005127, 1827065, 220)
	else
		activate_detonate_charge(npc, math.random(5000, 6000), "visible_big", -419.209, 25.620, -216.804, 149223, 93)
		create("snork_normal", -436.53112792969, 13.097826004028, -161.74021911621, 126567, 39)
		create("snork_normal", -430.52825927734, 13.314255714417, -168.42752075195, 133696, 39)
		create("snork_normal", -407.05767822266, 20.789720535278, -161.07034301758, 166994, 39)
		create("snork_strong_hunter", -429.6042175293, 13.857533454895, -138.47366333008, 134614, 94)
	end
end

function zat_ambush_vobla_sniper(actor, npc)
	create("zat_vobla_protection_sniper", 412.876, 5.907, 258.636, 1645736, 7)
end

function zat_ambush_heli_5(actor, npc)
	create("zat_heli_5_sniper", -447.016, -1.728, 92.031, 115302, 214)
end

function zat_breeder_reborn(actor, npc)
	create("zat_stalker_breeder2", 114.681, -7.348, 186.171, 1163606, 316)
end

function zat_monsters_1st_wave_update(actor, npc)
	if sgm_g.dont_has_alife_info("zat_monsters_wave_1st_wave_end") then
		sgm_g.inc_mod_param("zat_monster_w1_deaths")
		if read_mod_param("zat_monster_w1_deaths") >= 30 then
			clear_all_objects("monster", 1, 150)
			give_info("zat_monsters_wave_1st_wave_end")
			clear_mod_param("zat_monster_w1_deaths")
			clear_mod_param("zat_monster_w1_spawned")
			game_autosave_assign("save_zat_monsters_1st_wave_end")
		end
	end
end

function zat_monsters_2nd_wave_update(actor, npc)
	if sgm_g.dont_has_alife_info("zat_monsters_wave_2nd_wave_end") then
		sgm_g.inc_mod_param("zat_monster_w2_deaths")
		if read_mod_param("zat_monster_w2_deaths") >= 36 then
			clear_all_objects("monster", 1, 150)
			give_info("zat_monsters_wave_2nd_wave_end")
			clear_mod_param("zat_monster_w2_deaths")
			clear_mod_param("zat_monster_w2_spawned")
			game_autosave_assign("save_zat_monsters_2nd_wave_end")
		end
	end
end

function zat_monsters_3rd_wave_update(actor, npc)
	if sgm_g.dont_has_alife_info("zat_monsters_wave_3rd_wave_end") then
		sgm_g.inc_mod_param("zat_monster_w3_deaths")
		if read_mod_param("zat_monster_w3_deaths") >= 42 then
			clear_all_objects("monster", 1, 250)
			give_info("zat_monsters_wave_3rd_wave_end")
			clear_mod_param("zat_monster_w3_deaths")
			clear_mod_param("zat_monster_w3_spawned")
			game_autosave_assign("save_zat_monsters_3rd_wave_end")
		end
	end
end

function zat_monsters_wave_commander_death(actor, npc)
	if sgm_g.dont_has_alife_info("zat_monsters_wave_3_controller_destroyed") and sgm_g.dont_has_alife_info("zat_monsters_wave_fail") then
		clear_all_objects("monster", 1, 200)
		news_manager.send_tip(db.actor, "zat_barge_noah_about_commander_death_text", 0, "portrait_Noy", 8000, nil,
			"zat_barge_noah_title")
		give_info("zat_monsters_wave_fail")
	end
end

function zat_monsters_wave_1_controller_appeared(actor, npc)
	if sgm_g.dont_has_alife_info("zat_monsters_wave_defence_commander_killed") then
		news_manager.send_tip(db.actor, "zat_monsters_wave_1_controller_appeared_text", 0, "portrait_neutral_4", 12000,
			nil, "zat_barge_defence_commander_title")
	end
end

function zat_monsters_wave_2_controller_appeared(actor, npc)
	if sgm_g.dont_has_alife_info("zat_monsters_wave_defence_commander_killed") then
		news_manager.send_tip(db.actor, "zat_monsters_wave_2_controller_appeared_text", 0, "portrait_neutral_4", 12000,
			nil, "zat_barge_defence_commander_title")
	end
end

function zat_monsters_wave_3_controller_appeared(actor, npc)
	if sgm_g.dont_has_alife_info("zat_monsters_wave_defence_commander_killed") then
		news_manager.send_tip(db.actor, "zat_monsters_wave_3_controller_appeared_text", 0, "portrait_neutral_4", 12000,
			nil, "zat_barge_defence_commander_title")
	end
end

function zat_homsa_attacked_update_1(actor, npc)
	if sgm_g.dont_has_alife_info("zat_homsa_from_monsters_wave_1") then
		sgm_g.inc_mod_param("zat_homsa_attacked_monsters_deaths_1")
		if read_mod_param("zat_homsa_attacked_monsters_deaths_1") >= 3 then
			give_info("zat_homsa_from_monsters_wave_1")
			clear_mod_param("zat_homsa_attacked_monsters_deaths_1")
		end
	end
end

function zat_homsa_attacked_update_2(actor, npc)
	if sgm_g.dont_has_alife_info("zat_homsa_from_monsters_wave_2") then
		sgm_g.inc_mod_param("zat_homsa_attacked_monsters_deaths_2")
		if read_mod_param("zat_homsa_attacked_monsters_deaths_2") >= 3 then
			give_info("zat_homsa_from_monsters_wave_2")
			clear_mod_param("zat_homsa_attacked_monsters_deaths_2")
		end
	end
end

function zat_homsa_attacked_update_3(actor, npc)
	if sgm_g.dont_has_alife_info("zat_homsa_from_monsters_wave_3") then
		sgm_g.inc_mod_param("zat_homsa_attacked_monsters_deaths_3")
		if read_mod_param("zat_homsa_attacked_monsters_deaths_3") >= 2 then
			give_info("zat_homsa_from_monsters_wave_3")
			clear_mod_param("zat_homsa_attacked_monsters_deaths_3")
		end
	end
end

function zat_b103_merc_task_spez_1_create(actor, npc)
	if sgm_g.dont_has_alife_info("zat_quest_the_spez_freedom_all_dead") then
		create("zat_quest_the_spez_1_spot", -497.307, 28.247, -224.915, 58005, 38)
		create("zat_ecolog_spez_case", 179.622, 4.821, -191.095, 1273476, 78)
		create("zat_quest_the_spez_freedom_1_1", -507.797, 30.262, -232.305, 44475, 38)
		create("zat_quest_the_spez_freedom_1_2", -517.463, 31.208, -225.713, 32511, 38)
		create("zat_quest_the_spez_freedom_1_3", -530.278, 33.182, -222.015, 17887, 38)
		create("zat_quest_the_spez_freedom_1_4", -491.417, 28.930, -241.236, 65130, 38)
		create("zat_quest_the_spez_freedom_1_5", -520.189, 30.845, -209.555, 29305, 38)
		create_dead_body("zat_quest_the_spez_dolg_1_dead_1", "bio_bandage", 186.669, 4.821, -188.737, 1285026, 78)
		create_dead_body("zat_quest_the_spez_dolg_1_dead_2", "bio_bandage", 179.224, 4.821, -185.916, 1272319, 78)
		create_dead_body("zat_quest_the_spez_dolg_1_dead_3", "bio_bandage", 182.748, 4.821, -179.858, 1278168, 78)
		create_dead_body("zat_quest_the_spez_dolg_1_dead_4", "bio_bandage", 194.997, 5.637, -211.848, 1298331, 78)
		create_dead_body("zat_quest_the_spez_ecolog_1_dead_1", "bio_bandage", 169.139, 4.820, -186.843, 1255912, 149)
		create_dead_body("zat_quest_the_spez_ecolog_1_dead_2", "bio_bandage", 170.986, 4.818, -191.644, 1258189, 78)
		create_dead_body("zat_quest_the_spez_ecolog_1_dead_3", "bio_bandage", 193.258, 4.820, -187.768, 1294967, 78)
	end
end

function zat_b103_merc_task_spez_2_create(actor, npc)
	if sgm_g.dont_has_alife_info("zat_quest_the_spez_all_ecodolg_killed") then
		create("zat_quest_the_spez_2_spot", 523.335, -7.074, -168.535, 1803082, 83)
		create("zat_quest_the_spez_freedom_2_1", 475.759, 31.968, -433.542, 1740924, 82)
		create("zat_quest_the_spez_freedom_2_2", 472.630, 31.717, -440.119, 1735847, 74)
		create("zat_quest_the_spez_freedom_2_3", 463.886, 31.541, -439.264, 1723576, 74)
		create("zat_quest_the_spez_freedom_2_4", 475.322, 31.735, -442.787, 1739919, 82)
		create("zat_quest_the_spez_freedom_2_5", 481.279, 32.086, -443.815, 1748102, 82)
	end
end

function zat_b103_merc_task_spez_3_create(actor, npc)
	if sgm_g.dont_has_alife_info("zat_quest_the_spez_all_ecodolg_killed") then
		create("zat_ecolog_spez_case", 569.290, -7.367, -195.043, 1838561, 220)
		create("zat_quest_the_spez_ecolog_2_1", 575.513, -5.884, -201.112, 1840389, 220)
		create("zat_quest_the_spez_ecolog_2_2", 574.887, -6.418, -200.279, 1840203, 220)
		create("zat_quest_the_spez_ecolog_2_3", 574.096, -6.903, -199.103, 1839820, 220)
		create("zat_quest_the_spez_dolg_2_1", 573.080, -7.138, -197.977, 1839820, 220)
		create("zat_quest_the_spez_dolg_2_2", 571.863, -7.170, -198.591, 1839820, 220)
		create("zat_quest_the_spez_dolg_2_3", 571.143, -7.158, -201.207, 1839627, 220)
		create("zat_quest_the_spez_dolg_2_4", 570.565, -7.149, -203.440, 1839429, 220)
		create("zat_quest_the_spez_killer_razvodayshi", 434.788, 33.471, -231.101, 1672074, 73)
	end
end

function zat_a6_sultan_quest_kontra_create_enemy(actor, npc)
	if sgm_g.dont_has_alife_info("zat_a6_sultan_quest_kontra_all_lucian_member_dead") then
		create("zat_bandit_kontrabanda_lucian_2", 483.578, -5.846, 199.974, 1475874, 519)
		create("zat_bandit_kontrabanda_killer_1_2", 478.171, -6.404, 199.471, 1470114, 519)
		create("zat_bandit_kontrabanda_killer_2_2", 474.305, -6.497, 193.143, 1465791, 524)
		create("zat_bandit_kontrabanda_killer_3_2", 474.526, -6.533, 215.412, 1465818, 519)
	end
end

function zat_alfa_sabotage_squad_update(actor, npc)
	if sgm_g.dont_has_alife_info("zat_alfa_sabotage_alfa_dead") then
		sgm_g.inc_mod_param("zat_alfa_sabotage_squad_deaths")
		if read_mod_param("zat_alfa_sabotage_squad_deaths") >= 4 then
			give_info("zat_alfa_sabotage_alfa_dead")
			clear_mod_param("zat_alfa_sabotage_squad_deaths")
		end
	end
end

function zat_alfa_sabotage_charge_update(actor, npc)
	if sgm_g.dont_has_alife_info("zat_alfa_sabotage_charge_all_innocuous") then
		sgm_g.inc_mod_param("zat_alfa_sabotage_charge_innocuous")
	end
end

function jup_replace_on_tower_1(actor, npc)
	npc:set_npc_position(vector():set(-63.238, 33.481, -336.089))
end

function jup_replace_on_tower_2(actor, npc)
	npc:set_npc_position(vector():set(-53.237, 33.500, -335.834))
end

function jup_rasvet_eliminate_burrows_hole_1_launch(actor, npc)
	create_force("jup_rasvet_monsters_1_hole_squad", 382.375, -5.818, 465.765, 1321140, 563)
	give_info("jup_rasvet_eliminate_burrows_1_hole_spawn")
end

function jup_rasvet_eliminate_burrows_hole_2_launch(actor, npc)
	if sgm_g.dont_has_alife_info("jup_rasvet_eliminate_burrows_fail") then
		news_manager.send_tip(db.actor, "jup_rasvet_leader_about_eliminate_burrow_2_text", 0, "portrait_Nebo_3", 7000,
			nil, "jup_rasvet_leader_title", false)
		create_force("jup_rasvet_monsters_2_hole_squad", 417.749, 27.089, -424.699, 1370173, 555)
		give_info("jup_rasvet_eliminate_burrows_2_hole_spawn")
		game_autosave_assign("save_jup_rasvet_monsters_hole_1_destroyed")
	end
end

function jup_rasvet_eliminate_burrows_hole_3_launch(actor, npc)
	if sgm_g.dont_has_alife_info("jup_rasvet_eliminate_burrows_fail") then
		news_manager.send_tip(db.actor, "jup_rasvet_leader_about_eliminate_burrow_3_text", 0, "portrait_Nebo_3", 7000,
			nil, "jup_rasvet_leader_title", false)
		create_force("jup_rasvet_monsters_3_hole_squad", -280.001, 5.959, -443.465, 240801, 576)
		give_info("jup_rasvet_eliminate_burrows_3_hole_spawn")
		game_autosave_assign("save_jup_rasvet_monsters_hole_2_destroyed")
	end
end

function jup_rasvet_eliminate_burrows_hole_4_launch(actor, npc)
	if sgm_g.dont_has_alife_info("jup_rasvet_eliminate_burrows_fail") then
		news_manager.send_tip(db.actor, "jup_rasvet_leader_about_eliminate_burrow_4_text", 0, "portrait_Nebo_3", 7000,
			nil, "jup_rasvet_leader_title", false)
		create_force("jup_rasvet_monsters_4_hole_squad", -240.671, 1.456, -119.465, 308289, 449)
		give_info("jup_rasvet_eliminate_burrows_4_hole_spawn")
		game_autosave_assign("save_jup_rasvet_monsters_hole_3_destroyed")
	end
end

function jup_rasvet_eliminate_burrows_hole_5_launch(actor, npc)
	if sgm_g.dont_has_alife_info("jup_rasvet_eliminate_burrows_fail") then
		news_manager.send_tip(db.actor, "jup_rasvet_leader_about_eliminate_burrow_5_text", 0, "portrait_Nebo_3", 7000,
			nil, "jup_rasvet_leader_title", false)
		create_force("jup_rasvet_monsters_5_hole_squad", -406.648, 4.255, -108.928, 35167, 451)
		give_info("jup_rasvet_eliminate_burrows_5_hole_spawn")
	end
end

function jup_rasvet_eliminate_burrows_hole_5_victory(actor, npc)
	if sgm_g.dont_has_alife_info("jup_rasvet_eliminate_burrows_fail") then
		play_snd_at_actor([[characters_voice\human_01\csky\alife\defence\actor_help_1]])
		news_manager.send_tip(db.actor, "jup_rasvet_leader_about_eliminate_burrow_5_victory_text", 0, "portrait_Nebo_3",
			7000, nil, "jup_rasvet_leader_title", false)
	end
end

function jup_psi_spawner(actor, npc)
	create("jup_psi_controller_1", 315.936, 34.592, -232.588, 1223840, 549)
end

function jup_ambush_zombied_spawner(actor, npc)
	create("jup_ambush_zombied_1", 334.939, 27.179, -268.859, 1250657, 549)
	create("jup_ambush_zombied_2", 330.469, 26.866, -254.539, 1244500, 549)
	create("jup_ambush_zombied_3", 303.445, 27.289, -262.975, 1207137, 633)
	create("jup_ambush_zombied_4", 316.412, 26.872, -248.719, 1224770, 633)
	create("jup_ambush_zombied_5", 344.804, 27.979, -240.368, 1266513, 549)
	create("jup_ambush_zombied_6", 355.324, 27.161, -260.047, 1279815, 549)
end

function jup_killer_first_squad_controler(actor, npc)
	create("jup_psi_controller_1", 315.936, 34.592, -232.588, 1223840, 549)
end

function jup_killer_first_squad_1_mutation(actor, npc)
	--/create("jup_ambush_zombied_7",npc:position().x+math.random(-5,5),npc:position().y,npc:position().z+math.random(-5,5),npc:level_vertex_id(),npc:game_vertex_id())
end

function jup_killer_first_squad_2_mutation(actor, npc)
	--/create("jup_ambush_zombied_8",npc:position().x+math.random(-5,5),npc:position().y,npc:position().z+math.random(-5,5),npc:level_vertex_id(),npc:game_vertex_id())
end

function jup_killer_first_squad_3_mutation(actor, npc)
	--/create("jup_ambush_zombied_9",npc:position().x+math.random(-5,5),npc:position().y,npc:position().z+math.random(-5,5),npc:level_vertex_id(),npc:game_vertex_id())
end

function jup_killer_first_squad_4_mutation(actor, npc)
	--/create("jup_ambush_zombied_10",npc:position().x+math.random(-5,5),npc:position().y,npc:position().z+math.random(-5,5),npc:level_vertex_id(),npc:game_vertex_id())
end

function jup_ambush_zombied_check(actor, npc)
	if has_several_info("jup_ambush_zombied_", "_death", 1, 6) and sgm_g.dont_has_alife_info("jup_mercenary_check_plant_clear_perimetr") then
		give_info("jup_mercenary_check_plant_clear_perimetr")
		game_autosave_assign("save_jup_mercenary_check_plant_sector_clear")
	end
end

function jup_psi_controller_check(actor, npc)
	if sgm_g.dont_has_alife_info("jup_mercenary_check_plant_snorks") then
		sgm_g.inc_mod_param("jup_ambush_zombied_deaths")
		if read_mod_param("jup_ambush_zombied_deaths") >= 12 then
			create("jup_after_fight_snork_1", 282.904, 27.866, -212.074, 1180670, 653)
			create("jup_after_fight_snork_2", 414.830, 27.297, -240.032, 1371492, 641)
			create("jup_after_fight_snork_3", 405.413, 27.131, -266.837, 1354848, 637)
			create("jup_after_fight_snork_4", 381.892, 27.976, -239.890, 1320306, 642)
			create("jup_after_fight_snork_5", 265.964, 28.271, -179.728, 1159642, 537)
			clear_mod_param("jup_ambush_zombied_deaths")
			give_info("jup_mercenary_check_plant_snorks")
		end
	end
	if has_several_info("jup_after_fight_snork_", "_death", 1, 5) and sgm_g.dont_has_alife_info("jup_mercenary_check_plant_have_secured") then
		give_info("jup_mercenary_check_plant_have_secured")
	end
end

function jup_beylis_ambush_effect(actor, npc)
	create("chimera_normal", 72.532, 24.061, -168.847, 839146, 363)
	create("bloodsucker_strong", 72.532, 24.061, -168.847, 839146, 363)
end

function jup_train_zasada(actor, npc)
	create("jup_train_bandit_sniper", -95.290, 5.250, 203.518, 564533, 592)
end

function jup_rasvet_attacked_update(actor, npc)
	if sgm_g.dont_has_alife_info("jup_beat_from_monsters_safely") then
		sgm_g.inc_mod_param("jup_attacked_monsters_deaths")
		if read_mod_param("jup_attacked_monsters_deaths") >= 19 then
			give_info("jup_beat_from_monsters_safely")
			clear_mod_param("jup_attacked_monsters_deaths")
		end
	end
end

function jup_night_killers_check(actor, npc)
	if has_several_info("jup_night_killer_", "_death", 1, 8) and sgm_g.dont_has_alife_info("jup_destroy_night_killers_perebil") then
		give_info("jup_destroy_night_killers_perebil")
	end
	if has_several_info("jup_night_killer_", "_death", 1, 7) and sgm_g.dont_has_alife_info("jup_destroy_night_killers_esche") then
		create("jup_night_killer_8", 263.041, -17.519, 193.630, 1154748, 614)
		create("jup_night_killer_9", 423.285, 4.455, -72.301, 1384995, 527)
		give_info("jup_destroy_night_killers_esche")
	end
end

function jup_follower_scientist_check(actor, npc)
	if has_several_info("jup_follower_scientist_", "_death", 1, 5) and sgm_g.dont_has_alife_info("jup_follow_scientists_fail") then
		give_info("jup_follow_scientists_fail")
	elseif has_alife_info("jup_follower_scientist_1_death") and sgm_g.dont_has_alife_info("jup_follow_scientists_fail") then
		give_info("jup_follow_scientists_fail")
	end
end

function jup_witnesses_members_update(actor, npc)
	if sgm_g.dont_has_alife_info("jup_avoid_witnesses_cleaned") then
		sgm_g.inc_mod_param("jup_witnesses_deaths")
		if read_mod_param("jup_witnesses_deaths") >= 11 then
			give_info("jup_avoid_witnesses_cleaned")
			clear_mod_param("jup_witnesses_deaths")
			game_autosave_assign("save_jup_avoid_witnesses_rescued")
		end
	end
end

function jup_start_psi_sleep(actor, npc)
	news_manager.send_tip(db.actor, sgm_functions.ReadCaption("psy_complex"), 0, "got_medicine", 2500, nil,
		"st_item_used")
	disable_ui(db.actor, nil)
	level.add_cam_effector("camera_effects\\sleep.anm", 10, false, "ui_sleep_dialog.psi_sleep_callback")
	level.add_pp_effector("sleep_fade.ppe", 11, false)
	give_info("actor_is_sleeping")
	_G.mus_vol = get_console():get_float("snd_volume_music")
	_G.amb_vol = get_console():get_float("snd_volume_eff")
	get_console():execute("snd_volume_music 0")
	get_console():execute("snd_volume_eff 0")
	surge_manager.resurrect_skip_message()
end

function jup_killer_caravan_update(actor, npc)
	if has_alife_info("jup_killer_caravan_commander_death") and has_alife_info("jup_killer_caravan_member1_death") and has_alife_info("jup_killer_caravan_member2_death") and has_alife_info("jup_killer_caravan_member3_death") then
		give_info("jup_examine_caravan_is_dead")
	end
end

function jup_rasvet_polter_effect(actor, npc)
	if sgm_g.dont_has_alife_info("jup_rasvet_polter_skauts_talking") then
		play_snd_at_actor([[ambient\blowout_begin]])
		level.add_cam_effector("camera_effects\\shell_shock.anm", 118711, false, "")
		level.add_cam_effector("camera_effects\\earthquake_00.anm", 118712, false, "")
		level.add_pp_effector("snd_shock.ppe", 118713, false)
		level.add_pp_effector("shock_hit.ppe", 118990, false)
		level.set_pp_effector_factor(118990, 20)
		level.set_pp_effector_factor(118713, 0.5)
		news_manager.send_tip(db.actor, "jup_rasvet_migel_about_help_text", 0, "portrait_Nebo_1", 7000, nil,
			"jup_rasvet_migel_title", false)
	end
end

function jup_rasvet_prior_create_dead_body(actor, npc)
	if sgm_g.dont_has_alife_info("jup_b206_rasvet_prior_quest_fail") then
		news_manager.send_tip(db.actor, "jup_rasvet_leader_quest_about_dead_patrol_text", 0, "portrait_Nebo_3", 18000,
			nil, "jup_rasvet_leader_title", false)
		create("jup_rasvet_gudvin_letter", -194.194, 5.516, -76.940, 385941, 390)
		create("jup_rasvet_prior_quest_spot_1", -435.352, 9.615, -2.013, 5287, 376)
		create("jup_rasvet_prior_quest_spot_2", -200.808, 3.491, -439.198, 376193, 480)
		create_dead_body("jup_rasvet_prior_patrol_dead_1", "bio_bandage", -401.678, -2.680, 176.045, 42739, 644)
		create_dead_body("jup_rasvet_prior_patrol_dead_2", "bio_bandage", -406.250, -2.707, 168.987, 36537, 644)
		create_dead_body("jup_rasvet_prior_patrol_dead_3", "bio_bandage", -411.953, -2.670, 170.436, 27802, 644)
		create_dead_body("jup_rasvet_prior_patrol_dead_4", "bio_bandage", -417.420, -2.938, 179.110, 21724, 644)
	end
end

function jup_rasvet_prior_create_enemy_himera(actor, npc)
	if sgm_g.dont_has_alife_info("jup_b206_rasvet_prior_quest_fail") then
		create("jup_rasvet_quest_prior_himera_1", -406.241, 10.798, -9.445, 36294, 376)
		create("jup_rasvet_quest_prior_himera_2", -407.667, 9.858, -17.224, 34297, 376)
	end
end

function jup_rasvet_prior_create_enemy_angel(actor, npc)
	if sgm_g.dont_has_alife_info("jup_b206_rasvet_prior_quest_fail") then
		create("jup_rasvet_prior_zas_black_angel_1", -226.175, 3.405, -360.943, 332918, 480)
		create("jup_rasvet_prior_zas_black_angel_2", -219.538, 3.484, -360.620, 344092, 480)
		create("jup_rasvet_prior_zas_black_angel_3", -209.997, 5.487, -361.854, 360854, 480)
		create("jup_rasvet_prior_zas_black_angel_4", -232.104, 3.826, -365.464, 322358, 480)
		create("jup_rasvet_prior_zas_black_angel_5", -223.236, 3.422, -360.593, 337807, 480)
	end
end

function jup_a6_azot_quest_cheked_plant_1(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "jup_a6_azot_restr_plant_1" }) then
		db.actor:give_info_portion("jup_b206_modul_restr_1_searched")
		give_actor(db.actor, nil, { "jup_b12_plant_memory_1" })
	end
end

function jup_a6_azot_quest_cheked_plant_2(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "jup_a6_azot_restr_plant_2" }) then
		db.actor:give_info_portion("jup_b206_modul_restr_2_searched")
		give_actor(db.actor, nil, { "jup_b12_plant_memory_2" })
	end
end

function jup_a6_azot_quest_cheked_plant_3(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "jup_a6_azot_restr_plant_3" }) then
		create("jup_a6_azat_quest_mechanik_kurier_2", 407.324, 27.297, -465.436, 1358134, 555)
		db.actor:give_info_portion("jup_b206_modul_restr_3_searched")
		give_actor(db.actor, nil, { "jup_b12_plant_memory_3" })
	end
end

function jup_a6_azot_quest_mech_kutier_2_charge(actor, npc)
	activate_detonate_charge(npc, 0, "visible_big", 407.324, 27.297, -465.436, 1358134, 555)
end

function pri_monolith_use_temple(actor, npc)
	give_info("pri_expiation_sin_3_back_to_temple")
	play_snd_at_actor([[sound_effects\monolith_voice2]])
end

function pri_quest_bloodsucker_sleep1_activate(actor, npc)
	xr_effects.disable_ui_only(db.actor, nil)
	level.add_cam_effector("camera_effects\\surge_02.anm", 10, false, "xr_effects.pri_quest_bloodsucker_sleep1_callback1")
	level.add_pp_effector("surge_fade.ppe", 11, false)
	_G.mus_vol = get_console():get_float("snd_volume_music")
	_G.amb_vol = get_console():get_float("snd_volume_eff")
	get_console():execute("snd_volume_music 0")
	get_console():execute("snd_volume_eff 0")
	create("quest_bloodsucker_letter_1", 44.696, 17.434, -138.663, 259128, 698)
end

function pri_quest_bloodsucker_sleep1_callback1()
	set_ui_disabled()
	level.add_cam_effector("camera_effects\\surge_01.anm", 10, false, "xr_effects.pri_quest_bloodsucker_sleep1_callback2")
	local rnd = math.random(35, 45)
	sgm_callbacks.on_forward_game_time(0, rnd)
	level.change_game_time(0, 0, rnd)
	level_weathers.get_weather_manager():forced_weather_change()
end

function pri_quest_bloodsucker_sleep1_callback2()
	set_ui_worked()
	xr_effects.enable_ui(db.actor, nil)
	get_console():execute("snd_volume_music " .. tostring(_G.mus_vol))
	get_console():execute("snd_volume_eff " .. tostring(_G.amb_vol))
	_G.amb_vol = 0
	_G.mus_vol = 0
	give_info("pri_bloodsucker_vaccine_1st_sleep_end")
end

function pri_quest_bloodsucker_sleep2_activate(actor, npc)
	xr_effects.disable_ui_only(db.actor, nil)
	level.add_cam_effector("camera_effects\\surge_02.anm", 10, false, "xr_effects.pri_quest_bloodsucker_sleep2_callback1")
	level.add_pp_effector("surge_fade.ppe", 11, false)
	_G.mus_vol = get_console():get_float("snd_volume_music")
	_G.amb_vol = get_console():get_float("snd_volume_eff")
	get_console():execute("snd_volume_music 0")
	get_console():execute("snd_volume_eff 0")
	create("quest_bloodsucker_letter_2", 44.696, 17.434, -138.663, 259128, 698)
end

function pri_quest_bloodsucker_sleep2_callback1()
	set_ui_disabled()
	level.add_cam_effector("camera_effects\\surge_01.anm", 10, false, "xr_effects.pri_quest_bloodsucker_sleep2_callback2")
	local rnd = math.random(35, 45)
	sgm_callbacks.on_forward_game_time(0, rnd)
	level.change_game_time(0, 0, rnd)
	level_weathers.get_weather_manager():forced_weather_change()
end

function pri_quest_bloodsucker_sleep2_callback2()
	set_ui_worked()
	xr_effects.enable_ui(db.actor, nil)
	get_console():execute("snd_volume_music " .. tostring(_G.mus_vol))
	get_console():execute("snd_volume_eff " .. tostring(_G.amb_vol))
	_G.amb_vol = 0
	_G.mus_vol = 0
	give_info("pri_bloodsucker_vaccine_2nd_sleep_end")
end

function pass_guide_keeper_alfa_update(actor, npc)
	if sgm_g.dont_has_alife_info("pri_rescue_underground_guide_terrain_is_secured") then
		sgm_g.inc_mod_param("pass_keeper_alfa_deaths")
		if read_mod_param("pass_keeper_alfa_deaths") >= 21 then
			give_info("pri_rescue_underground_guide_terrain_is_secured")
			clear_mod_param("pass_keeper_alfa_deaths")
			game_autosave_assign("save_pri_rescue_guide_terrain_is_secured")
		end
	end
end

function val_b2_accompany_guider_ambush_action(actor, npc)
	create("boar_normal_hunter", -129.554, -1.352, -279.815, 28670, 1111)
end

function val_b2_assault_b1_commander_death_1(actor, npc)
	give_info("val_alt_storyline_commenced", "val_assault_factory_squad_commander_dead")
end

function val_b2_assault_b1_commander_death_2(actor, npc)
	give_info("val_assault_factory_squad_commander_dead")
end

function val_lucas_attacked_update_1(actor, npc)
	if sgm_g.dont_has_alife_info("val_beat_from_monsters_wave_1") then
		sgm_g.inc_mod_param("val_attacked_monsters_deaths_1")
		if read_mod_param("val_attacked_monsters_deaths_1") >= 7 then
			give_info("val_beat_from_monsters_wave_1")
			clear_mod_param("val_attacked_monsters_deaths_1")
		end
	end
end

function val_lucas_attacked_update_2(actor, npc)
	if sgm_g.dont_has_alife_info("val_beat_from_monsters_wave_2") then
		sgm_g.inc_mod_param("val_attacked_monsters_deaths_2")
		if read_mod_param("val_attacked_monsters_deaths_2") >= 9 then
			give_info("val_beat_from_monsters_wave_2")
			clear_mod_param("val_attacked_monsters_deaths_2")
		end
	end
end

function val_lucas_attacked_update_3(actor, npc)
	if sgm_g.dont_has_alife_info("val_beat_from_monsters_wave_3") then
		sgm_g.inc_mod_param("val_attacked_monsters_deaths_3")
		if read_mod_param("val_attacked_monsters_deaths_3") >= 3 then
			give_info("val_beat_from_monsters_wave_3")
			clear_mod_param("val_attacked_monsters_deaths_3")
		end
	end
end

function val_lucas_quest_antenner_1(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "val_lucas_antenna_1" }) then
		give_info("val_lucas_antenna_1_done")
		play_snd_at_actor([[sound_effects\radio_noise]])
	end
end

function val_lucas_quest_antenner_2(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "val_lucas_antenna_2" }) then
		give_info("val_lucas_antenna_2_done")
		play_snd_at_actor([[sound_effects\radio_noise]])
	end
end

function val_lucas_quest_antenner_3(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "val_lucas_antenna_3" }) then
		give_info("val_lucas_antenna_3_done")
		play_snd_at_actor([[sound_effects\radio_noise]])
	end
end

function mil_create_hole_bomb(actor, npc)
	create("mil_hole_bomb", -61.090858459473, -5.8885412216187, -12.620957374573, 236559, 1366)
end

function mil_b4_place_hole_bomb(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "mil_b4_hole_bomb" }) then
		give_info("mil_smash_monster_hole_bomb_setuped")
		create("remote_charge", db.actor:position().x, db.actor:position().y, db.actor:position().z,
			db.actor:level_vertex_id(), db.actor:game_vertex_id())
		check_actor_item_to_add("mil_hole_bomb_control")
	end
end

function mil_b6_wave_counter_inc(actor, npc)
	if sgm_g.dont_has_alife_info("mil_defence_b6_complete") and sgm_g.dont_has_alife_info("mil_alt_storyline_commenced") then
		if read_mod_param("mil_b6_wave_counter") == nil then
			write_mod_param("mil_b6_wave_counter", 1)
		else
			sgm_g.inc_mod_param("mil_b6_wave_counter")
		end
	end
end

function mil_b6_wave_counter_dec(actor, npc)
	if sgm_g.dont_has_alife_info("mil_defence_b6_complete") and sgm_g.dont_has_alife_info("mil_alt_storyline_commenced") then
		if read_mod_param("mil_b6_wave_counter") ~= nil and read_mod_param("mil_b6_wave_counter") > 0 then
			dec_mod_param("mil_b6_wave_counter")
		end
	end
end

function mil_b7_wave_counter_inc(actor, npc)
	if sgm_g.dont_has_alife_info("mil_defence_b7_complete") and sgm_g.dont_has_alife_info("mil_alt_storyline_commenced") then
		if read_mod_param("mil_b7_wave_counter") == nil then
			write_mod_param("mil_b7_wave_counter", 1)
		else
			sgm_g.inc_mod_param("mil_b7_wave_counter")
		end
	end
end

function mil_b7_wave_counter_dec(actor, npc)
	if sgm_g.dont_has_alife_info("mil_defence_b7_complete") and sgm_g.dont_has_alife_info("mil_alt_storyline_commenced") then
		if read_mod_param("mil_b7_wave_counter") ~= nil and read_mod_param("mil_b7_wave_counter") > 0 then
			dec_mod_param("mil_b7_wave_counter")
		end
	end
end

function mil_defence_b1_done(actor, npc)
	news_manager.send_tip(db.actor, "mil_defence_b1_done_text", 0, "portrait_Nebo_Exo", 8000, nil,
		"mil_b7_base_leader_title")
end

function mil_defence_b1_fail(actor, npc)
	news_manager.send_tip(db.actor, "mil_defence_b1_fail_text", 0, "portrait_Nebo_Exo", 8000, nil,
		"mil_b7_base_leader_title")
end

function mil_defence_b2_done(actor, npc)
	news_manager.send_tip(db.actor, "mil_defence_b2_done_text", 0, "portrait_Nebo_Exo", 8000, nil,
		"mil_b7_base_leader_title")
end

function mil_defence_b2_fail(actor, npc)
	news_manager.send_tip(db.actor, "mil_defence_b2_fail_text", 0, "portrait_Nebo_Exo", 8000, nil,
		"mil_b7_base_leader_title")
end

function mil_defence_b3_done(actor, npc)
	news_manager.send_tip(db.actor, "mil_defence_b3_done_text", 0, "portrait_Nebo_Exo", 8000, nil,
		"mil_b7_base_leader_title")
end

function mil_defence_b3_fail(actor, npc)
	news_manager.send_tip(db.actor, "mil_defence_b3_fail_text", 0, "portrait_Nebo_Exo", 8000, nil,
		"mil_b7_base_leader_title")
end

function mil_defence_b4_done(actor, npc)
	news_manager.send_tip(db.actor, "mil_defence_b4_done_text", 0, "portrait_Nebo_Exo", 8000, nil,
		"mil_b7_base_leader_title")
end

function mil_defence_b4_fail(actor, npc)
	news_manager.send_tip(db.actor, "mil_defence_b4_fail_text", 0, "portrait_Nebo_Exo", 8000, nil,
		"mil_b7_base_leader_title")
end

function mil_defence_b5_done(actor, npc)
	news_manager.send_tip(db.actor, "mil_defence_b5_done_text", 0, "portrait_Nebo_Exo", 8000, nil,
		"mil_b7_base_leader_title")
end

function mil_defence_b5_fail(actor, npc)
	news_manager.send_tip(db.actor, "mil_defence_b5_fail_text", 0, "portrait_Nebo_Exo", 8000, nil,
		"mil_b7_base_leader_title")
end

function mil_defence_b6_complete(actor, npc)
	news_manager.send_tip(db.actor, "mil_defence_b6_complete_text", 0, "portrait_Nebo_Exo", 14000, nil,
		"mil_b7_base_leader_title")
end

function mil_smash_monster_hole_done(actor, npc)
	news_manager.send_tip(db.actor, "mil_smash_monster_hole_done_text", 0, "portrait_Nebo_Exo", 12000, nil,
		"mil_b7_base_leader_title")
	game_autosave_assign("save_mil_smash_monster_hole_done")
end

function esc_b2_create_bomb(actor, npc)
	create("esc_b2_bomb", -185.15017700195, -21.729053497314, -131.43598937988, 64305, 1865)
end

function esc_b2_place_bomb(actor, npc)
	if xr_conditions.actor_in_zone(actor, npc, { "esc_b2_bomb_place" }) then
		give_info("esc_village_annex_placed_c4")
		create("remote_charge", db.actor:position().x, db.actor:position().y, db.actor:position().z,
			db.actor:level_vertex_id(), db.actor:game_vertex_id())
		check_actor_item_to_add("esc_b2_bomb_control")
	end
end

function esc_a2_monster_squad_death(actor, npc)
	create_force("esc_a1_monster_squad", "esc_monster_burrow_1")
end

function esc_a1_monster_squad_death(actor, npc)
	create_force("esc_a3_monster_squad", "esc_monster_burrow_3")
end

function esc_a3_monster_squad_death(actor, npc)
	create_force("esc_a5_monster_squad", "esc_monster_burrow_5")
end

function esc_blockpost_protection_bonus_inc(actor, npc)
	if sgm_g.dont_has_alife_info("esc_blockpost_protection_done") then
		if read_mod_param("esc_blockpost_protection_bonus") == nil then
			write_mod_param("esc_blockpost_protection_bonus", 1)
		else
			sgm_g.inc_mod_param("esc_blockpost_protection_bonus")
		end
	end
end

function mar_create_army_wounded(actor, npc)
	create("mar_army_wounded", -250.73123168945, 0.33261534571648, -117.54051208496, 18393, 1763)
end

function mar_destroy_mines(actor, npc)
	release_objects_by_section("sgm_mar_mine_field")
end

function red_forester_door_charge(actor, npc)
	activate_detonate_charge(npc, 10000, "invisible_big", 27.683589935303, 4.0145859718323, 24.82555770874, 80864, 2186)
end

------------------------------------------------------------------------------
--                        Работа с заселением пустырей                      --
------------------------------------------------------------------------------
function zat_respawn1_killers_counter(actor, npc)
	give_info(npc:section() .. "_death")
	if has_several_info("zat_respawn1_killer", "_death", 1, 12) and sgm_g.dont_has_alife_info("zat_respawn1_all_deaths") then
		give_info("zat_respawn1_all_deaths")
	end
end

function zat_respawn2_killers_counter(actor, npc)
	give_info(npc:section() .. "_death")
	if has_several_info("zat_respawn2_killer", "_death", 1, 11) and sgm_g.dont_has_alife_info("zat_respawn2_all_deaths") then
		give_info("zat_respawn2_all_deaths")
	end
end

function zat_respawn3_randoms_counter(actor, npc)
	if has_several_info("zat_respawn3_random", "_death", 1, 17) and sgm_g.dont_has_alife_info("zat_respawn3_all_deaths") then
		give_info("zat_respawn3_all_deaths")
	end
end

function zat_respawn3_release_counter(actor, npc)
	disable_several_info("zat_respawn3_random", "_death", 1, 17)
end

function zat_respawn4_killers_counter(actor, npc)
	give_info(npc:section() .. "_death")
	if has_several_info("zat_respawn4_killer", "_death", 1, 14) and sgm_g.dont_has_alife_info("zat_respawn4_all_deaths") then
		give_info("zat_respawn4_all_deaths")
	end
end

function zat_respawn5_randoms_counter(actor, npc)
	if has_several_info("zat_respawn5_random", "_death", 1, 8) and sgm_g.dont_has_alife_info("zat_respawn5_all_deaths") then
		give_info("zat_respawn5_all_deaths")
	end
end

function zat_respawn5_release_counter(actor, npc)
	disable_several_info("zat_respawn5_random", "_death", 1, 8)
end

function zat_respawn6_randoms_counter(actor, npc)
	if has_several_info("zat_respawn6_random", "_death", 1, 10) and sgm_g.dont_has_alife_info("zat_respawn6_all_deaths") then
		give_info("zat_respawn6_all_deaths")
	end
end

function zat_respawn6_release_counter(actor, npc)
	disable_several_info("zat_respawn6_random", "_death", 1, 10)
end

function zat_respawn7_randoms_counter(actor, npc)
	if has_several_info("zat_respawn7_random", "_death", 1, 8) and sgm_g.dont_has_alife_info("zat_respawn7_all_deaths") then
		give_info("zat_respawn7_all_deaths")
	end
end

function zat_respawn7_release_counter(actor, npc)
	disable_several_info("zat_respawn7_random", "_death", 1, 8)
end

function jup_respawn1_randoms_counter(actor, npc)
	if has_several_info("jup_respawn1_random", "_death", 1, 20) and sgm_g.dont_has_alife_info("jup_respawn1_all_deaths") then
		give_info("jup_respawn1_all_deaths")
	end
end

function jup_respawn1_release_counter(actor, npc)
	disable_several_info("jup_respawn1_random", "_death", 1, 20)
end

function jup_respawn2_randoms_counter(actor, npc)
	if has_several_info("jup_respawn2_random", "_death", 1, 29) and sgm_g.dont_has_alife_info("jup_respawn2_all_deaths") then
		give_info("jup_respawn2_all_deaths")
	end
end

function jup_respawn2_release_counter(actor, npc)
	disable_several_info("jup_respawn2_random", "_death", 1, 29)
end

function jup_respawn3_randoms_counter(actor, npc)
	if has_several_info("jup_respawn3_random", "_death", 1, 6) and sgm_g.dont_has_alife_info("jup_respawn3_all_deaths") then
		give_info("jup_respawn3_all_deaths")
	end
end

function jup_respawn3_release_counter(actor, npc)
	disable_several_info("jup_respawn3_random", "_death", 1, 6)
end

function jup_respawn4_randoms_counter(actor, npc)
	if has_several_info("jup_respawn4_random", "_death", 1, 15) and sgm_g.dont_has_alife_info("jup_respawn4_all_deaths") then
		give_info("jup_respawn4_all_deaths")
	end
end

function jup_respawn4_release_counter(actor, npc)
	disable_several_info("jup_respawn4_random", "_death", 1, 15)
end

------------------------------------------------------------------------------
--                          Шаблонные функции                               --
------------------------------------------------------------------------------
function set_spot_on_self(actor, npc, p)
	if p[1] == nil or p[2] == nil then return end
	add_spot_on_map(npc:id(), tostring(p[1]), tostring(p[2]))
end

function delete_spot_on_self(actor, npc, p)
	if p[1] == nil then return end
	sgm_g.remove_spot_on_map(npc:id(), tostring(p[1]))
end

function sleep_place_spot_control(actor, npc, p)
	local location_name, descr, need_1_info, dont_2_info = p[1], p[2], p[3], p[4]
	if npc ~= nil then
		if level.map_has_object_spot(npc:id(), location_name) == 0 and distance_between_safe(db.actor, npc) <= 100 and has_alife_info(need_1_info) and sgm_g.dont_has_alife_info(dont_2_info) then
			level.map_add_object_spot_ser(npc:id(), location_name, descr)
		end
		if level.map_has_object_spot(npc:id(), location_name) ~= 0 and (has_alife_info(dont_2_info) or distance_between_safe(db.actor, npc) > 100) then
			level.map_remove_object_spot(npc:id(), location_name)
		end
	end
end

function set_community_to_community_relation(actor, npc, p)
	local from_faction, to_faction, type_relation, double_effect = p[1], p[2], p[3], p[4]
	set_faction_to_faction_relation(from_faction, to_faction, type_relation, double_effect)
end

function set_npc_to_actor_relation(actor, npc, p)
	local type = p[1]
	if type == "enemy" then
		npc:set_relation(game_object.enemy, db.actor)
		npc:force_set_goodwill(-5000, db.actor)
	elseif type == "friend" then
		npc:set_relation(game_object.friend, db.actor)
	elseif type == "neutral" then
		npc:set_relation(game_object.neutral, db.actor)
	end
end

function play_s2d_sound(actor, npc, p)
	local sound = p[1]
	local count1 = p[2]
	local count2 = p[3]
	if count1 == nil and count2 == nil then
		snd_sourse = sound_object(sound)
		snd_sourse:play(db.actor, 0, sound_object.s2d)
	elseif count1 ~= nil and count2 ~= nil then
		local rnd_snd = math.random(count1, count2)
		snd_sourse = sound_object(sound .. rnd_snd)
		snd_sourse:play(db.actor, 0, sound_object.s2d)
	end
end

function play_s3d_sound(actor, npc, p)
	local sound = p[1]
	local count1 = p[2]
	local count2 = p[3]
	if count1 == nil and count2 == nil then
		snd_sourse = sound_object(sound)
		snd_sourse:play_at_pos(npc, npc:position(), 0, sound_object.s3d)
	elseif count1 ~= nil and count2 ~= nil then
		local rnd_snd = math.random(count1, count2)
		snd_sourse = sound_object(sound .. rnd_snd)
		snd_sourse:play_at_pos(npc, npc:position(), 0, sound_object.s3d)
		snd_sourse.volume = 1.00
	end
end

function play_looped_s2d_sound(actor, npc, p)
	local sound = p[1]
	local count1 = p[2]
	local count2 = p[3]
	if count1 == nil and count2 == nil then
		snd_sourse = sound_object(sound)
		snd_sourse:play(db.actor, 0, sound_object.s2d + sound_object.looped)
	elseif count1 ~= nil and count2 ~= nil then
		local rnd_snd = math.random(count1, count2)
		snd_sourse = sound_object(sound .. rnd_snd)
		snd_sourse:play(db.actor, 0, sound_object.s2d + sound_object.looped)
	end
end

function play_looped_s3d_sound(actor, npc, p)
	local sound = p[1]
	local count1 = p[2]
	local count2 = p[3]
	local snd_souce
	if count1 == nil or count2 == nil then
		snd_souce = sound_object(sound)
		if snd_souce:playing() == false then
			snd_souce:play_at_pos(npc, npc:position(), 0, sound_object.s3d + sound_object.looped)
		end
	elseif count1 ~= nil and count2 ~= nil then
		snd_souce = sound_object(sound .. math.random(count1, count2))
		if snd_souce:playing() == false then
			snd_souce:play_at_pos(npc, npc:position(), 0, sound_object.s3d + sound_object.looped)
		end
	end
end

function play_sound_theme(actor, obj, p)
	local theme = p[1]
	local unneed_info = p[2]
	local faction = p[3]
	local point = sim_board.get_sim_board().smarts_by_names[p[4]]
	if point ~= nil then
		point = point.id
	elseif p[4] ~= nil then
		point = p[3]
	end
	if obj and IsStalker(obj) then
		if not obj:alive() then
			abort("Stalker [%s][%s] is dead, but you wants to say something for you: [%s]!", tostring(obj:id()),
				tostring(obj:name()), p[1])
		end
	end
	if sgm_g.exists(unneed_info) and sgm_g.dont_has_alife_info(unneed_info) then
		xr_sound.set_sound_play(obj:id(), theme, faction, point)
	elseif sgm_g.exists(unneed_info) and has_alife_info(unneed_info) then
		return
	else
		xr_sound.set_sound_play(obj:id(), theme, faction, point)
	end
end

function add_sid(actor, npc, p)
	local story_name = p[1]
	add_story_object(npc:id(), story_name)
end

function release_sid(actor, npc, p)
	local target = p[1]
	unregister_story_id(p[1])
end

function teleport_npc_to_level_vertex(actor, npc, p)
	local lv_pos = p[1]
	if lv_pos ~= nil then
		local param1 = level.vertex_position(tonumber(lv_pos)).x
		local param2 = level.vertex_position(tonumber(lv_pos)).y
		local param3 = level.vertex_position(tonumber(lv_pos)).z
		npc:set_npc_position(vector():set(param1, param2, param3))
	end
end

function edit_counter(actor, npc, p)
	local counter_name = p[1]
	local to_value = p[2]
	local action = p[3]
	if read_mod_param(counter_name) ~= nil then
		if (action == true or action == "true" or action == "+" or action == "plus" or action == nil) then
			local counter = read_mod_param(counter_name)
			write_mod_param(counter_name, counter + to_value)
		elseif (action == false or action == "false" or action == "-" or action == "minus") then
			local counter = read_mod_param(counter_name)
			write_mod_param(counter_name, counter - to_value)
		end
	end
end

function increase_counter(actor, npc, p)
	local counter_name = p[1]
	local add_value = p[2]
	if read_mod_param(counter_name) == nil then write_mod_param(counter_name, 0) end
	if add_value == nil then add_value = 1 end
	if read_mod_param(counter_name) ~= nil then
		local counter = read_mod_param(counter_name)
		write_mod_param(counter_name, counter + add_value)
	end
end

function decrease_counter(actor, npc, p)
	local counter_name = p[1]
	local add_value = p[2]
	if read_mod_param(counter_name) == nil then write_mod_param(counter_name, 0) end
	if add_value == nil then add_value = 1 end
	if read_mod_param(counter_name) ~= nil then
		local counter = read_mod_param(counter_name)
		write_mod_param(counter_name, counter - add_value)
	end
end

function release_counter(actor, npc, p)
	local counter_1_name = p[1]
	local counter_2_name = p[2]
	local counter_3_name = p[3]
	local counter_4_name = p[4]
	local counter_5_name = p[5]
	if read_mod_param(counter_1_name) ~= nil then clear_mod_param(counter_1_name) end
	if read_mod_param(counter_2_name) ~= nil then clear_mod_param(counter_2_name) end
	if read_mod_param(counter_3_name) ~= nil then clear_mod_param(counter_3_name) end
	if read_mod_param(counter_4_name) ~= nil then clear_mod_param(counter_4_name) end
	if read_mod_param(counter_5_name) ~= nil then clear_mod_param(counter_5_name) end
end

function delete_counter(actor, npc, p)
	local counter_1_name = p[1]
	local counter_2_name = p[2]
	local counter_3_name = p[3]
	local counter_4_name = p[4]
	local counter_5_name = p[5]
	if sgm_functions.read_variable(counter_1_name) ~= nil then sgm_functions.clear_variable(counter_1_name) end
	if sgm_functions.read_variable(counter_2_name) ~= nil then sgm_functions.clear_variable(counter_2_name) end
	if sgm_functions.read_variable(counter_3_name) ~= nil then sgm_functions.clear_variable(counter_3_name) end
	if sgm_functions.read_variable(counter_4_name) ~= nil then sgm_functions.clear_variable(counter_4_name) end
	if sgm_functions.read_variable(counter_5_name) ~= nil then sgm_functions.clear_variable(counter_5_name) end
end

function setup_anim_to_actor(actor, npc, p)
	local need_state = p[1]
	local to_body = p[2]
	if state_mgr.get_state(npc) ~= need_state then
		if to_body == "true" then
			state_mgr.set_state(npc, need_state, nil, nil, { look_object = db.actor }, { fast_set = true })
		else
			state_mgr.set_state(npc, need_state, nil, nil,
				{ look_position = level.vertex_position(db.actor:level_vertex_id()) }, { fast_set = true })
		end
	end
end

function activate_no_weapon_zone(actor, npc, p)
	if p then
		setup_no_weapon_zone(p[1], "n_w_" .. npc:id(), p[2], npc)
	end
end

function activate_no_weapon_zone_disabled(actor, npc, p)
	if p then
		setup_no_weapon_zone_disabled(p[1], "n_w_d_" .. npc:id(), p[2], p[3], npc)
	end
end

function activate_inactivity_aura(actor, npc, p)
	if p then
		setup_inactivity_aura(p[1], "i_aura_" .. npc:id(), p[2], p[3], npc)
	end
end

function autosave_game(actor, npc, p)
	local save_name = p[1]
	game_autosave_assign(save_name)
end

function create_game_timer(actor, npc, p)
	if check_game_timer(p[1]) == nil then
		start_game_timer(p[1], p[2], p[3])
	end
end

function deliver_skill_book(actor, npc, p)
	if p ~= nil and p ~= "nil" then
		if sgm_g.exists(p[1]) then
			sgm_g.give_skill_book(p[1])
		end
		if sgm_g.exists(p[2]) then
			sgm_g.give_skill_book(nil, p[2])
		end
	else
		sgm_g.give_skill_book()
	end
end

function setup_detonate_charge(actor, npc, p)
	activate_detonate_charge(npc, p[1], true, p[2], p[3], p[4], p[5], p[6])
end

function add_actor_rank(actor, npc, p)
	local rank_bonus = p[1]
	if read_mod_param("actor_rank") ~= nil and rank_bonus ~= nil then
		write_mod_param("actor_rank", read_mod_param("actor_rank") + (rank_bonus * sgm_ranks.game_multiplier()))
		congratulate_with_rank_event("add", 8500, rank_bonus * sgm_ranks.game_multiplier())
	elseif read_mod_param("actor_rank") ~= nil and rank_bonus == nil then
		write_mod_param("actor_rank", read_mod_param("actor_rank") + 1)
		congratulate_with_rank_event("add", 8500, 1)
	end
end

function give_money_to_actor(actor, npc, p)
	if p[2] == true then
		db.actor:give_money(tonumber(p[1]))
		game_stats.money_quest_update(tonumber(p[1]))
	else
		dialogs.relocate_money(db.actor, p[1], "in")
	end
end

function give_money_from_actor(actor, npc, p)
	if p[2] == true then
		db.actor:give_money(-tonumber(p[1]))
		game_stats.money_quest_update(-tonumber(p[1]))
	else
		if p[3] == true then
			dialogs.relocate_money(db.actor, p[1], "out2")
		else
			dialogs.relocate_money(db.actor, p[1], "out")
		end
	end
end

function has_much_info(actor, npc, p)
	local l_part = p[1]
	local r_part = p[2]
	local count_a = p[3]
	local count_b = p[4]
	if count_b == nil then
		count_b = count_a
		count_a = 1
	end
	local info_cnt = 0
	for i = count_a, count_b do
		if has_alife_info(l_part .. i .. r_part) then
			info_cnt = info_cnt + 1
		end
	end
	return info_cnt >= count_b
end

------------------------------------------------------------------------------
--                              Разное                                      --
------------------------------------------------------------------------------
function chicken_rabua_activate_1(actor, npc)
	local x, y, z, lv, gv = npc:position().x, npc:position().y, npc:position().z, npc:level_vertex_id(),
		npc:game_vertex_id()
	remove_object_by_id(npc:id())
	create("chicken_rabua", x, y, z, lv, gv)
	create("chicken_rabua_egg", x, y + 0.5, z, lv, gv)
end

function chicken_rabua_activate_2(actor, npc)
	local x, y, z, lv, gv = npc:position().x, npc:position().y, npc:position().z, npc:level_vertex_id(),
		npc:game_vertex_id()
	remove_object_by_id(npc:id())
	create("chicken_rabua", x, y, z, lv, gv)
end

function employer_quest_complete(actor, npc)
	write_mod_param("employer_activate", "false")
	clear_mod_param("employer_currert_quest")
	clear_mod_param("employer_currert_target")
	clear_mod_param("employer_currert_distance")
	clear_mod_param("employer_currert_type")
	disable_info("employer_find_item_reward")
	disable_info("employer_find_item_complete")
	disable_info("employer_kill_stalker_reward")
	disable_info("employer_kill_stalker_complete")
end

function monster_captured(actor, npc)
	if not xr_logic.mob_captured(npc) then
		xr_logic.mob_capture(npc, true)
	end
end

function captured_monster_hitted(actor, npc)
	local c_m_h_rnd = math.random(1, 10)
	if c_m_h_rnd == 1 then
		sgm_flags.table_m_capture_hits[npc:id()] = true
	end
end

function release_npc(actor, npc)
	if npc ~= nil then
		if npc ~= nil and get_story_object(npc:profile_name()) ~= nil then
			unregister_story_id(npc:profile_name())
		end
		if alife():object(npc:id()) then
			sgm_g.clear_mod_params_for_npc(npc:id())
			alife():release(alife():object(npc:id()), true)
		end
	end
end

function release_object(actor, npc)
	if npc ~= nil then
		if alife():object(npc:id()) then
			alife():release(alife():object(npc:id()), true)
		end
	end
end

function sleep_zone_activate(actor, npc)
	ui_sleep_dialog.sleep()
	give_info("sleep_active")
end

function remove_mod_spots(actor, npc)
	sgm_g.remove_spot_on_map(npc:id(), sgm_flags.spot_actor_guard)
	sgm_g.remove_spot_on_map(npc:id(), sgm_flags.spot_cash_keeper)
	sgm_g.remove_spot_on_map(npc:id(), sgm_flags.spot_unique_trader)
	sgm_g.remove_spot_on_map(npc:id(), sgm_flags.spot_artefact_chemist)
	sgm_g.remove_spot_on_map(npc:id(), sgm_flags.spot_quest_person)
	sgm_g.remove_spot_on_map(npc:id(), sgm_flags.spot_job_person)
	sgm_g.remove_spot_on_map(npc:id(), sgm_flags.spot_base_commander)
	sgm_g.remove_spot_on_map(npc:id(), sgm_flags.spot_info_dealer)
	sgm_g.remove_spot_on_map(npc:id(), sgm_flags.spot_employer)
	sgm_g.remove_spot_on_map(npc:id(), sgm_flags.spot_quest_tip)
	sgm_g.remove_spot_on_map(npc:id(), sgm_flags.spot_quest_enemy_squad_1)
	sgm_g.remove_spot_on_map(npc:id(), sgm_flags.spot_quest_enemy_squad_2)
end
