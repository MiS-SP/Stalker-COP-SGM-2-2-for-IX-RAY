-- Called manually in global script
function start_game_callback_sgm_patching(squad_community_by_behaviour, monster_classes)
   squad_community_by_behaviour["night_stalker"] = "night_stalker"
   squad_community_by_behaviour["renegade"] = "renegade"
   squad_community_by_behaviour["alfa_force"] = "alfa_force"
   squad_community_by_behaviour["mercenary"] = "mercenary"
   squad_community_by_behaviour["bandit_enemy"] = "bandit_enemy"
   squad_community_by_behaviour["killer_enemy"] = "killer_enemy"

   monster_classes[clsid.cat_s] = true
   monster_classes[clsid.fracture_s] = true
   monster_classes[clsid.zombie_s] = true
end

--=============================================================--
--=======================/SGM/=================================--
--=============================================================--
local pistol_state_bar = nil
local rifle_state_bar = nil
local boss_health_bar = nil
local radiation_bar = nil
local capture_monster_bar = nil
local battery_power_bar = nil
------------------------------------------------------------------------------
--                              Работа со спауном                           --
------------------------------------------------------------------------------
-- 'Создание обьекта.
function create(who, x, y, z, lv, gv, spot_name, spot_descr)
   local who_table = parse_general_names(who)
   if z == nil and lv == nil and gv == nil then
      obj = alife():create(get_random_string(who_table), level.vertex_position(x), x, y)
   else
      obj = alife():create(get_random_string(who_table), vector():set(x, y, z), lv, gv)
   end
   if obj then
      sgm_modules.submodule_on_create(who, obj.id)
      if exists(spot_name) and exists(spot_descr) then
         add_spot_on_map(obj.id, spot_name, spot_descr)
      end
   end
   return obj
end

-- 'Создание нескольких объектов.
function create_objects(who_list, x, y, z, lv, gv, spot_name, spot_descr)
   local parse_who_list = utils.parse_spawns(who_list)
   for k, v in pairs(parse_who_list) do
      for i = 1, v.prob do
         obj = alife():create(v.section, vector():set(x, y, z), lv, gv)
         if exists(spot_name) and exists(spot_descr) then
            add_spot_on_map(obj.id, spot_name, spot_descr)
         end
      end
   end
end

-- 'Создание обьекта с рандомной позицией.
function create_random(who, count_pos, pos_1, pos_2, pos_3, pos_4, pos_5, pos_6, pos_7, pos_8, pos_9, pos_10)
   local who_table = parse_general_names(who)
   local selected_pos = get_rnd(1, count_pos)
   local pos_value = pos_1
   if selected_pos == 1 then
      pos_value = pos_1
   elseif selected_pos == 2 then
      pos_value = pos_2
   elseif selected_pos == 3 then
      pos_value = pos_3
   elseif selected_pos == 4 then
      pos_value = pos_4
   elseif selected_pos == 5 then
      pos_value = pos_5
   elseif selected_pos == 6 then
      pos_value = pos_6
   elseif selected_pos == 7 then
      pos_value = pos_7
   elseif selected_pos == 8 then
      pos_value = pos_8
   elseif selected_pos == 9 then
      pos_value = pos_9
   elseif selected_pos == 10 then
      pos_value = pos_10
   end
   local get_coord = parse_comma_names(pos_value, count_pos, true)
   obj = alife():create(get_random_string(who_table),
      vector():set(tonumber(get_coord[1]), tonumber(get_coord[2]), tonumber(get_coord[3])), tonumber(get_coord[4]),
      tonumber(get_coord[5]))
   if obj then
      sgm_modules.submodule_on_create(who, obj.id)
   end
   return obj
end

-- 'Создание нескольких объектов с рандомной позицией.
function create_objects_random(who_list, count_pos, pos_1, pos_2, pos_3, pos_4, pos_5, pos_6, pos_7, pos_8, pos_9, pos_10)
   local parse_who_list = utils.parse_spawns(who_list)
   local selected_pos = get_rnd(1, count_pos)
   local pos_value = pos_1
   if selected_pos == 1 then
      pos_value = pos_1
   elseif selected_pos == 2 then
      pos_value = pos_2
   elseif selected_pos == 3 then
      pos_value = pos_3
   elseif selected_pos == 4 then
      pos_value = pos_4
   elseif selected_pos == 5 then
      pos_value = pos_5
   elseif selected_pos == 6 then
      pos_value = pos_6
   elseif selected_pos == 7 then
      pos_value = pos_7
   elseif selected_pos == 8 then
      pos_value = pos_8
   elseif selected_pos == 9 then
      pos_value = pos_9
   elseif selected_pos == 10 then
      pos_value = pos_10
   end
   local get_coord = parse_comma_names(pos_value, count_pos, true)
   for k, v in pairs(parse_who_list) do
      for i = 1, v.prob do
         obj = alife():create(v.section,
            vector():set(tonumber(get_coord[1]), tonumber(get_coord[2]), tonumber(get_coord[3])), tonumber(get_coord[4]),
            tonumber(get_coord[5]))
      end
   end
   if obj then
      sgm_modules.submodule_on_create(who, obj.id)
   end
   return obj
end

-- 'Создание контейнера со случайными боеприпасами.
local ammo_container_config = {
   var_1 = "ammo_9x18_pmm, 3",
   var_2 = "ammo_9x19_pbp, 3",
   var_3 = "ammo_11.43x23_hydro, 5",
   var_4 = "ammo_12x70_buck, 2, ammo_12x76_zhekan, 2",
   var_5 = "ammo_5.45x39_fmj, 2, ammo_5.45x39_ap",
   var_6 = "ammo_9x39_ap, 3",
   var_7 = "ammo_5.56x45_ss190, 2, ammo_5.56x45_ap",
   var_8 = "ammo_7.62x54_7h1, 2",
   var_9 = "grenade_f1, 2, grenade_rgd5, 2, grenade_gd-05, grenade_gd-05_lighting"
}
function give_ammo_with_container(news)
   local var_selected = math.random(1, 9)
   local var_source = "var_" .. var_selected
   if ammo_container_config[var_source] ~= nil then
      local get_contain = ammo_container_config[var_source]
      if news ~= nil and news == true then
         give_objects_to_actor(get_contain, true)
      else
         give_objects_to_actor(get_contain, false)
      end
   end
end

-- 'Создание отряда(сквада).
function create_force(squad_sect, x, y, z, lv, gv)
   local squads_list = utils.parse_spawns(squad_sect)
   for k, v in pairs(squads_list) do
      for i = 1, v.prob do
         if y ~= nil then
            local board = sim_board.get_sim_board()
            local squad = board:create_force(v.section, x, y, z, lv, gv)
            for k in squad:squad_members() do
               board:setup_squad_and_group(k.object)
            end
            squad:update()
         else
            local board = sim_board.get_sim_board()
            local smart = board.smarts_by_names[x]
            local squad = board:create_squad(smart, v.section)
            board:enter_smart(squad, smart.id)
            for k in squad:squad_members() do
               board:setup_squad_and_group(k.object)
            end
            squad:update()
         end
      end
   end
end

-- 'Создание предмета в рюкзаке ГГ.
function give_object_to_actor(section, count, news)
   if count == nil then count = 1 end
   for i = 1, count do
      alife():create(section, db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), db.actor:id())
   end
   if news == true then
      news_manager.relocate_item(db.actor, "in", section, count)
   end
end

-- 'Создание предметов в рюкзаке ГГ.
function give_objects_to_actor(items_list, news)
   local parse_items_list = utils.parse_spawns(items_list)
   for k, v in pairs(parse_items_list) do
      for i = 1, v.prob do
         alife():create(v.section, db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(),
            db.actor:id())
         if news == true then news_manager.relocate_item(db.actor, "in", v.section) end
      end
   end
end

-- 'Создание предмета в рюкзаке НПС.
function give_object_to_npc(section, npc, count)
   if count == nil then count = 1 end
   for i = 1, count do
      alife():create(section, npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id())
   end
end

-- 'Создание предметов в рюкзаке НПС.
function give_objects_to_npc(items_list, npc)
   local parse_items_list = utils.parse_spawns(items_list)
   for k, v in pairs(parse_items_list) do
      for i = 1, v.prob do
         alife():create(v.section, npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id())
      end
   end
end

-- 'Создание предметов для обьекта с выбранным ID.
function give_object_to_object(items, obj_id)
   local parse_items = utils.parse_spawns(items)
   for k, v in pairs(parse_items) do
      for i = 1, v.prob do
         alife():create(v.section, vector(), 0, 0, obj_id)
      end
   end
end

-- 'Создание предметов, для обьекта с выбранным SID.
function give_item_to_sid(items, sid)
   local parse_items = utils.parse_spawns(items)
   if get_story_object_id(sid) ~= nil then
      for k, v in pairs(parse_items) do
         for i = 1, v.prob do
            alife():create(v.section, vector(), 0, 0, get_story_object_id(sid))
         end
      end
   end
end

-- 'Создание предмета в рюкзаке ГГ. Наградная функция.
function give_reward(items, count)
   local items_table = parse_general_names(items)
   local choose_item = get_random_string(items_table)
   if count == nil then count = 1 end
   for i = 1, count do
      alife():create(choose_item, db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(),
         db.actor:id())
   end
   news_manager.relocate_item(db.actor, "in", choose_item, count)
end

-- 'Создание инвентарного обьекта, с заполнением.
function create_inventory_item(items_tbl, model, x, y, z, lv, gv, extra_fill)
   local secret_case = db.actor
   local set_model
   if model == 1 then
      set_model = "secret_rukzak"
   elseif model == 2 then
      set_model = "secret_instrument"
   elseif model == 3 then
      set_model = "secret_dinamit"
   else
      set_model = model
   end
   if z == nil and lv == nil and gv == nil then
      secret_case = alife():create(set_model, level.vertex_position(x), x, y)
   else
      secret_case = alife():create(set_model, vector():set(x, y, z), lv, gv)
   end
   if exists(items_tbl) then
      local parse_first_table = utils.parse_spawns(items_tbl)
      for k, v in pairs(parse_first_table) do
         for i = 1, v.prob do
            alife():create(v.section, vector(), 0, 0, secret_case.id)
         end
      end
   end
   if extra_fill ~= nil and extra_fill == true then
      sgm_place.flip_secret_items(secret_case.id)
   end
   return secret_case.id
end

-- 'Создание мертвого НПС, с выбранными вещами.
function create_dead_body(dead_name, item_table, x, y, z, lv, gv)
   if z == nil and lv == nil and gv == nil then
      body_case = alife():create(dead_name, level.vertex_position(x), x, y)
   else
      body_case = alife():create(dead_name, vector():set(x, y, z), lv, gv)
   end
   if exists(item_table) then
      local parse_table = utils.parse_spawns(item_table)
      for k, v in pairs(parse_table) do
         for i = 1, v.prob do
            alife():create(v.section, vector(), 0, 0, body_case.id)
         end
      end
   end
end

function create_suicide_body(suicide_name, item_table, x, y, z, lv, gv)
   if z == nil and lv == nil and gv == nil then
      body_case = alife():create(suicide_name, level.vertex_position(x), x, y)
   else
      body_case = alife():create(suicide_name, vector():set(x, y, z), lv, gv)
   end
   if exists(item_table) then
      local parse_table = utils.parse_spawns(item_table)
      for k, v in pairs(parse_table) do
         for i = 1, v.prob do
            alife():create(v.section, vector(), 0, 0, body_case.id)
         end
      end
   end
end

-- 'Создание инвентаря с ценным хабаром. Сокровища группировки.
function create_base_treasure(model, x, y, z, lv, gv)
   local param_sid = sgm_functions.ReadStoryId(model)
   local param_ts = sgm_functions.ReadBaseTreasureSpot(model)
   local param_sc = sgm_functions.ReadSelfCommunity(model)
   local param_nc = sgm_functions.ReadNeedCommunity(model)
   local param_bi = sgm_functions.ReadBaseItems(model)
   local param_ii = sgm_functions.ReadTakeItemsInfo(model)
   local parse_table = utils.parse_spawns(param_bi)
   if z == nil and lv == nil and gv == nil then
      base_treasure = alife():create(model, level.vertex_position(x), x, y)
   else
      base_treasure = alife():create(model, vector():set(x, y, z), lv, gv)
   end
   add_story_object(base_treasure.id, param_sid)
   if exists(param_ts) then
      add_spot_on_map(base_treasure.id, param_ts,
         game.translate_string("st_base_treasure_name") .. " " .. game.translate_string(param_sc))
   end
   for k, v in pairs(parse_table) do
      for i = 1, v.prob do
         alife():create(v.section, vector(), 0, 0, base_treasure.id)
      end
   end
end

-- 'Создание GPS проводника.
function create_gps_guide(x, y, z, lv, gv)
   local gps_guide = db.actor
   if z == nil and lv == nil and gv == nil then
      gps_guide = alife():create("guidebook_mono", level.vertex_position(x), x, y)
   else
      gps_guide = alife():create("guidebook_mono", vector():set(x, y, z), lv, gv)
   end
   return gps_guide.id
end

-- 'Создание рестриктора.
function create_restrictor(custom_add, radius, x, y, z, lv, gv)
   if z == nil and lv == nil and gv == nil then
      se_obj = alife():create("space_restrictor", level.vertex_position(x), x, y)
   else
      se_obj = alife():create("space_restrictor", vector():set(x, y, z), lv, gv)
   end
   local custom_pack = "[logic]\n" .. "cfg = " .. custom_add
   sgm_packet.setup_restrictor(se_obj, custom_pack, radius, x, y, z, lv, gv)
end

-- 'Создание зоны случайного телепорта.
function create_throw_zone(custom_add, radius, x, y, z, lv, gv)
   sgm_packet.create_anomaly("sgm_throw_field", radius, lv, gv)
   if z == nil and lv == nil and gv == nil then
      se_obj = alife():create("space_restrictor", level.vertex_position(x), x, y)
   else
      se_obj = alife():create("space_restrictor", vector():set(x, y, z), lv, gv)
   end
   local custom_pack = "[logic]\n" .. "cfg = " .. custom_add
   sgm_packet.setup_restrictor(se_obj, custom_pack, radius, x, y, z, lv, gv)
end

-- 'Замена исчезнувшего квестового трупа на рюкзак с нужным предметом.
function replace_quest_corpse(spot_name, quest_item, x, y, z, lv, gv)
   create(spot_name, x, y, z, lv, gv)
   create_inventory_item(quest_item, "default_rukzak", x, y, z, lv, gv)
end

------------------------------------------------------------------------------
--                           Работа с режимами                              --
------------------------------------------------------------------------------
-- 'Использовать режим бессмертия.
function use_immortal_mode(val_first, val_second)
   if db.actor.health < val_first then
      db.actor.health = val_second
   end
end

-- 'Использовать режим восстановления энергии.
function use_power_mode(val_first, val_second)
   if db.actor.power < val_first then
      db.actor.power = val_second
   end
end

-- 'Использовать режим остановки любых кровотечений.
function use_bleeding_mode()
   local blood_level = db.actor.bleeding
   if blood_level > 0.05 then
      if db.actor:object("bandage") then
         db.actor:eat(db.actor:object("bandage"))
      else
         alife():create("bandage", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(),
            db.actor:id())
      end
   end
end

-- 'Использовать режим авто-ремонта.
function use_repair_mode(val_first, val_second)
   local active_slot = db.actor:active_slot()
   local active_item = db.actor:active_item()
   local pistol_in_slot = db.actor:item_in_slot(2)
   local rifle_in_slot = db.actor:item_in_slot(3)
   local outfit_in_slot = db.actor:item_in_slot(7)
   local helm_in_slot = db.actor:item_in_slot(12)
   local actor = db.actor
   local pistol_contain
   local rifle_contain
   local outfit_contain
   local artefact_contain
   local helm_contain
   if outfit_in_slot ~= nil then outfit_contain = outfit_in_slot:section() end
   if pistol_in_slot ~= nil then pistol_contain = pistol_in_slot:section() end
   if rifle_in_slot ~= nil then rifle_contain = rifle_in_slot:section() end
   if helm_in_slot ~= nil then helm_contain = helm_in_slot:section() end
   if outfit_contain ~= nil and outfit_in_slot ~= nil then
      if outfit_in_slot:condition() < val_first then
         outfit_in_slot:set_condition(val_second)
      end
   end
   if helm_contain ~= nil and helm_in_slot ~= nil then
      if helm_in_slot:condition() < val_first then
         helm_in_slot:set_condition(val_second)
      end
   end
   if pistol_contain ~= nil and pistol_in_slot ~= nil then
      if pistol_in_slot:condition() < val_first then
         pistol_in_slot:set_condition(val_second)
      end
   end
   if rifle_contain ~= nil and rifle_in_slot ~= nil then
      if rifle_in_slot:condition() < val_first then
         rifle_in_slot:set_condition(val_second)
      end
   end
end

-- 'Использовать все режимы.
function use_all_modes(val_first, val_second)
   use_immortal_mode(val_first, val_second)
   use_power_mode(val_first, val_second)
   use_repair_mode(val_first, val_second)
   use_bleeding_mode()
end

------------------------------------------------------------------------------
--                         Работа с инфопортациями                          --
------------------------------------------------------------------------------
-- 'Выдача инфопортации, если таковая отсутствует.
function recover_info(dont_info)
   if sgm_g.dont_has_alife_info(dont_info) then
      give_info(dont_info)
   end
end

-- 'Выдача инфопортации, если первая присутствует, а вторая отсутствует.
function recover_info2(has_info, grant_info)
   if has_alife_info(has_info) and sgm_g.dont_has_alife_info(grant_info) then
      give_info(grant_info)
   end
end

-- 'Выдача нескольких инфопортаций по возрастающим номерам.
function give_several_info(l_part, r_part, count_a, count_b)
   if count_b == nil then
      count_b = count_a
      count_a = 1
   end
   for i = count_a, count_b do
      give_info(l_part .. i .. r_part)
   end
end

-- 'Удаление нескольких инфопортаций по возрастающим номерам.
function disable_several_info(l_part, r_part, count_a, count_b)
   if count_b == nil then
      count_b = count_a
      count_a = 1
   end
   for i = count_a, count_b do
      disable_info(l_part .. i .. r_part)
   end
end

-- 'Подсчет нескольких полученных инфопортаций по возрастающим номерам.
function has_several_info(l_part, r_part, count_a, count_b)
   if count_b == nil then
      count_b = count_a
      count_a = 1
   end
   local info_cnt = 0
   for i = count_a, count_b do
      if has_alife_info(l_part .. i .. r_part) then
         info_cnt = info_cnt + 1
      end
   end
   return info_cnt >= count_b
end

-- 'Подсчет нескольких неполученных инфопортаций по возрастающим номерам.
function dont_has_several_info(l_part, r_part, count_a, count_b)
   if count_b == nil then
      count_b = count_a
      count_a = 1
   end
   local info_cnt = 0
   for i = count_a, count_b do
      if sgm_g.dont_has_alife_info(l_part .. i .. r_part) then
         info_cnt = info_cnt + 1
      end
   end
   return info_cnt >= count_b
end

-- 'Подсчет нескольких полученных инфопортаций за один вызов.
function has_chosen_info(info_list)
   if find_out_string(info_list, ",") then
      return has_alife_info(info_list)
   else
      local info_result = 0
      local info_table = utils.parse_spawns(info_list)
      local info_count = get_table_names(info_table)
      for k, v in pairs(info_table) do
         if has_alife_info(v.section) then
            info_result = info_result + 1
         end
      end
      return info_result >= info_count
   end
end

-- 'Подсчет нескольких неполученных инфопортаций за один вызов.
function dont_has_chosen_info(info_list)
   if find_out_string(info_list, ",") then
      return sgm_g.dont_has_alife_info(info_list)
   else
      local info_result = 0
      local info_table = utils.parse_spawns(info_list)
      local info_count = get_table_names(info_table)
      for k, v in pairs(info_table) do
         if sgm_g.dont_has_alife_info(v.section) then
            info_result = info_result + 1
         end
      end
      return info_result >= info_count
   end
end

-- 'Проверка на наличие любой из нескольких инфопортаций.
function has_any_info(info_list)
   if find_out_string(info_list, ",") then
      return has_alife_info(info_list)
   else
      local info_result = false
      local info_table = utils.parse_spawns(info_list)
      local info_count = get_table_names(info_table)
      for k, v in pairs(info_table) do
         if has_alife_info(v.section) then
            info_result = true
         end
      end
      return info_result
   end
end

-- 'Проверка на отсутствие любой из нескольких инфопортаций.
function dont_any_chosen_info(info_list)
   if find_out_string(info_list, ",") then
      return sgm_g.dont_has_alife_info(info_list)
   else
      local info_result = false
      local info_table = utils.parse_spawns(info_list)
      local info_count = get_table_names(info_table)
      for k, v in pairs(info_table) do
         if sgm_g.dont_has_alife_info(v.section) then
            info_result = true
         end
      end
      return info_result
   end
end

-- 'Проверка на отсутствие инфопортации.
function sgm_g.dont_has_alife_info(info_id)
   return not has_alife_info(info_id)
end

------------------------------------------------------------------------------
--                         Функции для парсинга                             --
------------------------------------------------------------------------------
-- 'Парсинг значений разделённых запятыми в таблицу.
function parse_general_names(s)
   local t = {}
   for name in string.gfind(s, "([%w_\\]+)%p*") do
      local w_name = parse_codicil(name)
      if avail_codicil(name) == true then table.insert(t, w_name) end
   end
   return t
end

function parse_accuracy_names(s)
   local t = {}
   for name in string.gfind(s, "([%w_%-.\\]+)%,*") do
      table.insert(t, name)
   end
   return t
end

-- 'Пропуск функции parse_general_names через фильтр, потому как эта функция считывает точку как запятую.
function avail_codicil(name)
   if (find_in_string(name, "ammo_5") or find_in_string(name, "ammo_7") or find_in_string(name, "ammo_11") or find_in_string(name, "ammo_12") or find_in_string(name, "grenade_gd") or find_in_string(name, "ammo_og") or find_in_string(name, "ammo_vog") or (find_in_string(name, "wpn_rg") and find_out_string(name, "rgd"))) and find_out_string(name, "12x7") then
      return false
   end
   return true
end

function parse_codicil(name)
   if find_out_string(name, "silencer") then
      if find_in_string(name, "45x39_") or find_in_string(name, "56x45_") or find_in_string(name, "7x28_") then
         return "ammo_5." .. name
      elseif find_in_string(name, "62x54_") or find_in_string(name, "62x51_") then
         return "ammo_7." .. name
      elseif find_in_string(name, "43x23_") then
         return "ammo_11." .. name
      elseif find_in_string(name, "7x99_") then
         return "ammo_12." .. name
      end
   else
      if find_in_string(name, "45x39") or find_in_string(name, "56x45") then
         return "wpn_addon_silencer_5." .. name
      elseif find_in_string(name, "43x23") then
         return "wpn_addon_silencer_11." .. name
      end
   end
   if find_in_string(name, "7b") then
      return "ammo_og-" .. name
   elseif find_in_string(name, "6") and find_out_string(name, "_") then
      return "wpn_rg-" .. name
   elseif find_in_string(name, "05_lighting") then
      return "grenade_gd-" .. name
   elseif find_in_string(name, "05_double") then
      return "grenade_gd-" .. name
   elseif find_in_string(name, "05") and find_out_string(name, "_") then
      return "grenade_gd-" .. name
   elseif find_in_string(name, "25") and find_out_string(name, "_") then
      return "ammo_vog-" .. name
   end
   return name
end

-- 'Возвращение значений разделённых запятыми.
function parse_comma_names(val, count, imm_cm)
   local cm_names = parse_accuracy_names(val)
   local cm_all = #cm_names
   if imm_cm == true then
      return cm_names
   end
   if cm_all >= count and val ~= nil then
      if count == 1 then
         return cm_names[1]
      elseif count == 2 then
         return cm_names[1], cm_names[2]
      elseif count == 3 then
         return cm_names[1], cm_names[2], cm_names[3]
      elseif count == 4 then
         return cm_names[1], cm_names[2], cm_names[3], cm_names[4]
      elseif count == 5 then
         return cm_names[1], cm_names[2], cm_names[3], cm_names[4], cm_names[5]
      elseif count == 6 then
         return cm_names[1], cm_names[2], cm_names[3], cm_names[4], cm_names[5], cm_names[6]
      elseif count == 7 then
         return cm_names[1], cm_names[2], cm_names[3], cm_names[4], cm_names[5], cm_names[6], cm_names[7]
      end
   end
   return nil
end

------------------------------------------------------------------------------
--                           Вывод информации на HUD                        --
------------------------------------------------------------------------------
-- 'Быстрый вывод на экран информации. Используется для тестов.
function give_quick_news(text)
   if db.actor ~= nil then
      if text == true then
         news_manager.send_tip(db.actor, "true", 0, "diplomat", 2000, nil, "Быстрое сообщение:")
      elseif text == false then
         news_manager.send_tip(db.actor, "false", 0, "diplomat", 2000, nil, "Быстрое сообщение:")
      elseif text == "true" then
         news_manager.send_tip(db.actor, "true в кавычках", 0, "diplomat", 2000, nil, "Быстрое сообщение:")
      elseif text == "false" then
         news_manager.send_tip(db.actor, "false в кавычках", 0, "diplomat", 2000, nil, "Быстрое сообщение:")
      elseif text == nil then
         news_manager.send_tip(db.actor, "nil", 0, "diplomat", 2000, nil, "Быстрое сообщение:")
      elseif text == "nil" then
         news_manager.send_tip(db.actor, "nil в кавычках", 0, "diplomat", 2000, nil, "Быстрое сообщение:")
      else
         news_manager.send_tip(db.actor, text, 0, "diplomat", 2000, nil, "Быстрое сообщение:")
      end
   end
end

function give_quick_news2(info)
   if db.actor ~= nil then
      if has_alife_info(info) then
         news_manager.send_tip(db.actor, "has " .. info, 0, "diplomat", 2000, nil, "Быстрое сообщение:")
      end
   end
end

function show_hud_message(text)
   if db.actor ~= nil then
      if text == true then
         add_hud("hud_event", "true")
      elseif text == "true" then
         add_hud("hud_event", "true в кавычках")
      elseif text == false then
         add_hud("hud_event", "false")
      elseif text == "false" then
         add_hud("hud_event", "false в кавычках")
      elseif text == nil then
         add_hud("hud_event", "nil")
      elseif text == "nil" then
         add_hud("hud_event", "nil в кавычках")
      else
         add_hud("hud_event", text)
      end
   end
end

function show_hud_message2(info)
   if has_alife_info(info) then
      add_hud("hud_event", "yes")
   else
      add_hud("hud_event", "no")
   end
end

-- 'Проверка на отсутствие UI.
function check_ui_disabled(check_frame)
   if check_frame == true then
      return sgm_flags.bool_is_ui_disabled == true and device().precache_frame == 0
   else
      return sgm_flags.bool_is_ui_disabled == true
   end
end

-- 'Проверка на присутствие UI.
function check_ui_worked(check_frame)
   if check_frame == true then
      return sgm_flags.bool_is_ui_disabled == false and device().precache_frame == 0
   else
      return sgm_flags.bool_is_ui_disabled == false
   end
end

-- 'Установка отсутствия UI.
function set_ui_disabled()
   sgm_flags.bool_is_ui_disabled = true
end

-- 'Установка присутствия UI.
function set_ui_worked()
   sgm_flags.bool_is_ui_disabled = false
end

-- 'Вывод на экран текущей секции логики НПС. По профилю.
function show_logic_section(npc, profile)
   local ids = npc:id()
   local hud = get_hud()
   if db.actor ~= nil and npc:profile_name() == profile and db.storage[ids].active_section ~= nil then
      local w_txt = "Схема = " .. db.storage[ids].active_section
      add_hud("hud_event", w_txt)
   end
end

-- 'Вывод на экран полосы прогресса. Состояние оружия во 1-м слоте.
function show_pistol_state_bar(hud_name, xml_name, xml_sect, show_func, clear_bool)
   local hud = get_hud()
   local xml = CScriptXmlInit()
   if hud:GetCustomStatic(hud_name) == nil and (clear_bool == nil or clear_bool ~= true) then
      add_hud(hud_name)
      xml:ParseFile(xml_name)
      pistol_state_bar = xml:InitProgressBar(xml_sect, hud:GetCustomStatic(hud_name):wnd())
      if hud:GetCustomStatic(hud_name) ~= nil then
         add_hud(hud_name)
         pistol_level = show_func
         if pistol_level ~= nil then
            pistol_state_bar:Show(true)
            pistol_state_bar:SetProgressPos(show_func)
         end
      end
   elseif hud:GetCustomStatic(hud_name) ~= nil and (clear_bool == nil or clear_bool ~= true) then
      xml:ParseFile(xml_name)
      add_hud(hud_name)
      pistol_level = show_func
      if pistol_level ~= nil then
         pistol_state_bar:Show(true)
         pistol_state_bar:SetProgressPos(show_func)
      end
   elseif clear_bool ~= nil and clear_bool == true and pistol_state_bar ~= nil then
      pistol_state_bar:Show(false)
   end
end

-- 'Вывод на экран полосы прогресса. Состояние оружия во 2-м слоте.
function show_rifle_state_bar(hud_name, xml_name, xml_sect, show_func, clear_bool)
   local hud = get_hud()
   local xml = CScriptXmlInit()
   if hud:GetCustomStatic(hud_name) == nil and (clear_bool == nil or clear_bool ~= true) then
      add_hud(hud_name)
      xml:ParseFile(xml_name)
      rifle_state_bar = xml:InitProgressBar(xml_sect, hud:GetCustomStatic(hud_name):wnd())
      if hud:GetCustomStatic(hud_name) ~= nil then
         add_hud(hud_name)
         rifle_level = show_func
         if rifle_level ~= nil then
            rifle_state_bar:Show(true)
            rifle_state_bar:SetProgressPos(show_func)
         end
      end
   elseif hud:GetCustomStatic(hud_name) ~= nil and (clear_bool == nil or clear_bool ~= true) then
      xml:ParseFile(xml_name)
      add_hud(hud_name)
      rifle_level = show_func
      if rifle_level ~= nil then
         rifle_state_bar:Show(true)
         rifle_state_bar:SetProgressPos(show_func)
      end
   elseif clear_bool ~= nil and clear_bool == true and rifle_state_bar ~= nil then
      rifle_state_bar:Show(false)
   end
end

-- 'Вывод на экран полосы прогресса. Радиоактивное излучение.
function show_radiation_bar(hud_name, xml_name, xml_sect, show_func)
   local hud = get_hud()
   local xml = CScriptXmlInit()
   if hud:GetCustomStatic(hud_name) == nil then
      add_hud(hud_name)
      xml:ParseFile(xml_name)
      radiation_bar = xml:InitProgressBar(xml_sect, hud:GetCustomStatic(hud_name):wnd())
      if hud:GetCustomStatic(hud_name) ~= nil then
         add_hud(hud_name)
         bar_level = show_func
         if bar_level ~= nil then
            radiation_bar:Show(true)
            radiation_bar:SetProgressPos(bar_level)
         end
      end
   elseif hud:GetCustomStatic(hud_name) ~= nil then
      xml:ParseFile(xml_name)
      add_hud(hud_name)
      bar_level = show_func
      if bar_level ~= nil then
         radiation_bar:Show(true)
         radiation_bar:SetProgressPos(bar_level)
      end
   end
end

-- 'Вывод на экран полосы прогресса. Жизнь босса.
function show_boss_health_bar(hud_name, xml_name, xml_sect, show_func)
   local hud = get_hud()
   local xml = CScriptXmlInit()
   if hud:GetCustomStatic(hud_name) == nil then
      add_hud(hud_name)
      xml:ParseFile(xml_name)
      boss_health_bar = xml:InitProgressBar(xml_sect, hud:GetCustomStatic(hud_name):wnd())
      if hud:GetCustomStatic(hud_name) ~= nil then
         add_hud(hud_name)
         bar_level = show_func
         if bar_level ~= nil then
            boss_health_bar:Show(true)
            boss_health_bar:SetProgressPos(bar_level)
         end
      end
   elseif hud:GetCustomStatic(hud_name) ~= nil then
      xml:ParseFile(xml_name)
      add_hud(hud_name)
      bar_level = show_func
      if bar_level ~= nil then
         boss_health_bar:Show(true)
         boss_health_bar:SetProgressPos(bar_level)
      end
   end
end

-- 'Вывод на экран полосы прогресса. Вербовка монстров.
function show_capture_monster_bar(hud_name, xml_name, xml_sect, show_func, show_text, icon)
   local hud = get_hud()
   local xml = CScriptXmlInit()
   if hud:GetCustomStatic(hud_name) == nil then
      add_hud(icon)
      add_hud(hud_name, show_text)
      xml:ParseFile(xml_name)
      capture_monster_bar = xml:InitProgressBar(xml_sect, hud:GetCustomStatic(hud_name):wnd())
      if hud:GetCustomStatic(hud_name) ~= nil then
         add_hud(icon)
         add_hud(hud_name, show_text)
         bar_level = show_func
         if bar_level ~= nil then
            capture_monster_bar:Show(true)
            capture_monster_bar:SetProgressPos(bar_level)
         end
      end
   elseif hud:GetCustomStatic(hud_name) ~= nil then
      xml:ParseFile(xml_name)
      add_hud(icon)
      add_hud(hud_name, show_text)
      bar_level = show_func
      if bar_level ~= nil then
         capture_monster_bar:Show(true)
         capture_monster_bar:SetProgressPos(bar_level)
      end
   end
end

-- 'Вывод на экран полосы прогресса. Вербовка монстров.
function show_battery_power_bar(hud_name, xml_name, xml_sect, show_func, show_text)
   local hud = get_hud()
   local xml = CScriptXmlInit()
   if hud:GetCustomStatic(hud_name) == nil then
      add_hud(hud_name, show_text)
      xml:ParseFile(xml_name)
      battery_power_bar = xml:InitProgressBar(xml_sect, hud:GetCustomStatic(hud_name):wnd())
      if hud:GetCustomStatic(hud_name) ~= nil then
         add_hud(hud_name, show_text)
         bar_level = show_func
         if bar_level ~= nil then
            battery_power_bar:Show(true)
            battery_power_bar:SetProgressPos(bar_level)
         end
      end
   elseif hud:GetCustomStatic(hud_name) ~= nil then
      xml:ParseFile(xml_name)
      add_hud(hud_name, show_text)
      bar_level = show_func
      if bar_level ~= nil then
         battery_power_bar:Show(true)
         battery_power_bar:SetProgressPos(bar_level)
      end
   end
end

-- 'Запуск динамического окна.
function run_dynamic_element(folder, close_inv, ui_disable)
   if close_inv == false then
      folder:ShowDialog(true)
   elseif close_inv == true then
      folder:ShowDialog(true)
      game_hide_menu()
      level.show_weapon(false)
   else
      folder:ShowDialog(true)
   end
   if ui_disable == true then
      set_ui_disabled()
   elseif ui_disable == false then
      set_ui_worked()
   end
end

-- 'Запуск окошка, в котором нужно нажимать кнопки Да:Нет:Ок.
function run_choose_box(type, reason, text, extra_value)
   if object_exists(db.actor) and device().precache_frame == 0 and (not db.actor:is_talking()) then
      sgm_ui_mod_elements.information_block_show(type, reason, text, extra_value)
   end
end

-- 'Добавление HUD элемента.
function add_hud(hud_name, hud_text, hud_precond, hud_clever)
   if (hud_precond == nil or hud_precond == false) or (hud_precond ~= nil and hud_precond == true and precond_hud()) then
      get_hud():AddCustomStatic(hud_name, true)
      if hud_text ~= nil then
         get_hud():GetCustomStatic(hud_name):wnd():TextControl():SetTextST(hud_text)
      end
   elseif hud_precond ~= nil and hud_precond == true and hud_clever ~= nil and hud_clever == true and (not precond_hud()) then
      if get_hud():GetCustomStatic(hud_name) ~= nil then
         get_hud():RemoveCustomStatic(hud_name)
      end
   end
end

-- 'Удаление HUD элемента.
function release_hud(hud_name)
   if get_hud():GetCustomStatic(hud_name) ~= nil then
      get_hud():RemoveCustomStatic(hud_name)
   end
end

-- 'Условие для использования HUD элементов.
function precond_hud(type)
   if type == nil or type == 1 then
      return (not db.actor:is_talking()) and object_alive(db.actor) and check_ui_worked(true) and
          sgm_g.dont_has_alife_info("inventory_wnd_opened") and sgm_g.dont_has_alife_info("sleep_active") and
          sgm_g.dont_has_alife_info("actor_in_sleep") and sgm_g.dont_has_alife_info("screenshot_mode")
   elseif type == 2 then
      return object_alive(db.actor) and check_ui_worked(true) and sgm_g.dont_has_alife_info("actor_in_sleep") and
          sgm_g.dont_has_alife_info("sleep_active")
   elseif type == 3 then
      return (not db.actor:is_talking()) and object_alive(db.actor) and check_ui_worked(true) and
          sgm_g.dont_has_alife_info("screenshot_mode") and sgm_g.dont_has_alife_info("inventory_wnd_opened") and
          sgm_g.dont_has_alife_info("actor_in_sleep")
   end
end

------------------------------------------------------------------------------
--                         Отсчет по статистике                             --
------------------------------------------------------------------------------
-- 'Вывод информации о заработанном ранге.
function congratulate_with_rank_event(type, delay, to_value, sound_bool, add_text, check_talking)
   if type == "add" and sgm_g.dont_has_alife_info("opt_disable_statistic_event") then
      sgm_flags.value_rank_counter = sgm_flags.value_rank_counter + to_value
      local descriptor = game.translate_string("st_rank_event_present") ..
          " " .. "(+" .. math.floor(sgm_flags.value_rank_counter) .. ")"
      local end_text = ""
      if add_text ~= nil then
         end_text = add_text
      end
      if math.floor(sgm_flags.value_rank_counter) >= 1.0 then
         descriptor = game.translate_string("st_rank_event_present") ..
             " " .. "(+" .. math.floor(sgm_flags.value_rank_counter) .. ")" .. " " .. end_text
      else
         descriptor = game.translate_string("st_rank_event_present") .. " " .. end_text
      end
      if (check_talking == nil or check_talking == false) or (check_talking == true and (not db.actor:is_talking())) then
         add_hud("hud_message_event", descriptor)
      end
      start_flague_timer("timer_hud_message", delay)
      if sound_bool ~= nil and sound_bool == true then
         play_snd_at_actor([[device\pda\pda_news]])
      end
   elseif type == "clear" and sgm_g.dont_has_alife_info("opt_disable_statistic_event") then
      sgm_flags.timer_hud_message = 0
      release_hud("hud_message_event")
   end
end

-- 'Вывод информации о заработанном хедшоте.
function congratulate_with_headshot_event(type, delay, to_value, sound_bool, check_talking)
   if type == "add" and sgm_g.dont_has_alife_info("opt_disable_statistic_event") then
      sgm_flags.value_headshot_counter = sgm_flags.value_headshot_counter + to_value
      local descriptor = game.translate_string("st_event_headshot") ..
          " " .. "(+" .. math.floor(sgm_flags.value_headshot_counter) .. ")"
      if (check_talking == nil or check_talking == false) or (check_talking == true and (not db.actor:is_talking())) then
         add_hud("hud_message_event", descriptor)
      end
      start_flague_timer("timer_hud_message", delay)
      if sound_bool ~= nil and sound_bool == true then
         play_snd_at_actor([[device\pda\pda_news]])
      end
   elseif type == "clear" and sgm_g.dont_has_alife_info("opt_disable_statistic_event") then
      sgm_flags.timer_hud_message = 0
      release_hud("hud_message_event")
   end
end

-- 'Вывод информации о найденном SGM тайнике.
function congratulate_with_secret_event(type, delay, sound_bool, check_talking)
   if type == "add" and sgm_g.dont_has_alife_info("opt_disable_statistic_event") then
      local descriptor = game.translate_string("st_event_iam_find") ..
          " " .. read_mod_param("stat_taynikov") .. game.translate_string("st_event_find_secret")
      if (check_talking == nil or check_talking == false) or (check_talking == true and (not db.actor:is_talking())) then
         add_hud("hud_message_event", descriptor)
      end
      start_flague_timer("timer_hud_message", delay)
      if sound_bool ~= nil and sound_bool == true then
         play_snd_at_actor([[device\pda\pda_news]])
      end
   elseif type == "clear" and sgm_g.dont_has_alife_info("opt_disable_statistic_event") then
      sgm_flags.timer_hud_message = 0
      release_hud("hud_message_event")
   end
end

-- 'Вывод информации о найденном персональном тайнике.
function congratulate_with_deserve_event(type, delay, sound_bool, check_talking)
   if type == "add" and sgm_g.dont_has_alife_info("opt_disable_statistic_event") then
      local descriptor = game.translate_string("st_event_iam_find") ..
          " " .. read_mod_param("stat_deserves") .. game.translate_string("st_event_find_deserve")
      if (check_talking == nil or check_talking == false) or (check_talking == true and (not db.actor:is_talking())) then
         add_hud("hud_message_event", descriptor)
      end
      start_flague_timer("timer_hud_message", delay)
      if sound_bool ~= nil and sound_bool == true then
         play_snd_at_actor([[device\pda\pda_news]])
      end
   elseif type == "clear" and sgm_g.dont_has_alife_info("opt_disable_statistic_event") then
      sgm_flags.timer_hud_message = 0
      release_hud("hud_message_event")
   end
end

-- 'Вывод длинной строки на HUD.
function congratulate_with_event(delay, descr, sound_bool, check_talking)
   if sgm_g.dont_has_alife_info("opt_disable_statistic_event") then
      if (check_talking == nil or check_talking == false) or (check_talking == true and (not db.actor:is_talking())) then
         add_hud("hud_message_event_long", descr)
      end
      start_flague_timer("timer_hud_message", delay)
      if sound_bool ~= nil and sound_bool == true then
         play_snd_at_actor([[device\pda\pda_news]])
      end
   end
end

-- 'Используется для проверки работы биндера.
function show_crash_event(delay, descr)
   add_hud("hud_crash_info", descr)
   start_flague_timer("timer_hud_crash", delay)
end

------------------------------------------------------------------------------
--                      Работа с автосохранениями                           --
------------------------------------------------------------------------------
-- 'Условие для успешного автосохранения.
function autosave_precond()
   if object_exists(db.actor) and device().precache_frame == 0 and (not db.actor:is_talking()) and sgm_g.dont_has_alife_info("actor_in_sleep") then
      return true
   elseif object_exists(db.actor) and device().precache_frame ~= 0 and (not db.actor:is_talking()) and sgm_g.dont_has_alife_info("actor_in_sleep") then
      return false
   else
      return false
   end
end

-- 'Запись автосохранения.
function game_autosave(save_name, type)
   if type == nil then type = 1 end
   if type == 1 then
      if autosave_precond() then
         if save_name ~= nil and sgm_g.dont_has_alife_info(save_name) then
            give_info(save_name)
            if IsImportantSave() then
               local save_param = user_name() .. " - " .. game.translate_string("st_" .. save_name)
               sgm_flags.string_savegame_type = "autosave"
               data_param_save_game(save_param)
               get_console():execute("save " .. save_param)
            end
         end
      else
         if sgm_flags.table_mod_autosaves[save_name] == nil and IsImportantSave() then
            sgm_flags.table_mod_autosaves[save_name] = true
         end
      end
   elseif type == 2 then
      if (autosave_precond() or find_in_string(save_name, "st_save_travel_")) and IsImportantSave() then
         local save_param = user_name() .. " - " .. game.translate_string(save_name)
         sgm_flags.string_savegame_type = "autosave"
         data_param_save_game(save_param)
         get_console():execute("save " .. save_param)
      else
         if sgm_flags.table_mod_autosaves[save_name] == nil and IsImportantSave() then
            sgm_flags.table_mod_autosaves[save_name] = true
         end
      end
   end
end

function game_autosave_assign(save_name)
   if sgm_flags.table_mod_autosaves[save_name] == nil and IsImportantSave() then
      sgm_flags.table_mod_autosaves[save_name] = true
   end
end

------------------------------------------------------------------------------
--                   Функции воспроизведения звуков                         --
------------------------------------------------------------------------------
-- 'Воспроизвести звук(возможно зацыкленный) в голове ГГ.
function play_folder_snd(sound, looped)
   local snd_souce
   if looped == nil then
      snd_souce = sound_object(sound)
      snd_souce:play(db.actor, 0, sound_object.s2d)
   else
      snd_souce = sound_object(sound)
      if snd_souce:playing() == false then
         snd_souce:play(db.actor, 0, sound_object.s2d + sound_object.looped)
      end
   end
end

-- 'Воспроизвести звук от НПС.
function play_snd_at_pos(npc, sound, count1, count2)
   local snd_souce
   if count1 == nil or count2 == nil then
      snd_souce = sound_object(sound)
      snd_souce:play_at_pos(npc, npc:position(), 0, sound_object.s3d)
   elseif count1 ~= nil and count2 ~= nil then
      local rnd_snd = math.random(count1, count2)
      snd_souce = sound_object(sound .. rnd_snd)
      snd_souce:play_at_pos(npc, npc:position(), 0, sound_object.s3d)
   end
end

-- 'Воспроизвести звук в голове ГГ.
function play_snd_at_actor(sound, count1, count2)
   local snd_souce
   if count1 == nil or count2 == nil then
      snd_souce = sound_object(sound)
      snd_souce:play(db.actor, 0, sound_object.s2d)
   elseif count1 ~= nil and count2 ~= nil then
      local rnd_snd = math.random(count1, count2)
      snd_souce = sound_object(sound .. rnd_snd)
      snd_souce:play(db.actor, 0, sound_object.s2d)
   end
end

-- 'Воспроизвести зацыкленный звук от НПС.
function play_loop_snd_at_pos(npc, sound, count1, count2)
   local snd_souce
   if count1 == nil or count2 == nil then
      snd_souce = sound_object(sound)
      if snd_souce:playing() == false then
         snd_souce:play_at_pos(npc, npc:position(), 0, sound_object.s3d + sound_object.looped)
      end
   elseif count1 ~= nil and count2 ~= nil then
      snd_souce = sound_object(sound .. math.random(count1, count2))
      if snd_souce:playing() == false then
         snd_souce:play_at_pos(npc, npc:position(), 0, sound_object.s3d + sound_object.looped)
      end
   end
end

-- 'Воспроизвести зацыкленный звук в голове ГГ.
function play_loop_snd_at_actor(sound, count1, count2)
   local snd_souce
   if count1 == nil or count2 == nil then
      snd_souce = sound_object(sound)
      if snd_souce:playing() == false then
         snd_souce:play(db.actor, 0, sound_object.s2d + sound_object.looped)
      end
   elseif count1 ~= nil and count2 ~= nil then
      snd_souce = sound_object(sound .. math.random(count1, count2))
      if snd_souce:playing() == false then
         snd_souce:play(db.actor, 0, sound_object.s2d + sound_object.looped)
      end
   end
end

-- 'Воспроизвести звуковую схему.
function play_theme_snd(npc, snd)
   if npc == nil then npc = db.actor end
   xr_sound.set_sound_play(npc:id(), snd)
end

------------------------------------------------------------------------------
--                     Работа с секциями и строками                         --
------------------------------------------------------------------------------
-- 'Чтение текста слева от указанного знака.
function read_string_removal_l(target_str, sign)
   if target_str ~= nil then
      return string.sub(target_str, 1, string.find(target_str, sign) - 1)
   end
   return nil
end

-- 'Чтение текста справа от указанного знака.
function read_string_removal_r(target_str, sign)
   if target_str ~= nil then
      return string.sub(target_str, string.find(target_str, sign) + 1)
   end
   return nil
end

-- 'Чтение текста c указанной буквы по счету.
function read_string_from_symbol(target_str, s_num)
   if target_str ~= nil then
      return string.sub(target_str, s_num)
   end
   return nil
end

-- 'Присутствие в названии строки.
function find_in_string(where, what)
   if where ~= nil and what ~= nil and string.find(where, what) then
      return true
   elseif where == nil or what == nil then
      return nil
   end
   return false
end

-- 'Отсутствие в названии строки.
function find_out_string(where, what)
   if where ~= nil and what ~= nil and string.find(where, what) then
      return false
   elseif where == nil or what == nil then
      return nil
   end
   return true
end

-- 'Сохранение списка секций из .ltx в табличную переменную.
-- ! warning, NOT SAVE FUNCTION
function save_and_transform_ini_table(ini_path, ini_table, script_path, script_table, need_exist)
   local ini = ini_file(ini_path)
   local list_name_1 = ini_table
   local list_name_2 = script_table
   local n = ini:line_count(list_name_1)
   for i = 0, n - 1 do
      local result, id, value = ini:r_line(list_name_1, i, "", "")
      if (need_exist == nil or need_exist == false) or (need_exist == true and ini:section_exist(id)) then
         if sgm_flags[script_path][list_name_2] == nil then
            sgm_flags[script_path][list_name_2] = {}
         end
         table.insert(sgm_flags[script_path][list_name_2], id)
      end
   end
end

-- 'Проверка таблицы на наличие составляющих.
function check_table(tbl)
   for k, v in pairs(tbl) do
      if v ~= nil then
         return true
      end
   end
   return false
end

-- 'Проверка таблицы на количество {}.
function get_table_lines(tbl, debug)
   local result = 0
   for k, v in pairs(tbl) do
      result = result + 1
      if debug == true then
         if k ~= nil and v ~= nil then
            debug_to_file("debug.txt", "k=" .. tostring(k) .. "|" .. "v=" .. tostring(v))
         end
      end
   end
   return result
end

-- 'Случайный выбор строки из таблицы.
function get_random_string(tbl)
   return tbl[math.random(table.getn(tbl))]
end

-- 'Случайный выбор значения из переменной.
function get_random_line(line)
   line_table = parse_general_names(line)
   return get_random_string(line_table)
end

-- 'Количество значений в таблице.
function get_table_names(tbl)
   return #tbl
end

-- 'Возвращение строки
function to_string(val)
   if val == nil then
      return val
   end
   return tostring(val)
end

-- 'Возвращение цифры
function to_number(val)
   if val == nil then
      return val
   end
   return tonumber(val)
end

-- 'Проверка на адекватность значения.
function exists(val)
   return val ~= nil and val ~= "nil"
end

-- 'Случайное число
function get_rnd(v1, v2)
   if v1 == nil and v2 == nil then v1, v2 = 1, 2 end
   local rnd_value = math.random(v1, v2)
   return rnd_value
end

------------------------------------------------------------------------------
--                 Работа с LOG файлом или консолью                         --
------------------------------------------------------------------------------
-- 'Отправка сообщения в консоль.
function fill_log(string_txt)
   get_console():execute(string_txt)
end

-- 'Создание файл с текстом внутри.
function debug_to_file(filename, text)
   local file = io.open(filename, "w")
   file:write(tostring(text), "\n")
   file:close()
end

-- 'Отладка координат предмета.
function debug_rect_item(filename, itmname, x, y, w, h)
   local data = "     <texture id=" .. itmname .. " x=" .. x .. " y=" .. y .. " width=" .. w .. " height=" .. h .. "/>"
   local file = io.open(filename, "a+")
   file:write(data, "\n")
   file:close(file)
end

-- 'Работа с файлом.
function file_write_param(filename, param, value)
   local file = io.open(filename, "a+")
   if param == nil then
      file:write(tostring(value), "\n")
   else
      file:write(tostring(param) .. "=" .. tostring(value), "\n")
   end
   file:close(file)
end

function file_read_param(filename)
   f = io.input(filename)
   s = f:read("*l")
   if s then
      return s
   else
      return 0
   end
end

function file_remove(filename)
   os.remove(filename)
end

------------------------------------------------------------------------------
--                         Работа с инвентарем                              --
------------------------------------------------------------------------------
-- 'Удаление предмета из инвентаря обьекта.
function remove_inv_item(victim, item)
   if victim ~= nil and item ~= nil and victim:object(item) and alife():object(victim:object(item):id()) then
      alife():release(alife():object(victim:object(item):id()), true)
   end
end

-- 'Удаление обьекта по его ID.
function remove_object_by_id(item_id)
   if item_id ~= nil and alife():object(item_id) then
      alife():release(alife():object(item_id), true)
   end
end

-- 'Удалить предмет обьекта, из слота.
function remove_item_from_slot(victim, slot_number)
   if victim:item_in_slot(tonumber(slot_number)) ~= nil then
      remove_object_by_id(victim:item_in_slot(tonumber(slot_number)):id())
   end
end

-- 'Проверка на отсутствие предмета, и спаун предмета.
function check_actor_item_to_add(target_item, count)
   if not db.actor:object(target_item) then
      give_object_to_npc(target_item, db.actor, count)
   end
end

-- 'Проверка на наличие, и затем удаление предмета из инвентаря ГГ.
function check_actor_item_to_remove(target_item)
   if db.actor:object(target_item) then
      remove_inv_item(db.actor, target_item)
   end
end

-- 'Проверка на наличие перечня указанных предметов.
function has_chosen_items(items)
   if find_out_string(items, ",") then
      return db.actor:object(items)
   else
      local items_result = 0
      local items_table = utils.parse_spawns(items)
      local items_count = get_table_names(items_table)
      for k, v in pairs(items_table) do
         if db.actor:object(v.section) then
            if v.prob > 1 then
               if get_item_count(v.section) >= v.prob then
                  items_result = items_result + 1
               end
            else
               items_result = items_result + 1
            end
         end
      end
      return items_result >= items_count
   end
end

-- 'Проверка на отсутствие перечня указанных предметов.
function dont_has_chosen_items(items)
   if find_out_string(items, ",") then
      return not db.actor:object(items)
   else
      local items_result = 0
      local items_table = utils.parse_spawns(items)
      local items_count = get_table_names(items_table)
      for k, v in pairs(items_table) do
         if not db.actor:object(v.section) then
            items_result = items_result + 1
         end
      end
      return items_result >= items_count
   end
end

-- 'Проверка на наличие любого предмета из перечня.
function has_any_items(items)
   if find_out_string(items, ",") then
      return db.actor:object(items)
   else
      local items_result = false
      local items_table = utils.parse_spawns(items)
      local items_count = get_table_names(items_table)
      for k, v in pairs(items_table) do
         if db.actor:object(v.section) then
            items_result = true
         end
      end
      return items_result
   end
end

-- 'Проверка на отсутствие любого предмета из перечня.
function dont_has_any_items(items)
   if find_out_string(items, ",") then
      return not db.actor:object(items)
   else
      local items_result = false
      local items_table = utils.parse_spawns(items)
      local items_count = get_table_names(items_table)
      for k, v in pairs(items_table) do
         if not db.actor:object(v.section) then
            items_result = true
         end
      end
      return items_result
   end
end

-- 'Снятие предмета с рабочего слота.
function throw_item_from_slot(slot)
   if slot == "pistol" then
      slot = 2
   elseif slot == "rifle" then
      slot = 3
   elseif slot == "outfit" then
      slot = 7
   elseif slot == "helm" then
      slot = 12
   end
   local check_slot = db.actor:item_in_slot(slot)
   if check_slot ~= nil and check_slot:section() ~= nil and alife():object(check_slot:id()) then
      local section = check_slot:section()
      sgm_flags.value_throw_item_cond = check_slot:condition()
      alife():release(alife():object(check_slot:id()), true)
      th_itm = alife():create(section, db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(),
         db.actor:id())
      sgm_flags.value_throw_item_id = th_itm.id
   end
end

-- 'Респаун предмета при соблюдении специального условия.
function respawn_item_if_comparison(need_value_and_item, comparison_value, item_count)
   local check_item = need_value_and_item
   if find_in_string(comparison_value, check_item) then
      check_actor_item_to_add(check_item, item_count)
   end
end

-- 'Проверка наличия определенного предмета в слоте.
function get_actor_slot_item(item_name, item_type)
   local pistol_in_slot = db.actor:item_in_slot(2)
   local rifle_in_slot = db.actor:item_in_slot(3)
   local outfit_in_slot = db.actor:item_in_slot(7)
   local helm_in_slot = db.actor:item_in_slot(12)
   if item_name ~= nil and item_type == "pistol" and pistol_in_slot ~= nil and find_in_string(pistol_in_slot:section(), item_name) then
      return true
   elseif item_name ~= nil and item_type == "rifle" and rifle_in_slot ~= nil and find_in_string(rifle_in_slot:section(), item_name) then
      return true
   elseif item_name ~= nil and item_type == "outfit" and outfit_in_slot ~= nil and find_in_string(outfit_in_slot:section(), item_name) then
      return true
   elseif item_name ~= nil and item_type == "helm" and helm_in_slot ~= nil and find_in_string(helm_in_slot:section(), item_name) then
      return true
   else
      return false
   end
end

-- 'Проверка на наличие предмета в слоте и при необходимости, на соответствие к compare_section.
function check_actor_item_in_slot(need_slot, compare_section, need_active)
   local currert_slot = db.actor:item_in_slot(need_slot)
   local active_item = db.actor:active_item()
   if currert_slot ~= nil and currert_slot:section() ~= nil then
      if compare_section ~= nil and compare_section == "self" then
         compare_section = currert_slot:section()
      end
      if compare_section ~= nil and currert_slot:section() == compare_section then
         if need_active ~= true then
            return true
         else
            if active_item and active_item:section() == compare_section then
               return true
            end
         end
      elseif compare_section == nil then
         return true
      end
   end
   return false
end

-- 'Проверка на занятость слота.
function check_slot_filled(need_slot)
   local currert_slot = db.actor:item_in_slot(need_slot)
   if currert_slot ~= nil and currert_slot:section() ~= nil then
      return true
   end
   return false
end

-- 'Возвращение предмета в слоте.
function get_slot_object(slot)
   local currert_slot = db.actor:item_in_slot(slot)
   if currert_slot ~= nil and currert_slot:section() ~= nil then
      return currert_slot
   end
   return nil
end

-- 'Проверка по количеству предметов одного типа.
function have_item_count(need_item, num, st_find)
   local item_section = need_item
   local need_count = tonumber(num)
   local has_count = 0
   local function calc(temp, item)
      if (st_find == nil or st_find == false) and item:section() == item_section then
         has_count = has_count + 1
      elseif st_find == true and find_in_string(item:section(), item_section) then
         has_count = has_count + 1
      end
   end
   db.actor:iterate_inventory(calc, db.actor)
   return has_count >= need_count
end

function get_item_count(need_item, st_find)
   local item_section = need_item
   local has_count = 0
   local function calc(temp, item)
      if (st_find == nil or st_find == false) and item:section() == item_section then
         has_count = has_count + 1
      elseif st_find == true and find_in_string(item:section(), item_section) then
         has_count = has_count + 1
      end
   end
   db.actor:iterate_inventory(calc, db.actor)
   return has_count
end

-- 'Проверка по количеству предметов нескольких типов.
function check_item_count(need_items, type_count, glass)
   local has_count = 0
   local need_count = tonumber(type_count)
   if need_count == nil then need_count = 1 end
   local item_table = utils.parse_spawns(need_items)
   for k, v in pairs(item_table) do
      for i = 1, v.prob do
         local function calc(temp, item)
            if glass == nil or glass == false then
               if item:section() == v.section then has_count = has_count + 1 end
            else
               if find_in_string(item:section(), v.section) then has_count = has_count + 1 end
            end
         end
         db.actor:iterate_inventory(calc, db.actor)
      end
   end
   return has_count >= need_count
end

-- 'Возвращение ID предмета из инвентаря ГГ. С проверкой на не совпадение ID с exclude_id.
function get_utils_id(need_item, exclude_id)
   local item_section = need_item
   local utils_id = 0
   local function calc(temp, item)
      if item:id() ~= exclude_id and item:section() == item_section then
         utils_id = item:id()
      end
   end
   db.actor:iterate_inventory(calc, db.actor)
   return utils_id
end

-- 'Вернуть таблицу с ID для одного предмета.
function parse_one_item_table(need_item)
   local item_table = {}
   local item_section = need_item
   local item_cnt = 0
   local function calc(temp, item)
      if item:section() == item_section then
         if item_cnt == 0 then
            item_cnt = 1
            table.insert(item_table, item:id())
         end
      end
   end
   db.actor:iterate_inventory(calc, db.actor)
   return item_table
end

-- 'Вернуть таблицу с IDшниками для двух предметов.
function parse_two_item_table(need_item)
   local item_table = {}
   local item_section = need_item
   local item_cnt = 0
   local function calc(temp, item)
      if item:section() == item_section then
         if item_cnt == 0 then
            item_cnt = 1
            table.insert(item_table, item:id())
         elseif item_cnt == 1 then
            item_cnt = 2
            table.insert(item_table, item:id())
         end
      end
   end
   db.actor:iterate_inventory(calc, db.actor)
   return item_table
end

-- 'Удаление предметов из инвентаря.
function release_inventory(victim, from_what)
   local function get_release_inventory(victim, item)
      local section = item:section()
      if item ~= nil and (from_what == nil or from_what == "all" or (from_what == "weapon" and (find_in_string(section, "wpn_") or find_in_string(section, "grenade"))) or (from_what == "outfit" and (find_in_string(section, "outfit") or find_in_string(section, "helm")))) then
         remove_object_by_id(item:id())
      end
   end
   victim:iterate_inventory(get_release_inventory, victim)
end

-- 'Удаление предметов из инвентарного обьекта.
function clear_items_from_inv_box(victim)
   local function calc(temp, item)
      if item ~= nil then
         if alife():object(item:id()) then
            alife():release(alife():object(item:id()), true)
         end
      end
   end
   victim:iterate_inventory_box(calc, victim)
end

-- 'Удаление предметов по их принадлежности к определенному слоту.
function clear_slot_items_from_inventory(victim, target_slot)
   local function calc(temp, item)
      if item ~= nil then
         if sgm_functions.GetItemSlot(item:section()) == target_slot then
            if alife():object(item:id()) then
               alife():release(alife():object(item:id()), true)
            end
         end
      end
   end
   victim:iterate_inventory(calc, victim)
end

-- 'Удаление определённых предметов.
function clear_item_from_inventory(victim, target_item)
   local function calc(temp, item)
      if item ~= nil then
         if item:section() == target_item then
            if alife():object(item:id()) then
               alife():release(alife():object(item:id()), true)
            end
         end
      end
   end
   victim:iterate_inventory(calc, victim)
end

-- 'Перенос предметов от одного обьекта к другому.
function inventory_box_transfer_to(from, to)
   local transfer_items = {}
   local function transfer_functor(from, item)
      table.insert(transfer_items, item)
   end
   from:iterate_inventory_box(transfer_functor, from)
   for k, v in pairs(transfer_items) do
      from:transfer_item(v, to)
   end
end

-- 'Проверка текущего веса в рюкзаке ГГ.
function get_actor_inventory_weight()
   local weight = 0.0
   local function calculate_weight(temp, item)
      if item ~= nil and item:section() ~= nil then
         weight = weight + sgm_functions.ReadItemWeight(item:section()) * item:condition()
      end
   end
   db.actor:iterate_inventory(calculate_weight, db.actor)
   return weight
end

-- 'Проверка наличия предметов с указанной секцией, в инвентарном обьекте.
function get_item_section_in_inventory_box(obj_box, target_item)
   local result = false
   local function check_items(temp, item)
      if item ~= nil and item:section() == target_item then
         result = true
         return true
      end
   end
   obj_box:iterate_inventory_box(check_items, obj_box)
   return result
end

-- 'Проверка количества предметов с указанной секцией, в инвентарном обьекте.
function get_item_count_in_inventory_box(obj_box, target_item)
   local result = 0
   local function check_items(temp, item)
      if item ~= nil and item:section() == target_item then
         result = result + 1
      end
   end
   obj_box:iterate_inventory_box(check_items, obj_box)
   return result
end

-- 'Проверка наличия предметов с указанной частью секции, в инвентарном обьекте.
function get_item_section_f_inventory_box(obj_box, target_item)
   local result = false
   local function check_items(temp, item)
      if item ~= nil and find_in_string(item:section(), target_item) then
         result = true
         return true
      end
   end
   obj_box:iterate_inventory_box(check_items, obj_box)
   return result
end

-- 'Проверка количества предметов с указанной частью секции, в инвентарном обьекте.
function get_item_count_f_inventory_box(obj_box, target_item)
   local result = 0
   local function check_items(temp, item)
      if item ~= nil and find_in_string(item:section(), target_item) then
         result = result + 1
      end
   end
   obj_box:iterate_inventory_box(check_items, obj_box)
   return result
end

-- 'Чистка предметов в инвентаре ГГ после фриплея.
function freeplay_inventory_clean(victim)
   local function calc(temp, item)
      if item ~= nil then
         if get_object_story_id(item:id()) == nil and find_out_string(item:section(), "device_torch") and find_out_string(item:section(), "knife") and find_out_string(item:section(), "addon") and find_out_string(item:section(), "binoc") and find_out_string(item:section(), "knife") and find_out_string(item:section(), "_box") and (find_in_string(item:section(), "wpn_") or find_in_string(item:section(), "_outfit") or find_in_string(item:section(), "helm_") or find_in_string(item:section(), "ammo_") or find_in_string(item:section(), "medkit") or find_in_string(item:section(), "psy_complex") or find_in_string(item:section(), "antirad") or find_in_string(item:section(), "bandage")) then
            if alife():object(item:id()) then
               alife():release(alife():object(item:id()), true)
            end
         end
      end
   end
   victim:iterate_inventory(calc, victim)
end

-- 'Перезагрузка артефактов ГГ. Используется для переброски артефактов из пояса в рюкзак.
function transfer_artefacts_with_belt_to_inv()
   local function transfers(temp, item)
      if item ~= nil then
         if find_in_string(item:section(), "af_") or find_in_string(item:section(), "cev_plastin") then
            if alife():object(item:id()) then
               alife():release(alife():object(item:id()), true)
               give_object_to_actor(item:section())
            end
         end
      end
   end
   db.actor:iterate_inventory(transfers, db.actor)
end

------------------------------------------------------------------------------
--                     Функции для добавления квестов                       --
------------------------------------------------------------------------------
-- 'Выдача квеста.
function add_task(task_id)
   task_manager.get_task_manager():give_task(task_id)
end

------------------------------------------------------------------------------
--                         Работа с метками                                 --
------------------------------------------------------------------------------
-- 'Проверка метки на обьекте.
function get_spot_on_map(obj_id, location_name)
   return level.map_has_object_spot(obj_id, location_name) ~= 0
end

-- 'Установка метки на обьект.
function add_spot_on_map(obj_id, location_name, descr)
   if obj_id ~= nil and level.map_has_object_spot(obj_id, location_name) == 0 then
      if descr == nil then descr = "" end
      level.map_add_object_spot_ser(obj_id, location_name, descr)
   end
end

-- 'Удаление метки с обьекта.
function remove_spot_on_map(obj_id, location_name)
   if obj_id ~= nil and level.map_has_object_spot(obj_id, location_name) ~= 0 then
      level.map_remove_object_spot(obj_id, location_name)
   end
end

-- 'Установка/удаление метки на обьекте.
function set_spot_choose(obj_id, location_name, type, descr)
   if type == "hide" and obj_id ~= nil then
      remove_spot_on_map(obj_id, location_name)
   elseif type == "show" and obj_id ~= nil then
      add_spot_on_map(obj_id, location_name, descr)
   end
end

-- 'Установка метки на SID.
function add_spot_on_map_for_sid(sid, location, descr)
   if get_story_object_id(sid) ~= nil then
      add_spot_on_map(get_story_object_id(sid), location, descr)
   end
end

------------------------------------------------------------------------------
--                       Захват всех обьектов                               --
------------------------------------------------------------------------------
-- 'Универсальная чистка предметов на локациях.
function clear_all_objects(victim_type, range_min, range_max)
   local anomaly_exception = (level.name() ~= "darkvalley" and level.name() ~= "military" and level.name() ~= "agroprom" and level.name() ~= "escape" and level.name() ~= "marsh" and level.name() ~= "red_forest")
   if victim_type == "monster" then
      for a = 1, 65534 do
         local obj = alife():object(a)
         if obj and IsMonster(obj) and (not obj:alive()) and get_object_story_id(obj.id) == nil then
            if range_min == nil and range_max == nil then
               remove_object_by_id(obj.id)
            elseif range_min ~= nil and range_max == nil then
               if db.actor:position():distance_to(obj.position) >= range_min then
                  remove_object_by_id(obj.id)
               end
            elseif range_min == nil and range_max ~= nil then
               if db.actor:position():distance_to(obj.position) <= range_max then
                  remove_object_by_id(obj.id)
               end
            elseif range_min ~= nil and range_max ~= nil then
               if db.actor:position():distance_to(obj.position) >= range_min and db.actor:position():distance_to(obj.position) <= range_max then
                  remove_object_by_id(obj.id)
               end
            end
         end
      end
   elseif victim_type == "stalker" then
      for a = 1, 65534 do
         local obj = alife():object(a)
         if obj and IsStalker(obj) and (not obj:alive()) and get_object_story_id(obj.id) == nil then
            if range_min == nil and range_max == nil then
               remove_object_by_id(obj.id)
            elseif range_min ~= nil and range_max == nil then
               if db.actor:position():distance_to(obj.position) >= range_min then
                  remove_object_by_id(obj.id)
               end
            elseif range_min == nil and range_max ~= nil then
               if db.actor:position():distance_to(obj.position) <= range_max then
                  remove_object_by_id(obj.id)
               end
            elseif range_min ~= nil and range_max ~= nil then
               if db.actor:position():distance_to(obj.position) >= range_min and db.actor:position():distance_to(obj.position) <= range_max then
                  remove_object_by_id(obj.id)
               end
            end
         end
      end
   elseif victim_type == "anomaly" then
      for a = 1, 65534 do
         local obj = alife():object(a)
         if obj and obj:section_name() ~= nil and anomaly_exception and get_object_story_id(obj.id) == nil and ((string.find(obj:section_name(), "sgm_") and (not string.find(obj:name(), "quest_anomaly")) and (string.find(obj:section_name(), "field") or string.find(obj:section_name(), "streem"))) or string.find(obj:name(), "throw_zone") or string.find(obj:name(), "artefact_spawner_mod")) then
            if range_min == nil and range_max == nil then
               remove_object_by_id(obj.id)
            elseif range_min ~= nil and range_max == nil then
               if db.actor:position():distance_to(obj.position) >= range_min then
                  remove_object_by_id(obj.id)
               end
            elseif range_min == nil and range_max ~= nil then
               if db.actor:position():distance_to(obj.position) <= range_max then
                  remove_object_by_id(obj.id)
               end
            elseif range_min ~= nil and range_max ~= nil then
               if db.actor:position():distance_to(obj.position) >= range_min and db.actor:position():distance_to(obj.position) <= range_max then
                  remove_object_by_id(obj.id)
               end
            end
         end
      end
   elseif victim_type == "mine" then
      for a = 1, 65534 do
         local obj = alife():object(a)
         if obj and obj:section_name() ~= nil and string.find(obj:section_name(), "_mine_trap_") then
            if range_min == nil and range_max == nil then
               remove_object_by_id(obj.id)
            elseif range_min ~= nil and range_max == nil then
               if db.actor:position():distance_to(obj.position) >= range_min then
                  remove_object_by_id(obj.id)
               end
            elseif range_min == nil and range_max ~= nil then
               if db.actor:position():distance_to(obj.position) <= range_max then
                  remove_object_by_id(obj.id)
               end
            elseif range_min ~= nil and range_max ~= nil then
               if db.actor:position():distance_to(obj.position) >= range_min and db.actor:position():distance_to(obj.position) <= range_max then
                  remove_object_by_id(obj.id)
               end
            end
         end
      end
   elseif victim_type == "weapon" then
      for a = 1, 65534 do
         local obj = alife():object(a)
         local obj_logic = obj:spawn_ini()
         if obj and obj:section_name() ~= nil and (find_in_string(obj:section_name(), "wpn_") or find_in_string(obj:section_name(), "grenade")) and ((obj_logic == nil) or (obj_logic ~= nil and not spawn_ini:section_exist("secret"))) and get_object_story_id(obj.id) == nil and (level.object_by_id(obj.id) == nil or level.object_by_id(obj.id):parent() == nil) and (get_weapon_type(obj:section_name()) == "grenade" or get_weapon_type(obj:section_name()) == "rifle" or get_weapon_type(obj:section_name()) == "pistol" or get_weapon_type(obj:section_name()) == "shotgun") then
            if range_min == nil and range_max == nil then
               remove_object_by_id(obj.id)
            elseif range_min ~= nil and range_max == nil then
               if db.actor:position():distance_to(obj.position) >= range_min then
                  remove_object_by_id(obj.id)
               end
            elseif range_min == nil and range_max ~= nil then
               if db.actor:position():distance_to(obj.position) <= range_max then
                  remove_object_by_id(obj.id)
               end
            elseif range_min ~= nil and range_max ~= nil then
               if db.actor:position():distance_to(obj.position) >= range_min and db.actor:position():distance_to(obj.position) <= range_max then
                  remove_object_by_id(obj.id)
               end
            end
         end
      end
   end
end

-- 'Пометить на карте все обьекты с указанной секцией.
function reveal_objects_by_section(find_string)
   for a = 1, 65534 do
      local obj = alife():object(a)
      if obj then
         if obj:section_name() ~= nil and string.find(obj:section_name(), find_string) then
            local sect = obj:section_name()
            add_spot_on_map(obj.id, sgm_flags.spot_toolkit_place, obj:section_name())
            --debug_to_file("on_take_item_from_box.txt",obj:name())
         end
      end
   end
end

-- 'Пометить на карте все обьекты с указанным именем.
function reveal_objects_by_name(find_string)
   for a = 1, 65534 do
      local obj = alife():object(a)
      if obj then
         if obj:name() ~= nil and string.find(obj:name(), find_string) then
            local sect = obj:name()
            add_spot_on_map(obj.id, sgm_flags.spot_toolkit_place, obj:name())
         end
      end
   end
end

-- 'Скрыть все обьекты с указанной секцией.
function hide_spot_by_section(find_string, location_name)
   for a = 1, 65534 do
      local obj = alife():object(a)
      if obj then
         if obj:section_name() ~= nil and string.find(obj:section_name(), find_string) then
            set_spot_choose(obj.id, location_name, "hide")
         end
      end
   end
end

-- 'Скрыть все обьекты с указанным именем.
function hide_radius_spot_by_section(find_string, location_name, radius_value)
   for a = 1, 65534 do
      local obj = alife():object(a)
      if obj then
         if obj:section_name() ~= nil and string.find(obj:section_name(), find_string) and distance_between_safe(db.actor, level.object_by_id(obj.id)) <= radius_value then
            set_spot_choose(obj.id, location_name, "hide")
         end
      end
   end
end

-- 'Удалить все обьекты с указанной секцией.
function release_objects_by_section(find_string)
   for a = 1, 65534 do
      local obj = alife():object(a)
      if obj then
         if obj:section_name() ~= nil and string.find(obj:section_name(), find_string) then
            local sect = obj:section_name()
            remove_object_by_id(obj.id)
         end
      end
   end
end

-- 'Удалить все обьекты с указанным именем.
function release_objects_by_name(find_string)
   for a = 1, 65534 do
      local obj = alife():object(a)
      if obj then
         if obj:name() ~= nil and string.find(obj:name(), find_string) then
            local sect = obj:name()
            remove_object_by_id(obj.id)
         end
      end
   end
end

------------------------------------------------------------------------------
--                       Работа с дистанцией                                --
------------------------------------------------------------------------------
-- 'Дистанция до обьекта.
function distance_to_object(obj, type, dist_value, absence_parent)
   local currert_distance = db.actor:position():distance_to(obj:position())
   if ((type == "<=" and currert_distance <= dist_value) or (type == "<" and currert_distance < dist_value) or (type == ">=" and currert_distance >= dist_value) or (type == ">" and currert_distance > dist_value) or (type == "==" and currert_distance < dist_value)) and ((absence_parent == nil) or (absence_parent ~= nil and absence_parent == false and obj:parent() ~= nil) or (absence_parent ~= nil and absence_parent == true and obj:parent() == nil)) then
      return true
   end
   return false
end

-- 'Дистанция до обьекта. В квадратных метрах.
function distance_to_sqr_object(obj, type, dist_value, absence_parent)
   local currert_distance = db.actor:position():distance_to_sqr(obj:position())
   if ((type == "<=" and currert_distance <= dist_value) or (type == "<" and currert_distance < dist_value) or (type == ">=" and currert_distance >= dist_value) or (type == ">" and currert_distance > dist_value) or (type == "==" and currert_distance < dist_value)) and ((absence_parent == nil) or (absence_parent ~= nil and absence_parent == false and obj:parent() ~= nil) or (absence_parent ~= nil and absence_parent == true and obj:parent() == nil)) then
      return true
   end
   return false
end

-- 'Контрольная зона телепорта.
function make_teleport_control_zone(nx, ny, nz, nlv, ngv, ndist, tx, ty, tz, dir_h, g_info)
   if sgm_flags.bool_travel_level_change ~= true and db.actor:position():distance_to(vector():set(nx, ny, nz), nlv, ngv) <= ndist then
      db.actor:set_actor_position(vector():set(tx, ty, tz))
      if dir_h ~= nil then db.actor:set_actor_direction(-dir_h) end
      if g_info ~= nil then give_info(g_info) end
   end
end

-- 'ГГ в зоне рестриктора.
function actor_in_restrictor(zone_name)
   local zone = db.zone_by_name[zone_name]
   return utils.npc_in_zone(db.actor, zone)
end

-- 'ГГ не в зоне рестриктора.
function actor_out_restrictor(zone_name)
   local zone = db.zone_by_name[zone_name]
   if zone == nil then
      return false
   end
   return not utils.npc_in_zone(db.actor, db.zone_by_name[zone_name])
end

------------------------------------------------------------------------------
--                      Работа с отношениями                                --
------------------------------------------------------------------------------
-- 'Чтение текущего отношения ГГ к группировке.
function get_actor_relation_to(to_community)
   return relation_registry.community_relation(db.actor:character_community(), to_community) +
       db.actor:community_goodwill(to_community)
end

-- 'Улучшить отношения между группировкой и ГГ.
function increase_faction_goodwill(community, value)
   game_relations.change_factions_community_num(community, db.actor:id(), tonumber(value))
end

-- 'Ухудшить отношения между группировкой и ГГ.
function decrease_faction_goodwill(community, value)
   game_relations.change_factions_community_num(community, db.actor:id(), -tonumber(value))
end

-- 'Улучшить отношения между группировкой и обьектом.
function increase_faction_goodwill_to(obj_id, community, value)
   game_relations.change_factions_community_num(community, obj_id, tonumber(value))
end

-- 'Ухудшить отношения между группировкой и обьектом.
function decrease_faction_goodwill_to(obj_id, community, value)
   game_relations.change_factions_community_num(community, obj_id, -tonumber(value))
end

-- 'Установка отношений одной группировки к другой.
function set_faction_to_faction_relation(from_faction, to_faction, type_relation, double_effect)
   local relation_value = 0
   if type_relation == "enemy" or type_relation == "e" then
      relation_value = -5000
   elseif type_relation == "neutral" or type_relation == "n" then
      relation_value = 0
   elseif type_relation == "friend" or type_relation == "f" then
      relation_value = 5000
   end
   relation_registry.set_community_relation(from_faction, to_faction, relation_value)
   if double_effect == true then
      relation_registry.set_community_relation(to_faction, from_faction, relation_value)
   end
end

-- 'Установка отношений одного обьекта к другому.
function set_relation_between(obj1, obj2, type)
   if type == nil or type == "enemy" or type == "e" then
      obj1:set_relation(game_object.enemy, obj2)
   elseif type == "friend" or type == "f" then
      obj1:set_relation(game_object.friend, obj2)
   elseif type == "neutral" or type == "n" then
      obj1:set_relation(game_object.neutral, obj2)
   end
end

-- 'Чтение отношений одного обьекта к другому.
function check_relation_between(obj1, obj2)
   local relation = "neutral"
   if IsStalker(obj1) then
      if obj1:relation(obj2) == game_object.friend then
         relation = "friend"
      elseif obj1:relation(obj2) == game_object.neutral then
         relation = "neutral"
      elseif obj1:relation(obj2) == game_object.enemy then
         relation = "enemy"
      else
         relation = "enemy"
      end
   elseif IsMonster(obj1) then
      if obj2:relation(obj1) == game_object.friend then
         relation = "friend"
      elseif obj2:relation(obj1) == game_object.neutral then
         relation = "neutral"
      elseif obj2:relation(obj1) == game_object.enemy then
         relation = "enemy"
      else
         relation = "enemy"
      end
   end
   return relation
end

------------------------------------------------------------------------------
--                       Функции CUIWindow                                  --
------------------------------------------------------------------------------
function CUI_show_item_icon(icon_source, item_section)
   if icon_source ~= nil and item_section ~= nil then
      local rx = read_number(item_section, "inv_grid_x") * 50
      local ry = read_number(item_section, "inv_grid_y") * 50
      local rw = read_number(item_section, "inv_grid_width") * 50
      local rh = read_number(item_section, "inv_grid_height") * 50
      icon_source:Show(true)
      icon_source:InitTexture("ui\\ui_icon_equipment")
      icon_source:SetTextureRect(Frect():set(rx, ry, rx + rw, ry + rh))
   end
end

------------------------------------------------------------------------------
--                           Чтение .LTX                                    --
------------------------------------------------------------------------------
function read_number(section, param, ini_path)
   local ltx_ini = system_ini()
   if ini_path ~= nil and ini_path ~= "nil" then
      ltx_ini = ini_file(ini_path)
   end
   if ltx_ini:line_exist(section, param) then
      return ltx_ini:r_float(section, param)
   else
      return "nil"
   end
end

function read_string(section, param, ini_path)
   local ltx_ini = system_ini()
   if ini_path ~= nil and ini_path ~= "nil" then
      ltx_ini = ini_file(ini_path)
   end
   if ltx_ini:line_exist(section, param) then
      return ltx_ini:r_string(section, param)
   else
      return "nil"
   end
end

function read_boolean(section, param, ini_path)
   local ltx_ini = system_ini()
   if ini_path ~= nil and ini_path ~= "nil" then
      ltx_ini = ini_file(ini_path)
   end
   if ltx_ini:line_exist(section, param) then
      return ltx_ini:r_bool(section, param)
   else
      return "nil"
   end
end

------------------------------------------------------------------------------
--                        Чтение опций мода                                 --
------------------------------------------------------------------------------
-- 'Фунция чтения параметров с конфигов.
function get_params_by_section(ini_name, section, val_type, target_string, default_value, use_action)
   local ini, line = ini_file(ini_name), section
   if val_type == "number" then
      if ini:line_exist(line, target_string) then
         if use_action == nil or use_action == "nil" then
            return ini:r_float(line, target_string)
         elseif use_action == "floor" then
            return ini:r_float(line, target_string) / 100
         elseif use_action == "multiply" then
            return ini:r_float(line, target_string) * 100
         end
      else
         if use_action == nil or use_action == "nil" then
            return default_value
         elseif use_action == "floor" then
            return default_value / 100
         elseif use_action == "multiply" then
            return default_value * 100
         end
      end
   elseif val_type == "string" then
      if ini:line_exist(line, target_string) then
         if use_action == nil or use_action == "nil" then
            return ini:r_string(line, target_string)
         elseif use_action == "floor" then
            return ini:r_string(line, target_string) / 100
         elseif use_action == "multiply" then
            return ini:r_string(line, target_string) * 100
         end
      else
         if use_action == nil or use_action == "nil" then
            return default_value
         elseif use_action == "floor" then
            return default_value / 100
         elseif use_action == "multiply" then
            return default_value * 100
         end
      end
   elseif val_type == "bool" then
      if ini:line_exist(line, target_string) then
         if use_action == nil or use_action == "nil" then
            return ini:r_bool(line, target_string)
         elseif use_action == "floor" then
            return ini:r_bool(line, target_string) / 100
         elseif use_action == "multiply" then
            return ini:r_bool(line, target_string) * 100
         end
      else
         if use_action == nil or use_action == "nil" then
            return default_value
         elseif use_action == "floor" then
            return default_value / 100
         elseif use_action == "multiply" then
            return default_value * 100
         end
      end
   else
      return 0
   end
end

-- 'Считывать главные опции.
function r_mod_params(val_type, target_string, default_value, use_action)
   return get_params_by_section("mod_parameters\\mod_params.ltx", "mod_params", val_type, target_string, default_value,
      use_action)
end

-- 'Считывать опции отрядов Альфы.
function r_alfa_params(val_type, target_string, default_value, use_action)
   return get_params_by_section("mod_parameters\\mod_params.ltx", "alfa_params", val_type, target_string, default_value,
      use_action)
end

-- 'Считывать опции ранговой системы.
function r_rank_params(val_type, target_string, default_value, use_action)
   return get_params_by_section("mod_parameters\\mod_params.ltx", "rank_params", val_type, target_string, default_value,
      use_action)
end

-- 'Считывать опции трофеев.
function r_booty_params(val_type, target_string, default_value, use_action)
   return get_params_by_section("mod_parameters\\mod_params.ltx", "booty_params", val_type, target_string, default_value,
      use_action)
end

-- 'Считывать опции квестов.
function r_quest_params(val_type, target_string, default_value, use_action)
   return get_params_by_section("mod_parameters\\mod_params.ltx", "quest_params", val_type, target_string, default_value,
      use_action)
end

------------------------------------------------------------------------------
--                          Использование предметов                         --
------------------------------------------------------------------------------
-- 'Использование предмета ГГ-м.
function eat_item(item_name, with_news)
   if db.actor:object(item_name) then
      db.actor:eat(db.actor:object(item_name))
      if with_news == true then
         news_manager.send_tip(db.actor, sgm_functions.ReadCaption(item_name), 0, "got_medicine", 2000, nil,
            "st_item_used")
      end
   end
end

-- 'Автоматическое использование предмета, с выдачей сообщения о причине расходования.
function automatic_use(item_name, effect_type)
   local effect_descr
   db.actor:eat(db.actor:object(item_name))
   if effect_type == "is_bleeding" then
      effect_descr = game.translate_string("st_automatic_vs_bleeding")
   elseif effect_type == "is_health" then
      effect_descr = game.translate_string("st_automatic_vs_health")
   elseif effect_type == "is_psy_health" then
      effect_descr = game.translate_string("st_automatic_vs_psy_health")
   elseif effect_type == "is_radiation" then
      effect_descr = game.translate_string("st_automatic_vs_radiation")
   end
   news_manager.send_tip(db.actor,
      effect_descr ..
      " " ..
      game.translate_string("st_used_item_descr") .. " " .. game.translate_string(sgm_functions.ReadCaption(item_name)),
      0, "can_resupply", 2000, nil, "st_automatic_use_title", false)
end

-- 'Заставить ГГ спрятать оружие во время использования предмета.
function set_item_activation(val)
   start_flague_timer("timer_item_activation", val)
end

------------------------------------------------------------------------------
--                            Работа с аномалиями                           --
------------------------------------------------------------------------------
-- 'Выключить аномалию.
function anomaly_turn_off(a_name)
   local anomal_zone = db.anomaly_by_name[a_name]
   if anomal_zone == nil then
      return
   end
   anomal_zone:turn_off()
end

-- 'Включить аномалию.
function anomaly_turn_on(a_name)
   local anomal_zone = db.anomaly_by_name[a_name]
   if anomal_zone == nil then
      return
   end
   if anomal_zone then
      anomal_zone:turn_on(true)
   end
end

------------------------------------------------------------------------------
--                        Проверка и обработка обьектов                     --
------------------------------------------------------------------------------
-- 'Обьект живой.
function object_alive(victim)
   if victim:alive() == true then
      return true
   end
   return false
end

-- 'Обьект живой.
function object_exists(obj, is_live)
   return level.present() and obj ~= nil and
       (is_live == false or ((is_live == nil or is_live == true) and obj:alive() == true))
end

-- 'Обьект находится в online.
function object_online(victim)
   if victim ~= nil then
      local obj = alife():object(victim:id())
      if obj then
         if obj.online then
            return true
         else
            return false
         end
      end
   end
   return false
end

-- 'SID обьект является врагом для ГГ.
function sid_thinks_that_actor_is_enemy(npc_sid)
   local soid = get_story_object_id(npc_sid)
   return soid ~= nil and level.object_by_id(soid) ~= nil and
       check_relation_between(level.object_by_id(soid), db.actor) == "enemy"
end

-- 'SID обьект есть, и он уже погиб.
function sid_is_dead(npc_sid)
   local soid = get_story_object_id(npc_sid)
   return soid ~= nil and level.object_by_id(soid) ~= nil and level.object_by_id(soid):alive() == false
end

-- 'SID обьект есть, и он online.
function get_sid_online(sid_name)
   return get_story_object_id(sid_name) ~= nil and level.object_by_id(get_story_object_id(sid_name)) ~= nil
end

-- 'Существует ли обьект с SID.
function story_id_exists(sid_name)
   return get_story_object_id(sid_name) ~= nil
end

-- 'Обьекта с SID нет.
function story_id_not_found(sid_name)
   return not get_story_object_id(sid_name)
end

-- 'Перевести объект в онлайн.
function object_switch_online(npc_id)
   local sim = alife()
   if sim == nil then return true end
   sim:set_switch_online(npc_id, true)
   sim:set_switch_offline(npc_id, false)
end

-- 'Перевести объект в оффлайн.
function object_switch_offline(npc_id)
   local sim = alife()
   if sim == nil then return true end
   sim:set_switch_online(npc_id, false)
   sim:set_switch_offline(npc_id, true)
end

------------------------------------------------------------------------------
--                            Работа со временем                            --
------------------------------------------------------------------------------
-- 'Проверка секундного таймера с коллбеком.
function check_seconds(name)
   if name == 1 then
      name = "one"
   elseif name == 2 then
      name = "two"
   elseif name == 3 then
      name = "three"
   elseif name == 4 then
      name = "four"
   elseif name == 5 then
      name = "fifth"
   elseif name == 10 then
      name = "ten"
   elseif name == 20 then
      name = "twenty"
   elseif name == 30 then
      name = "thirty"
   elseif name == 40 then
      name = "fourty"
   elseif name == 50 then
      name = "fifty"
   end
   return sgm_flags["timer_" .. name .. "_seconds"] == 0
end

-- 'Проверка пропущенного интервала времени. Для специальных условий.
function check_difference_missed_time(need_time_h, need_time_m, variable_name)
   if sgm_flags.table_mod_utils["on_forward_game_time_saved"] ~= nil and sgm_flags.table_mod_utils["on_forward_game_time_loaded"] ~= nil then
      if sgm_flags.table_mod_utils["forward_game_closed" .. variable_name] == nil then
         sgm_flags.table_mod_utils["forward_game_closed" .. variable_name] = "false"
      end
      if sgm_flags.table_mod_utils["forward_game_closed" .. variable_name] == "false" then
         local dif_time = get_general_game_time(nil, need_time_h, need_time_m) >
             sgm_flags.table_mod_utils["on_forward_game_time_saved"] and
             get_general_game_time(nil, need_time_h, need_time_m) <
             sgm_flags.table_mod_utils["on_forward_game_time_loaded"]
         if dif_time then
            return true
         end
      end
   else
      if sgm_flags.table_mod_utils["forward_game_closed" .. variable_name] ~= nil then
         sgm_flags.table_mod_utils["forward_game_closed" .. variable_name] = nil
      end
   end
   return false
end

-- 'Использование пропущенного интервала времени. Для специальных условий.
function use_difference_missed_time(variable_name)
   if sgm_flags.table_mod_utils["on_forward_game_time_saved"] ~= nil and sgm_flags.table_mod_utils["on_forward_game_time_loaded"] ~= nil then
      sgm_flags.table_mod_utils["forward_game_closed" .. variable_name] = "true"
   end
end

-- 'Пройденное игровое время, с момента начала игры.
function get_general_game_time(n_day, n_hour, n_minute, accuracy)
   local time_result = (level.get_time_days() * 60 * 24 + level.get_time_hours() * 60 + level.get_time_minutes()) - 1440
   if n_day ~= nil and n_hour == nil and n_minute == nil then
      time_result = n_day * 60 * 24 + level.get_time_hours() * 60 +
          level.get_time_minutes()
   end
   if n_day ~= nil and n_hour ~= nil and n_minute == nil then
      time_result = n_day * 60 * 24 + n_hour * 60 +
          level.get_time_minutes()
   end
   if n_day == nil and n_hour == nil and n_minute ~= nil then
      time_result = level.get_time_days() * 60 * 24 +
          level.get_time_hours() * 60 + n_minute
   end
   if n_day == nil and n_hour ~= nil and n_minute ~= nil then
      time_result = level.get_time_days() * 60 * 24 + n_hour * 60 +
          n_minute
   end
   if n_day ~= nil and n_hour ~= nil and n_minute ~= nil then time_result = n_day * 60 * 24 + n_hour * 60 + n_minute end
   if accuracy == true then
      return time_result
   else
      return GetUntilGameTime() + time_result
   end
end

-- 'Перемотка времени.
function refresh_game_time(hours, minutes)
   if hours == nil then hours = 0 end
   if minutes == nil then minutes = 0 end
   sgm_callbacks.on_forward_game_time(hours, minutes)
   level.change_game_time(0, hours, minutes)
   level_weathers.get_weather_manager():forced_weather_change()
   surge_manager.get_surge_manager().time_forwarded = true
end

-- 'Текущее игровое время.
function get_parsed_time()
   local minutes_time = level.get_time_minutes()
   local hours_time = level.get_time_hours()
   if level.get_time_minutes() >= 0 and level.get_time_minutes() <= 9 then
      data = hours_time .. ":" .. "0" .. minutes_time
   end
   if level.get_time_minutes() >= 10 and level.get_time_minutes() <= 59 then
      data = hours_time .. ":" .. minutes_time
   end
   if level.get_time_minutes() >= 0 and level.get_time_minutes() <= 9 and level.get_time_hours() >= 0 and level.get_time_hours() < 10 then
      data = "0" .. hours_time .. ":" .. "0" .. minutes_time
   end
   if level.get_time_minutes() >= 10 and level.get_time_minutes() <= 59 and level.get_time_hours() >= 0 and level.get_time_hours() < 10 then
      data = "0" .. hours_time .. ":" .. minutes_time
   end
   return data
end

-- 'Значение смены месяца.
function GetUntilGameTime()
   if read_mod_param("until_game_time") ~= nil then
      return read_mod_param("until_game_time")
   else
      return 0
   end
end

-- 'Стандартный тайм фактор.
function DefaultTimeFactor()
   local ltx = system_ini()
   if ltx:line_exist("alife", "time_factor") then
      return ltx:r_float("alife", "time_factor")
   else
      return 8
   end
end

-- 'Проверка ночного времени суток.
function present_night()
   if level.get_time_hours() < 6 or level.get_time_hours() >= 22 then
      return true
   else
      return false
   end
end

-- 'Проверка дневного времени суток.
function present_day()
   if level.get_time_hours() < 6 or level.get_time_hours() >= 22 then
      return false
   else
      return true
   end
end

function start_game_timer(name, value, format)
   if format == "d" or format == "days" then
      write_mod_param(name, get_general_game_time() + ((60 * 24) * value))
   elseif format == "h" or format == "hours" then
      write_mod_param(name, get_general_game_time() + (value * 60))
   else
      write_mod_param(name, get_general_game_time() + value)
   end
end

-- 'Проверка таймера в игровом времени.
function check_game_timer(name, ret_val)
   if ret_val == true then
      if read_mod_param(name) ~= nil then
         return read_mod_param(name)
      end
   end
   if read_mod_param(name) ~= nil and read_mod_param(name) <= get_general_game_time() then
      return true
   elseif read_mod_param(name) == nil then
      return nil
   end
   return false
end

-- 'Очистка таймера в игровом времени.
function abort_game_timer(name)
   if read_mod_param(name) ~= nil then
      clear_mod_param(name)
   end
end

-- 'Старт таймера в реальном времени. Пример:
-- '   if check_real_timer("имя таймера")==nil then
-- '      start_real_timer("имя таймера",1)
-- '   elseif check_real_timer("имя таймера") then
-- '      действие, если таймер истек
-- '      start_real_timer("имя таймера",1) --/Продолжаем таймер.
-- '   end
function start_real_timer(name, value, format)
   local calculate_value
   value = value * 1000
   if format == "d" or format == "days" then
      calculate_value = time_global() + ((60 * 60 * 24) * value)
   elseif format == "h" or format == "hours" then
      calculate_value = time_global() + ((60 * 60) * value)
   elseif format == "m" or format == "minutes" then
      calculate_value = time_global() + (value * 60)
   else
      calculate_value = math.floor(time_global() + value)
   end
   write_mod_param(name, calculate_value)
end

-- 'Проверка таймера в игровом времени.
function check_real_timer(name, ret_val)
   if ret_val == true then
      if read_mod_param(name) ~= nil then
         local countdown = math.floor((read_mod_param(name) - time_global()) * 0.001)
         if countdown >= 0 then
            return countdown
         else
            return 0
         end
      end
   end
   if read_mod_param(name) ~= nil and read_mod_param(name) <= time_global() then
      return true
   elseif read_mod_param(name) == nil then
      return nil
   end
   return false
end

-- 'Очистка таймера в игровом времени.
function abort_real_timer(name)
   if read_mod_param(name) ~= nil then
      clear_mod_param(name)
   end
end

-- 'Старт флагового таймера в реальном времени. Пример:
-- '   if check_flague_timer("название флага таймера")==nil then
-- '      start_flague_timer("название флага таймера",1000)
-- '   elseif check_flague_timer("название флага таймера") then
-- '      действие, если таймер истек
-- '      start_flague_timer("название флага таймера",1000) --/Продолжаем таймер.
-- '   end
-- 'Запуск флагового таймера. В реальном времени.
function start_flague_timer(flag_name, ms_val)
   sgm_flags[flag_name] = time_global() + ms_val
end

-- 'Обнуление флагового таймера.
function abort_flague_timer(flag_name)
   sgm_flags[flag_name] = 0
end

-- 'Проверка флагового таймера.
function check_flague_timer(flag_name)
   if sgm_flags[flag_name] ~= nil and sgm_flags[flag_name] ~= 0 and time_global() >= sgm_flags[flag_name] then
      return true
   elseif sgm_flags[flag_name] == nil then
      return nil
   end
   return false
end

-- 'Контроль над флаговым таймером.
function run_flague_timer(flag_name, type, extra_val)
   if type == 2 then
      if sgm_flags[flag_name] ~= 0 and sgm_flags[flag_name] ~= 1 then
         if time_global() >= sgm_flags[flag_name] then
            sgm_flags[flag_name] = 1
         end
      end
   elseif type == 3 then
      if sgm_flags[flag_name] == 0 then
         if extra_val == nil then extra_val = 1000 end
         sgm_flags[flag_name] = time_global() + extra_val
      end
   else
      if sgm_flags[flag_name] ~= 0 then
         if time_global() >= sgm_flags[flag_name] then
            sgm_flags[flag_name] = 0
         end
      end
   end
end

------------------------------------------------------------------------------
--                           Контроль событий                               --
------------------------------------------------------------------------------
-- 'Активация потери сознания, из-за недосыпания.
function activate_approach_sleep()
   sgm_flags.bool_approach_sleep = true
end

--= Активны ли в данный момент: =--
-- 'Затмение
function check_is_black_day()
   return has_alife_info("blackday_is_active")
end

-- 'Выброс
function check_is_surge_day()
   return has_alife_info("vibros_is_active")
end

-- 'Лимит сна
function check_is_dream_limited()
   return read_mod_param("dream_limited") ~= nil and read_mod_param("dream_limited") ~= "none"
end

-- 'Принудительное засыпание
function check_is_approach_sleep()
   return sgm_flags.bool_approach_sleep
end

-- 'Аура бездействия ГГ
function check_is_aura_inactivity()
   return sgm_flags.bool_aura_inactivity_inc
end

-- 'Чит режимы
function check_is_cheats_mode()
   return has_alife_info("opt_activate_immortal") or has_alife_info("opt_activate_power") or
       has_alife_info("opt_activate_bleeding") or has_alife_info("opt_activate_repair") or
       has_alife_info("opt_activate_ammo")
end

-- 'Воспроизведение в МП-3 плеере
function check_is_mp3_playing()
   return sgm_ui_mod_elements.mp3_obj ~= nil and sgm_ui_mod_elements.mp3_obj:playing()
end

-- 'Вербовка мутанта
function check_is_capture_meal()
   return has_alife_info("capture_meal_active")
end

-- 'Проверка на разрешение затмений.
function get_blackday_frequency(f_o_s, e_type)
   local g_ini = ini_file("misc\\config_blackday.ltx")
   local g_settings = "settings"
   local g_frequency = sgm_functions.check_section_comma(g_ini, g_settings, "frequency_default", "840,1440", 2)
   if e_type == "start" then
      g_frequency = sgm_functions.check_section_comma(g_ini, g_settings, "frequency_start", "240,660", 2)
   elseif e_type == "night" then
      g_frequency = sgm_functions.check_section_comma(g_ini, g_settings, "frequency_night", "240,700", 2)
   end
   if f_o_s == 1 then
      return tonumber(g_frequency[1])
   else
      return tonumber(g_frequency[2])
   end
end

-- 'Проверка на разрешение затмений.
function check_blackday_precond()
   local g_ini = ini_file("misc\\config_blackday.ltx")
   local g_settings = "settings"
   local g_condlist = to_string(sgm_functions.check_section_condlist(g_ini, g_settings, "condlist", "false"))
   if g_condlist == "true" then
      return true
   end
   return false
end

-- 'Активация дневного затмения.
function blackday_activate()
   if level.get_time_hours() >= 7 and level.get_time_hours() <= 21 then
      disable_info("opt_deactivate_blackday")
      write_mod_param("blackday_stage", "step_end")
      start_game_timer("blackday_main_timer", 0)
   end
end

-- 'Активация спауна артефактов без затмения.
function blackday_birth_activate()
   sgm_blackday.get_black_day():blackday_birth()
end

------------------------------------------------------------------------------
--             Обработка данных с менеджера сохранения/загрузки             --
------------------------------------------------------------------------------
-- 'Возвращение значения счетчика статистики.
function get_statistic_counter(type, counter_name)
   if type == "k_m" then
      if sgm_save.statistic_killed_monsters[counter_name] ~= nil then
         return sgm_save.statistic_killed_monsters[counter_name]
      end
   elseif type == "k_s" then
      if sgm_save.statistic_killed_stalkers[counter_name] ~= nil then
         return sgm_save.statistic_killed_stalkers[counter_name]
      end
   end
   return nil
end

-- 'Редактирование счетчиков статистики.
function edit_statistic_counter(type, counter_name, value, action)
   if value == nil then value = 1 end
   if action == nil then action = "+" end
   if type == "k_m" then
      if action == "+" then
         sgm_save.statistic_killed_monsters[counter_name] = sgm_save.statistic_killed_monsters[counter_name] + value
      else
         sgm_save.statistic_killed_monsters[counter_name] = sgm_save.statistic_killed_monsters[counter_name] - value
      end
   elseif type == "k_s" then
      if action == "+" then
         sgm_save.statistic_killed_stalkers[counter_name] = sgm_save.statistic_killed_stalkers[counter_name] + value
      else
         sgm_save.statistic_killed_stalkers[counter_name] = sgm_save.statistic_killed_stalkers[counter_name] - value
      end
   end
end

-- 'Возвращение текущего предмета заказа для торговца.
function get_trader_order(trader_name)
   if sgm_save.trader_orders[trader_name] ~= nil and sgm_save.trader_orders[trader_name] ~= "none" then
      return sgm_save.trader_orders[trader_name]
   end
   return nil
end

-- 'Возвращение текущего времени заказа для торговца.
function get_trader_order_time(trader_name)
   if sgm_save.trader_orders[trader_name .. "_t"] ~= nil and sgm_save.trader_orders[trader_name .. "_t"] ~= 0 and get_general_game_time() >= sgm_save.trader_orders[trader_name .. "_t"] then
      return true
   end
   return false
end

-- 'Установка текущего предмета заказа для торговца.
function edit_trader_order(trader_name, order_item)
   if sgm_save.trader_orders[trader_name] == nil then return end
   if sgm_save.trader_orders[trader_name] ~= order_item then
      sgm_save.trader_orders[trader_name] = order_item
   end
end

-- 'Установка текущего времени заказа для торговца.
function edit_trader_order_time(trader_name, time_minutes)
   if sgm_save.trader_orders[trader_name .. "_t"] == nil then return end
   if sgm_save.trader_orders[trader_name .. "_t"] ~= nil then
      if time_minutes == -1 then
         sgm_save.trader_orders[trader_name .. "_t"] = 0
      else
         sgm_save.trader_orders[trader_name .. "_t"] = get_general_game_time() + time_minutes
      end
   end
end

------------------------------------------------------------------------------
--                           Работа с флагами                               --
------------------------------------------------------------------------------
-- 'Просмотр значения флага.
function get_flag_value(param)
   return sgm_flags[param]
end

-- 'Установка значения флага.
function set_flag_value(param, value)
   sgm_flags[param] = value
end

-- 'Исправление значения флага.
function change_flag_value(param, value)
   if sgm_flags[param] ~= value then
      sgm_flags[param] = value
   end
end

-- 'Исправление значения табличного флага.
function change_tbl_flag_value(param1, param2, value)
   if sgm_flags[param1][param2] ~= value then
      sgm_flags[param1][param2] = value
   end
end

------------------------------------------------------------------------------
--                           Выдача чего-либо                               --
------------------------------------------------------------------------------
-- 'Выдача случайного тайника оригинальной игры.
local treasure_with_zaton = { "zat_hiding_place_1", "zat_hiding_place_2", "zat_hiding_place_3", "zat_hiding_place_4",
   "zat_hiding_place_5", "zat_hiding_place_6", "zat_hiding_place_7", "zat_hiding_place_8", "zat_hiding_place_9",
   "zat_hiding_place_10", "zat_hiding_place_11", "zat_hiding_place_12", "zat_hiding_place_13", "zat_hiding_place_14",
   "zat_hiding_place_15", "zat_hiding_place_16", "zat_hiding_place_17", "zat_hiding_place_18", "zat_hiding_place_19",
   "zat_hiding_place_20", "zat_hiding_place_21", "zat_hiding_place_22", "zat_hiding_place_23", "zat_hiding_place_24",
   "zat_hiding_place_25", "zat_hiding_place_26", "zat_hiding_place_27", "zat_hiding_place_28", "zat_hiding_place_29",
   "zat_hiding_place_30", "zat_hiding_place_31", "zat_hiding_place_32", "zat_hiding_place_33", "zat_hiding_place_34",
   "zat_hiding_place_35", "zat_hiding_place_36", "zat_hiding_place_37", "zat_hiding_place_38", "zat_hiding_place_39",
   "zat_hiding_place_40", "zat_hiding_place_41", "zat_hiding_place_42", "zat_hiding_place_43", "zat_hiding_place_44",
   "zat_hiding_place_45", "zat_hiding_place_46", "zat_hiding_place_47", "zat_hiding_place_48", "zat_hiding_place_49",
   "zat_hiding_place_50", "zat_hiding_place_51", "zat_hiding_place_52", "zat_hiding_place_53", "zat_hiding_place_54",
   "zat_hiding_place_55" }
local treasure_with_jupiter = { "jup_hiding_place_1", "jup_hiding_place_2", "jup_hiding_place_3", "jup_hiding_place_4",
   "jup_hiding_place_5", "jup_hiding_place_6", "jup_hiding_place_7", "jup_hiding_place_8", "jup_hiding_place_9",
   "jup_hiding_place_10", "jup_hiding_place_11", "jup_hiding_place_12", "jup_hiding_place_13", "jup_hiding_place_14",
   "jup_hiding_place_15", "jup_hiding_place_16", "jup_hiding_place_17", "jup_hiding_place_18", "jup_hiding_place_19",
   "jup_hiding_place_20", "jup_hiding_place_21", "jup_hiding_place_22", "jup_hiding_place_23", "jup_hiding_place_24",
   "jup_hiding_place_25", "jup_hiding_place_26", "jup_hiding_place_27", "jup_hiding_place_28", "jup_hiding_place_29",
   "jup_hiding_place_30", "jup_hiding_place_31", "jup_hiding_place_32", "jup_hiding_place_33", "jup_hiding_place_34",
   "jup_hiding_place_35", "jup_hiding_place_36", "jup_hiding_place_37", "jup_hiding_place_38", "jup_hiding_place_39",
   "jup_hiding_place_40", "jup_hiding_place_41", "jup_hiding_place_42", "jup_hiding_place_43", "jup_hiding_place_44",
   "jup_hiding_place_45", "jup_hiding_place_46", "jup_hiding_place_47", "jup_hiding_place_48", "jup_hiding_place_49",
   "jup_hiding_place_50" }
local treasure_with_pripyat = { "pri_hiding_place_1", "pri_hiding_place_2", "pri_hiding_place_3", "pri_hiding_place_4",
   "pri_hiding_place_5", "pri_hiding_place_6", "pri_hiding_place_7", "pri_hiding_place_8", "pri_hiding_place_9",
   "pri_hiding_place_10", "pri_hiding_place_11", "pri_hiding_place_12", "pri_hiding_place_13", "pri_hiding_place_14",
   "pri_hiding_place_15", "pri_hiding_place_16", "pri_hiding_place_17", "pri_hiding_place_18", "pri_hiding_place_19",
   "pri_hiding_place_20", "pri_hiding_place_21", "pri_hiding_place_22", "pri_hiding_place_23", "pri_hiding_place_24",
   "pri_hiding_place_25", "pri_hiding_place_26", "pri_hiding_place_27", "pri_hiding_place_28", "pri_hiding_place_29",
   "pri_hiding_place_30", "pri_hiding_place_31" }
local treasure_with_darkvalley = { "val_hiding_place_1", "val_hiding_place_2", "val_hiding_place_3", "val_hiding_place_4",
   "val_hiding_place_5", "val_hiding_place_6", "val_hiding_place_7", "val_hiding_place_8", "val_hiding_place_9",
   "val_hiding_place_10", "val_hiding_place_11", "val_hiding_place_12", "val_hiding_place_13", "val_hiding_place_14",
   "val_hiding_place_15", "val_hiding_place_16", "val_hiding_place_17", "val_hiding_place_18", "val_hiding_place_19",
   "val_hiding_place_20", "val_hiding_place_21", "val_hiding_place_22", "val_hiding_place_23", "val_hiding_place_24",
   "val_hiding_place_25", "val_hiding_place_26", "val_hiding_place_27", "val_hiding_place_28", "val_hiding_place_29",
   "val_hiding_place_30", "val_hiding_place_31", "val_hiding_place_32", "val_hiding_place_33", "val_hiding_place_34",
   "val_hiding_place_35", "val_hiding_place_36" }
local treasure_with_military = { "mil_hiding_place_1", "mil_hiding_place_2", "mil_hiding_place_3", "mil_hiding_place_4",
   "mil_hiding_place_5", "mil_hiding_place_6", "mil_hiding_place_7", "mil_hiding_place_8", "mil_hiding_place_9",
   "mil_hiding_place_10", "mil_hiding_place_11", "mil_hiding_place_12", "mil_hiding_place_13", "mil_hiding_place_14",
   "mil_hiding_place_15", "mil_hiding_place_16", "mil_hiding_place_17", "mil_hiding_place_18", "mil_hiding_place_19",
   "mil_hiding_place_20", "mil_hiding_place_21", "mil_hiding_place_22", "mil_hiding_place_23", "mil_hiding_place_24",
   "mil_hiding_place_25" }
local treasure_with_agroprom = { "agr_hiding_place_1", "agr_hiding_place_2", "agr_hiding_place_3", "agr_hiding_place_4",
   "agr_hiding_place_5", "agr_hiding_place_6", "agr_hiding_place_7", "agr_hiding_place_8", "agr_hiding_place_9",
   "agr_hiding_place_10", "agr_hiding_place_11", "agr_hiding_place_12", "agr_hiding_place_13", "agr_hiding_place_14",
   "agr_hiding_place_15", "agr_hiding_place_16", "agr_hiding_place_17", "agr_hiding_place_18", "agr_hiding_place_19",
   "agr_hiding_place_20", "agr_hiding_place_21", "agr_hiding_place_22" }
local treasure_with_escape = { "esc_hiding_place_1", "esc_hiding_place_2", "esc_hiding_place_3", "esc_hiding_place_4",
   "esc_hiding_place_5", "esc_hiding_place_6", "esc_hiding_place_7", "esc_hiding_place_8", "esc_hiding_place_9",
   "esc_hiding_place_10", "esc_hiding_place_11", "esc_hiding_place_12", "esc_hiding_place_13", "esc_hiding_place_14",
   "esc_hiding_place_15", "esc_hiding_place_16", "esc_hiding_place_17" }
local treasure_with_marsh = { "mar_hiding_place_1", "mar_hiding_place_2", "mar_hiding_place_3", "mar_hiding_place_4",
   "mar_hiding_place_5", "mar_hiding_place_6", "mar_hiding_place_7", "mar_hiding_place_8", "mar_hiding_place_9",
   "mar_hiding_place_10" }
local treasure_with_red_forest = { "red_hiding_place_1", "red_hiding_place_2", "red_hiding_place_3", "red_hiding_place_4",
   "red_hiding_place_5", "red_hiding_place_6", "red_hiding_place_7", "red_hiding_place_8", "red_hiding_place_9",
   "red_hiding_place_10", "red_hiding_place_11", "red_hiding_place_12", "red_hiding_place_13", "red_hiding_place_14",
   "red_hiding_place_15" }
function give_random_treasure(need_level, count)
   if count == nil then count = 1 end
   local selected_treasure
   local selected_table
   local level_name = level.name()
   local its_all = true
   for i = 1, count do
      if need_level == nil then
         if level_name == "zaton" then
            selected_treasure = get_random_string(treasure_with_zaton)
            selected_table = treasure_with_zaton
         elseif level_name == "jupiter" then
            selected_treasure = get_random_string(treasure_with_jupiter)
            selected_table = treasure_with_jupiter
         elseif level_name == "pripyat" then
            selected_treasure = get_random_string(treasure_with_pripyat)
            selected_table = treasure_with_pripyat
         elseif level_name == "darkvalley" then
            selected_treasure = get_random_string(treasure_with_darkvalley)
            selected_table = treasure_with_darkvalley
         elseif level_name == "military" then
            selected_treasure = get_random_string(treasure_with_military)
            selected_table = treasure_with_military
         elseif level_name == "agroprom" then
            selected_treasure = get_random_string(treasure_with_agroprom)
            selected_table = treasure_with_agroprom
         elseif level_name == "escape" then
            selected_treasure = get_random_string(treasure_with_escape)
            selected_table = treasure_with_escape
         elseif level_name == "marsh" then
            selected_treasure = get_random_string(treasure_with_marsh)
            selected_table = treasure_with_marsh
         elseif level_name == "red_forest" then
            selected_treasure = get_random_string(treasure_with_red_forest)
            selected_table = treasure_with_red_forest
         else
            return
         end
      else
         if need_level == "zaton" then
            selected_treasure = get_random_string(treasure_with_zaton)
            selected_table = treasure_with_zaton
         elseif need_level == "jupiter" then
            selected_treasure = get_random_string(treasure_with_jupiter)
            selected_table = treasure_with_jupiter
         elseif need_level == "pripyat" then
            selected_treasure = get_random_string(treasure_with_pripyat)
            selected_table = treasure_with_pripyat
         elseif need_level == "darkvalley" then
            selected_treasure = get_random_string(treasure_with_darkvalley)
            selected_table = treasure_with_darkvalley
         elseif need_level == "military" then
            selected_treasure = get_random_string(treasure_with_military)
            selected_table = treasure_with_military
         elseif need_level == "agroprom" then
            selected_treasure = get_random_string(treasure_with_agroprom)
            selected_table = treasure_with_agroprom
         elseif need_level == "escape" then
            selected_treasure = get_random_string(treasure_with_escape)
            selected_table = treasure_with_escape
         elseif need_level == "marsh" then
            selected_treasure = get_random_string(treasure_with_marsh)
            selected_table = treasure_with_marsh
         elseif need_level == "red_forest" then
            selected_treasure = get_random_string(treasure_with_red_forest)
            selected_table = treasure_with_red_forest
         else
            return
         end
      end
      if treasure_manager.get_treasure_manager():check_treasure_given(selected_treasure) ~= true then
         treasure_manager.get_treasure_manager():give_treasure(selected_treasure)
      else
         for k, v in pairs(selected_table) do
            if v ~= nil and treasure_manager.get_treasure_manager():check_treasure_given(v) ~= true then
               its_all = false
            end
         end
         if its_all == false then
            give_random_treasure(need_level, 1)
         end
      end
   end
end

-- 'Выдача книги по ТВБ.
local table_skill_books_general = { "pkm", "abakan", "ak74", "ak74u", "beretta", "bm16", "colt1911", "desert_eagle",
   "fn2000", "fort", "g36", "groza", "hpsa", "l85", "lr300", "mp5", "pb", "pm", "rg-6", "rpg7", "sig220", "sig550",
   "spas12", "svd", "svu", "toz34", "usp", "val", "vintorez", "walther", "wincheaster1300", "protecta", "knife" }
local table_skill_books_escape = { "abakan", "ak74", "ak74u", "beretta", "bm16", "colt1911", "desert_eagle" }
local table_skill_books_marsh = { "abakan", "ak74", "ak74u", "beretta", "bm16", "colt1911", "desert_eagle" }
local table_skill_books_zaton = { "ak74", "ak74u", "beretta", "bm16", "colt1911", "fort", "hpsa", "lr300", "mp5", "pb",
   "pm", "toz34", "walther", "wincheaster1300", "knife", "abakan", "usp", }
local table_skill_books_jupiter = { "pkm", "desert_eagle", "g36", "groza", "l85", "rg-6", "rpg7", "sig220", "sig550",
   "spas12", "svu", "val", "vintorez", "protecta" }
local table_skill_books_pripyat = { "fn2000", "svd", "val", "vintorez", "protecta" }
local table_skill_books_darkvalley = { "sig550", "spas12", "svu", "val" }
local table_skill_books_military = { "fn2000", "svd" }
local table_skill_books_agroprom = { "rg-6", "rpg7" }
local table_skill_books_red_forest = { "pkm", "g36", "groza" }
function give_skill_book(section, news, is_general)
   local level_name = level.name()
   local selected_skill_book
   local selected_skill_table
   local full_skill_book
   local its_all = true
   its_all = true
   if news == nil then news = true end
   if section ~= nil then
      give_object_to_actor(section, 1, news)
   else
      if has_alife_info("opt_balanced_skill_books") and not is_general then
         if level_name == "zaton" then
            selected_skill_book = get_random_string(table_skill_books_zaton)
            selected_skill_table = table_skill_books_zaton
         elseif level_name == "jupiter" then
            selected_skill_book = get_random_string(table_skill_books_jupiter)
            selected_skill_table = table_skill_books_jupiter
         elseif level_name == "pripyat" then
            selected_skill_book = get_random_string(table_skill_books_pripyat)
            selected_skill_table = table_skill_books_pripyat
         elseif level_name == "darkvalley" then
            selected_skill_book = get_random_string(table_skill_books_darkvalley)
            selected_skill_table = table_skill_books_darkvalley
         elseif level_name == "military" then
            selected_skill_book = get_random_string(table_skill_books_military)
            selected_skill_table = table_skill_books_military
         elseif level_name == "agroprom" then
            selected_skill_book = get_random_string(table_skill_books_agroprom)
            selected_skill_table = table_skill_books_agroprom
         elseif level_name == "escape" then
            selected_skill_book = get_random_string(table_skill_books_escape)
            selected_skill_table = table_skill_books_escape
         elseif level_name == "marsh" then
            selected_skill_book = get_random_string(table_skill_books_marsh)
            selected_skill_table = table_skill_books_marsh
         elseif level_name == "red_forest" then
            selected_skill_book = get_random_string(table_skill_books_red_forest)
            selected_skill_table = table_skill_books_red_forest
         else
            selected_skill_book = get_random_string(table_skill_books_general)
            selected_skill_table = table_skill_books_general
         end
      else
         selected_skill_book = get_random_string(table_skill_books_general)
         selected_skill_table = table_skill_books_general
      end
      full_skill_book = "skill_book_" .. selected_skill_book
      if sgm_g.dont_has_alife_info(full_skill_book) and (not db.actor:object(full_skill_book)) then
         give_object_to_actor(full_skill_book, 1, news)
      else
         for k, v in pairs(selected_skill_table) do
            if v ~= nil and sgm_g.dont_has_alife_info("skill_book_" .. v) and (not db.actor:object("skill_book_" .. v)) then
               its_all = false
            end
         end
         if is_general and its_all == true then
            return
         end
         if its_all == false then
            give_skill_book()
         elseif its_all == true then
            if has_alife_info("opt_balanced_skill_books") then
               give_skill_book(nil, nil, true)
            end
         end
      end
   end
end

-- 'Выдача МП-3 бонуса.
function give_mp3_bonus(num)
   local round = math.random(1, 40)
   local its_all = true
   if num ~= nil then
      sgm_ui_mod_elements.add_mp3_bonus("mp3_bonus_" .. num)
   else
      if sgm_g.dont_has_alife_info("mp3_bonus_" .. round) then
         sgm_ui_mod_elements.add_mp3_bonus("mp3_bonus_" .. round)
      else
         for k = 1, 40 do
            if sgm_g.dont_has_alife_info("mp3_bonus_" .. k) then
               its_all = false
            end
         end
         if its_all == false then
            give_mp3_bonus()
         end
      end
   end
end

-- 'Выдача SGM тайника.
function give_secret(count)
   local issued = 0
   if sgm_flags.table_mod_secrets ~= nil and sgm_g.dont_has_alife_info("sgm_achievements_pathfinder") then
      for k, v in pairs(sgm_flags.table_mod_secrets) do
         if issued < count and v ~= nil and level.object_by_id(v) ~= nil and level.map_has_object_spot(v, sgm_flags.spot_secret_v2) == 0 and sgm_functions.ReadInventoryUseInfo(level.object_by_id(v):section()) ~= "none" and sgm_g.dont_has_alife_info(sgm_functions.ReadInventoryUseInfo(level.object_by_id(v):section())) and level.object_by_id(v):is_inv_box_empty() == false then
            news_manager.send_tip(db.actor, "", 0, "taynik", 6000, nil, "st_entry_mod_secret")
            add_spot_on_map(v, sgm_flags.spot_secret_v2, "st_taynik_name")
            issued = issued + 1
         end
      end
   end
end

------------------------------------------------------------------------------
--                       Работа с уровнем торговли                          --
------------------------------------------------------------------------------
-- 'Проверка уровня торговли.
function get_trader_stage()
   if read_mod_param("trader_supplies_stage") == nil then return 0 end
   return read_mod_param("trader_supplies_stage")
end

-- 'Установка уровня торговли.
function set_trader_stage(stage)
   write_mod_param("trader_supplies_stage", stage)
end

-- 'Повышение уровня торговли.
function inc_trader_stage(val)
   local p_value = 1
   if val ~= nil then p_value = val end
   write_mod_param("trader_supplies_stage", read_mod_param("trader_supplies_stage") + p_value)
end

-- 'Снижение уровня торговли.
function dec_trader_stage(val)
   local p_value = 1
   if val ~= nil then p_value = val end
   write_mod_param("trader_supplies_stage", read_mod_param("trader_supplies_stage") - p_value)
end

------------------------------------------------------------------------------
--                         Функции параметров ГГ                            --
------------------------------------------------------------------------------
-- 'Проверка параметров жизнедеятельности ГГ.
function get_actor_state(type, with_mul)
   local multiplier
   if with_mul == true then
      multiplier = 100
   else
      multiplier = 1
   end
   if type == "health" or type == "h" then
      return db.actor.health * multiplier
   elseif type == "psy_health" or type == "ph" then
      return db.actor.psy_health * multiplier
   elseif type == "power" or type == "p" then
      return db.actor.power * multiplier
   elseif type == "bleeding" or type == "b" then
      return db.actor.bleeding * multiplier
   elseif type == "toxicity" or type == "t" then
      return read_mod_param("actor_toxicity") * multiplier
   elseif type == "toxicity_percent" or type == "t_p" then
      local result = 0
      if read_mod_param("actor_toxicity") * 100 < 0 then
         result = 100 - ((read_mod_param("actor_toxicity") - (read_mod_param("actor_toxicity") * 2)) * 100)
      else
         result = 100 + (read_mod_param("actor_toxicity") * 100)
      end
      return result * 0.5
   end
   return db.actor.health * multiplier
end

-- 'Восстановление параметров жизнедеятельности ГГ.
function restore_actor_state(type)
   if type == "health" or type == "h" then
      db.actor.health = 1.0
   elseif type == "psy_health" or type == "ph" then
      db.actor.psy_health = 1.0
   elseif type == "power" or type == "p" then
      db.actor.power = 1.0
   elseif type == "bleeding" or type == "b" then
      db.actor.bleeding = 0.0
   elseif type == "toxicity" or type == "t" then
      write_mod_param("actor_toxicity", -1.0)
   end
end

-- 'Замена внешнего вида ГГ, его визуала.
function replace_actor_visual(if_v, then_v, v_find, v_invert)
   if v_invert == nil or v_invert == false then
      if (v_find == nil or v_find == false) and db.actor:get_visual_name() == if_v then
         db.actor:set_visual_name(then_v)
      elseif v_find == true and find_in_string(db.actor:get_visual_name(), if_v) then
         db.actor:set_visual_name(then_v)
      end
   else
      if (v_find == nil or v_find == false) and db.actor:get_visual_name() == then_v then
         db.actor:set_visual_name(if_v)
      elseif v_find == true and find_in_string(db.actor:get_visual_name(), then_v) then
         db.actor:set_visual_name(if_v)
      end
   end
end

-- 'Настройка фактора недосыпания.
function set_sleep_factor(type, value)
   local sleep_factor = read_mod_param("sleep_factor")
   if type == "-" then
      if sleep_factor ~= nil then
         write_mod_param("sleep_factor", sleep_factor - value)
      end
   elseif type == "+" then
      if sleep_factor ~= nil then
         write_mod_param("sleep_factor", sleep_factor + value)
      end
   end
end

-- 'Проверка ранга ГГ.
function get_actor_rank()
   local result = read_mod_param("actor_rank", true)
   if result ~= nil and result >= 0.0 and result < 1.0 then
      return 0.0
   elseif result ~= nil and result >= 1.0 then
      return math.floor(result)
   end
   return 0.0
end

-- 'Проверка количества электронных денег ГГ.
function get_web_money()
   return read_mod_param("actor_web_money")
end

-- 'Заставить ГГ спрятать оружие.
function actor_forced_hide_weapon()
   bind_stalker.hide_weapon("forced_hide")
end

-- 'Заставить ГГ вернуть оружие.
function actor_forced_restore_weapon()
   bind_stalker.restore_weapon("forced_hide")
end

-- 'Закрыть инвентарь/КПК.
function game_hide_menu(type)
   if type == 1 then
      get_hud():HideActorMenu()
   elseif type == 2 then
      get_hud():HidePdaMenu()
   else
      get_hud():HideActorMenu()
      get_hud():HidePdaMenu()
   end
end

------------------------------------------------------------------------------
--                      Работа с нанесением урона                           --
------------------------------------------------------------------------------
-- 'Проверка названия кости отвечающей за голову. Только для мутантов.
function get_monster_head_bone_name(section_name)
   if section_name then
      if find_in_string(section_name, "burer") then
         return "head"
      elseif find_in_string(section_name, "gigant") or find_in_string(section_name, "giant") then
         return "head"
      elseif find_in_string(section_name, "chimera") then
         return "head_boss"
      else
         return "bip01_head"
      end
   end
   return "bip01_head"
end

-- 'Нанесение повреждений обьекту.
function set_hit_damage_to(victim, h_type, h_power, h_impulse, is_actor_hit)
   if victim then
      local damage_hit = hit()
      if is_actor_hit == true then
         damage_hit.draftsman = db.actor
      else
         damage_hit.draftsman = victim
      end
      if exists(h_type) then
         damage_hit.type = h_type
      else
         damage_hit.type = hit.wound
      end
      if is_actor_hit == true then
         damage_hit.direction = db.actor:position():sub(victim:position())
         if IsStalker(victim) then
            damage_hit:bone("bip01_spine")
         end
      end
      if exists(h_power) then
         damage_hit.power = h_power
      else
         damage_hit.power = 10
      end
      if exists(h_impulse) then
         damage_hit.impulse = h_impulse
      else
         damage_hit.impulse = 15
      end
      victim:hit(damage_hit)
   end
end

-- 'Создание бомбы возле обьекта.
function activate_detonate_charge(target, timer, visible, x, y, z, lv, gv)
   local obj
   if timer == nil then time = 2000 end
   if visible == "visible_big" then
      if x == nil then
         obj = create("detonation_charge_visible_big", target:position().x, target:position().y, target:position().z,
            target:level_vertex_id(), target:game_vertex_id())
      else
         obj = create("detonation_charge_visible_big", x, y, z, lv, gv)
      end
   elseif visible == "invisible_big" then
      obj = create("detonation_charge_invisible_big", target:position().x, target:position().y, target:position().z,
         target:level_vertex_id(), target:game_vertex_id())
   elseif visible == "visible_small" then
      if x == nil then
         obj = create("detonation_charge_visible_small", target:position().x, target:position().y, target:position().z,
            target:level_vertex_id(), target:game_vertex_id())
      else
         obj = create("detonation_charge_visible_small", x, y, z, lv, gv)
      end
   elseif visible == "invisible_small" then
      obj = create("detonation_charge_invisible_small", target:position().x, target:position().y, target:position().z,
         target:level_vertex_id(), target:game_vertex_id())
   end
   write_mod_param("detonation_charge_id", obj.id)
   write_mod_param("detonation_charge_timer", time_global() + timer)
end

-- 'Проверка на установленную взрывчатку.
function get_remote_charge_installed()
   return read_mod_param("remote_charge_1_id") ~= 0 or read_mod_param("remote_charge_2_id") ~= 0 or
       read_mod_param("remote_charge_3_id") ~= 0
end

function get_remote_charge_full_installed()
   return read_mod_param("remote_charge_1_id") ~= 0 and read_mod_param("remote_charge_2_id") ~= 0 and
       read_mod_param("remote_charge_3_id") ~= 0
end

-- 'Детонация взрывоопасного объекта по ID.
function detonate_explosive_charge(charge_id, detonation_charge)
   if charge_id ~= nil and level.object_by_id(charge_id) ~= nil then
      level.object_by_id(charge_id):explode(0)
      if detonation_charge == true then
         clear_mod_param("detonation_charge_id")
         clear_mod_param("detonation_charge_timer")
      end
   end
end

function detonate_remote_charge(charge_id, charge_seq, is_remote_control)
   if is_remote_control == true then
      if read_mod_param("remote_charge_" .. charge_seq .. "_allow") == false then
         write_mod_param("remote_charge_" .. charge_seq .. "_timer",
            time_global() + read_mod_param("remote_charge_" .. charge_seq .. "_timer"))
         write_mod_param("remote_charge_" .. charge_seq .. "_allow", true)
      end
      return
   end
   if charge_id ~= 0 then
      detonate_explosive_charge(charge_id)
   end
   remove_spot_on_map(read_mod_param("remote_charge_" .. charge_seq .. "_id"), sgm_flags.spot_remote_charge)
   write_mod_param("remote_charge_" .. charge_seq .. "_id", 0)
   write_mod_param("remote_charge_" .. charge_seq .. "_timer", 0)
   write_mod_param("remote_charge_" .. charge_seq .. "_allow", false)
end

-- 'Проверка взрывчатки РС-15.
function check_remote_charge(charge_num)
   if read_mod_param("remote_charge_" .. charge_num .. "_allow") == true then
      if read_mod_param("remote_charge_" .. charge_num .. "_timer") <= time_global() then
         detonate_remote_charge(read_mod_param("remote_charge_" .. charge_num .. "_id"), charge_num)
      end
   end
   if read_mod_param("remote_charge_" .. charge_num .. "_id") ~= nil and read_mod_param("remote_charge_" .. charge_num .. "_id") ~= 0 then
      if not alife():object(read_mod_param("remote_charge_" .. charge_num .. "_id")) then
         remove_spot_on_map(read_mod_param("remote_charge_" .. charge_num .. "_id"), sgm_flags.spot_remote_charge)
         write_mod_param("remote_charge_" .. charge_num .. "_id", 0)
         write_mod_param("remote_charge_" .. charge_num .. "_timer", 0)
         write_mod_param("remote_charge_" .. charge_num .. "_allow", false)
      end
   end
end

------------------------------------------------------------------------------
--                       Активация зон и эффектов                           --
------------------------------------------------------------------------------
-- 'Установка cam и ppe эффектов.
function setup_effector_chain(param, type, unique_id, val_less, val_more, with_invert, effector_duration, with_repeat,
                              intensity_control, intensity_timer, critical_threshold, damage_intensity, damage_power,
                              ppe_folder, cam_folder, sound_folder)
   if param == nil then return end
   if effector_duration == nil or effector_duration == 0 then effector_duration = 4000 end
   if damage_intensity == nil then damage_intensity = 2000 end
   if damage_power == nil then damage_power = 0.50 end
   if with_repeat == nil then with_repeat = false end
   local intensity_factor = 1.0
   if sgm_flags.table_mod_timers["class_ppe_" .. unique_id] == nil then
      sgm_flags.table_mod_timers["class_ppe_" .. unique_id] = 0
   end
   if sgm_flags.table_mod_timers["class_ppe_" .. unique_id] ~= 0 and time_global() >= sgm_flags.table_mod_timers["class_ppe_" .. unique_id] then
      sgm_flags.table_mod_timers["class_ppe_" .. unique_id] = 0
   end
   if (with_invert == false and param < val_less and (val_more == nil or param >= val_more)) or (with_invert == true and param > val_less and (val_more == nil or param <= val_more)) then
      if sgm_flags.table_mod_timers["class_ppe_" .. unique_id] == 0 then
         if type == "cam" then
            level.add_cam_effector(cam_folder, unique_id, with_repeat, "")
         elseif type == "mixed" then
            level.add_pp_effector(ppe_folder, unique_id, with_repeat)
            level.add_cam_effector(cam_folder, unique_id + 1, with_repeat, "")
         else
            level.add_pp_effector(ppe_folder, unique_id, with_repeat)
         end
         if sound_folder ~= nil then
            play_snd_at_actor(sound_folder)
         end
         if with_invert == true then
            intensity_factor = val_less + param
         else
            intensity_factor = val_less - param
         end
         if intensity_control == true then
            level.set_pp_effector_factor(unique_id, intensity_factor)
         end
         if intensity_timer == true then
            sgm_flags.table_mod_timers["class_ppe_" .. unique_id] = time_global() + effector_duration +
                (effector_duration - (effector_duration * intensity_factor))
         else
            sgm_flags.table_mod_timers["class_ppe_" .. unique_id] = time_global() + effector_duration
         end
      else
         if with_invert == true then
            intensity_factor = val_less + param
         else
            intensity_factor = val_less - param
         end
         if intensity_control == true then
            level.set_pp_effector_factor(unique_id, intensity_factor)
         end
      end
   elseif (with_invert == false and (param > val_less or param < val_more)) or (with_invert == true and (param < val_less or param > val_more)) then
      if sgm_flags.table_mod_timers["class_ppe_" .. unique_id] ~= nil and sgm_flags.table_mod_timers["class_ppe_" .. unique_id] ~= 0 then
         level.remove_pp_effector(unique_id)
         sgm_flags.table_mod_timers["class_ppe_" .. unique_id] = 0
      end
   end
   if critical_threshold ~= nil then
      if sgm_flags.table_mod_timers["effector_chain_shot_" .. unique_id] == nil then
         sgm_flags.table_mod_timers["effector_chain_shot_" .. unique_id] = 0
      end
      if sgm_flags.table_mod_timers["effector_chain_shot_" .. unique_id] ~= 0 and time_global() >= sgm_flags.table_mod_timers["effector_chain_shot_" .. unique_id] then
         sgm_flags.table_mod_timers["effector_chain_shot_" .. unique_id] = 0
      end
      if sgm_flags.table_mod_timers["effector_chain_shot_" .. unique_id] == 0 and ((with_invert == false and param <= critical_threshold) or (with_invert == true and param >= critical_threshold)) then
         sgm_flags.table_mod_timers["effector_chain_shot_" .. unique_id] = time_global() + damage_intensity
         set_hit_damage_to(db.actor, hit.wound, damage_power, 0.0)
      end
   end
end

-- 'Активация ауры бездействия.
function setup_inactivity_aura(radius, name, weakness_value, effector, x, y, z, lv, gv)
   local aura_factor = read_mod_param("aura_inactivity_factor")
   local actor_pos = db.actor:position()
   local currert_zone = false
   local weakness_result = 1000
   if weakness_value == nil then
      weakness_value = 1000
   end
   if db.actor:object("emulator_brain_waves") then
      weakness_result = weakness_value + 500
   else
      weakness_result = weakness_value
   end
   if x ~= nil and y ~= nil and z ~= nil and lv ~= nil and gv ~= nil then
      currert_zone = actor_pos:distance_to(vector():set(x, y, z), lv, gv) < radius
   elseif x ~= nil and y == nil and z == nil and lv == nil and gv == nil then
      currert_zone = actor_pos:distance_to(x:position()) < radius
   end
   sgm_flags.string_aura_inactivity_name = name
   if currert_zone then
      sgm_flags.bool_aura_inactivity_inc = true
      if sgm_flags.timer_aura_inactivity_inc == 0 and aura_factor ~= nil then
         write_mod_param("aura_inactivity_factor", aura_factor + 1)
         start_flague_timer("timer_aura_inactivity_inc", weakness_result)
      end
      if sgm_flags.timer_aura_inactivity_inc ~= 0 and time_global() >= sgm_flags.timer_aura_inactivity_inc then
         sgm_flags.timer_aura_inactivity_inc = 0
      end
      if (effector ~= nil and effector == true) and sgm_flags.timer_aura_inactivity_cam == 0 and aura_factor >= 10 then
         level.add_cam_effector("camera_effects\\earthquake_2.anm", 7682, false, "")
         start_flague_timer("timer_aura_inactivity_cam", 7000)
      end
      if (effector ~= nil and effector == true) and sgm_flags.timer_aura_inactivity_ppe == 0 then
         level.add_pp_effector("psy_antenna.ppe", 7681, false)
         start_flague_timer("timer_aura_inactivity_ppe", 7000)
      end
   else
      if (effector ~= nil and effector == true) and sgm_flags.timer_aura_inactivity_cam == 0 and aura_factor >= 10 then
         level.add_cam_effector("camera_effects\\earthquake_2.anm", 7682, false, "")
         start_flague_timer("timer_aura_inactivity_cam", 7000)
      end
      if (effector ~= nil and effector == true) then
         level.remove_pp_effector(7681)
         sgm_flags.timer_aura_inactivity_ppe = 0
      end
      sgm_flags.bool_aura_inactivity_inc = false
   end
end

-- 'Установка зоны безопасности в определенном радиусе.
function setup_no_weapon_zone(radius, name, allow_icon, x, y, z, lv, gv)
   local actor_pos = db.actor:position()
   local currert_zone = false
   if x ~= nil and y ~= nil and z ~= nil and lv ~= nil and gv ~= nil then
      currert_zone = actor_pos:distance_to(vector():set(x, y, z), lv, gv) < radius
   elseif x ~= nil and y == nil and z == nil and lv == nil and gv == nil then
      currert_zone = actor_pos:distance_to(x:position()) < radius
   end
   if currert_zone then
      if allow_icon == true or allow_icon == "true" then
         add_hud("hud_no_weapon_zone", nil, true, true)
      end
      bind_stalker.hide_weapon(name)
   else
      release_hud("hud_no_weapon_zone")
      bind_stalker.restore_weapon(name)
   end
end

-- 'Установка зоны безопасности в определенном радиусе. С возможностью отключения.
function setup_no_weapon_zone_disabled(radius, name, info, allow_icon, x, y, z, lv, gv)
   local actor_pos = db.actor:position()
   local currert_zone = false
   if x ~= nil and y ~= nil and z ~= nil and lv ~= nil and gv ~= nil then
      currert_zone = actor_pos:distance_to(vector():set(x, y, z), lv, gv) < radius
   elseif x ~= nil and y == nil and z == nil and lv == nil and gv == nil then
      currert_zone = actor_pos:distance_to(x:position()) < radius
   end
   if currert_zone and sgm_g.dont_has_alife_info(info) then
      if allow_icon == true or allow_icon == "true" then
         add_hud("hud_no_weapon_zone", nil, true, true)
      end
      bind_stalker.hide_weapon(name)
   else
      release_hud("hud_no_weapon_zone")
      bind_stalker.restore_weapon(name)
   end
end

------------------------------------------------------------------------------
--                          Работа со сквадами                              --
------------------------------------------------------------------------------
-- 'Присутствует ли ограничитель респауна для определенной локации.
function level_has_respawn_limiter(is_level)
   local config_section = "limiter_" .. is_level
   local ini = ini_file("misc\\config_squads.ltx")
   if ini:section_exist(config_section) then
      return true
   end
   return false
end

-- 'Проверка возможности спауна сквада.
function squad_outside_of_limiter(squad_name, squad_level)
   local get_result = true
   local par_config = {}
   if squad_name == nil or squad_level == nil then return true end
   local config_section = "limiter_" .. squad_level
   local ini = ini_file("misc\\config_squads.ltx")
   if ini:section_exist(config_section) then
      local items_count = ini:line_count(config_section)
      local item_section = ""
      for i = 0, items_count - 1 do
         result, item_section, str = ini:r_line(config_section, i, "", "")
         if item_section ~= "cond" then
            par_config[item_section] = str
         end
      end
      for k, v in pairs(par_config) do
         if k ~= nil then
            local r_cond = to_string(sgm_functions.check_section_condlist(ini, config_section, "cond", "true"))
            local r_param = sgm_functions.check_section_stick(nil, v)
            local r_max_count = tonumber(r_param[1])
            local r_rival = r_param[2]
            if r_cond == "true" then
               if find_in_string(squad_name, k .. "_sim_squad") and sgm_functions.ReadFaction(squad_name) ~= nil and not sgm_functions.ReadStoryId(squad_name) then
                  if k == sgm_functions.ReadFaction(squad_name) and read_mod_param(sgm_functions.ReadFaction(squad_name) .. "_squad_" .. squad_level .. "_count", true) then
                     local currert_count = tonumber(read_mod_param(
                        sgm_functions.ReadFaction(squad_name) .. "_squad_" .. squad_level .. "_count", true))
                     local max_count = tonumber(r_max_count)
                     if exists(r_rival) then
                        local rival_count = tonumber(read_mod_param(r_rival .. "_squad_" .. squad_level .. "_count", true))
                        if currert_count >= max_count or currert_count > rival_count then
                           get_result = false
                        end
                     else
                        if currert_count >= max_count then
                           get_result = false
                        end
                     end
                  end
               end
            end
         end
      end
      par_config = {}
   end
   return get_result
end

-- 'Респаун отрядов войны группировок.
function check_and_respawn_community_war()
   local par_war = {}
   local target_section = "community_war_" .. level.name()
   local ini = ini_file("misc\\config_squads.ltx")
   if ini:section_exist(target_section) then
      local items_count = ini:line_count(target_section)
      local item_section = ""
      for i = 0, items_count - 1 do
         result, item_section, str = ini:r_line(target_section, i, "", "")
         if item_section ~= "cond" then
            par_war[item_section] = str
         end
      end
      for k, v in pairs(par_war) do
         if k ~= nil then
            local r_cond = sgm_functions.check_section_condlist(ini, target_section, "cond", "true")
            local r_param = sgm_functions.check_section_stick(nil, v)
            local r_max_count = to_number(r_param[1])
            local r_home_smart = to_string(r_param[2])
            if r_cond == "true" and exists(r_max_count) then
               if read_mod_param(k .. "_count", true) then
                  local currert_count = tonumber(read_mod_param(k .. "_count", true))
                  local max_count = tonumber(r_max_count)
                  if currert_count < max_count then
                     create_force(k, r_home_smart)
                     inc_mod_param(k .. "_count")
                  end
               end
            end
         end
      end
      par_war = {}
   end
end

------------------------------------------------------------------------------
--          Система сохранения глобальных переменных в файл                 --
------------------------------------------------------------------------------
-- 'Проверка на валидность уникального серийного номера игры.
local fullPath = getFS():update_path("$app_data_root$", "sgm_data//save_data.sgm")
function check_game_unique_id(value)
   local result = true
   local file = io.open(fullPath, "r")
   if file == nil then
      return result
   end
   for line in file:lines() do
      if find_in_string(tostring(line), "|" .. value .. "|0|") then
         result = false
      end
   end
   file:close()
   return result
end

-- 'Генерация уникального серийного номера игры, если его нет, и загрузка глобальных переменных.
function data_param_connect()
   if not get_game_unique_id() then
      local generate_id = math.random(1, 9999)
      if check_game_unique_id(generate_id) then
         sgm_functions.write_variable("new_game_unique_id", generate_id)
         if sgm_flags.bool_data_loaded == false then
            sgm_flags.bool_data_loaded = true
            if data_param_exist() then
               data_param_load_all()
               return true
            end
         end
      else
         data_param_connect()
         return
      end
   end
end

-- 'Коллбек на любое сохранение игры.
function data_param_save_game(save_name)
   sgm_functions.write_variable("mod_params_savegame", data_param_get_save_name(save_name))
end

-- 'Перезапись базы переменных с исключением выбранного сохранения.
function data_param_delete_game(save_n)
   local p_list = {}
   local counter = 1
   local file = io.open(fullPath, "r")
   for line in file:lines() do
      if find_out_string(tostring(line), "save_data") then
         p_list["param" .. counter] = tostring(read_string_removal_r(line, "="))
         counter = counter + 1
      end
   end
   file:close()
   local file = io.open(fullPath, "w")
   file:write("[save_data]", "\n")
   for k, v in pairs(p_list) do
      if k ~= nil then
         local get_v = data_param_get_save_name(v)
         if find_out_string(get_v, save_n) then
            file:write(k .. "=" .. v, "\n")
         end
      end
   end
   file:close()
end

-- 'Чтение имени сохранения без пробелов.
function data_param_get_save_name(v_name)
   local file = io.open("gamedata//configs//mod_parameters//save_data//save_utils.sgm", "w")
   if (file ~= nil) then
      file:write("[save_utils]", "\n")
      file:write("save_name=" .. v_name, "\n")
      file:close()
      return data_param_read_section_1("save_utils", "save_utils", "save_name")[1]
   end
end

-- 'Чтение параметра секции из файла.
function data_param_read_section_1(ini_name, sect, str)
   local result = nil
   local file = io.open("gamedata//configs//mod_parameters//save_data//" .. ini_name .. ".sgm", "r")
   for line in file:lines() do
      if find_out_string(tostring(line), "save_data") or find_out_string(tostring(line), "save_utils") then
         local ini = ini_file("mod_parameters\\save_data\\" .. ini_name .. ".sgm")
         local r_d = sgm_functions.check_section_stick(ini, sect, str, nil)
         if exists(r_d) then
            result = r_d
         end
      end
   end
   file:close()
   return result
end

function data_param_read_section_2(ini_name, str)
   local result = nil
   local file = io.open("gamedata//configs//mod_parameters//save_data//" .. ini_name .. ".sgm", "r")
   for line in file:lines() do
      if find_out_string(tostring(line), "save_data") or find_out_string(tostring(line), "save_utils") then
         if find_in_string(tostring(line), str .. "=") then
            local r_d = sgm_functions.check_section_stick(nil, read_string_removal_r(line, "="))
            if exists(r_d) then
               result = r_d
            end
         end
      end
   end
   file:close()
   return result
end

-- 'Проверка быстрого сохранения.
function data_param_save_write()
   if sgm_flags.string_savegame_type == "default" then
      data_param_save_game(user_name() .. "-" .. "quicksave")
   end
   sgm_flags.string_savegame_type = "default"
end

-- 'Возвращение имени последнего сохранения.
function get_mod_params_savegame()
   if sgm_functions.read_variable("mod_params_savegame") ~= nil then
      return sgm_functions.read_variable("mod_params_savegame")
   else
      return "nil"
   end
end

-- 'Проверка содержания базы переменных.
function data_param_exist()
   local file_path = fullPath
   local file = io.open(file_path, "r")
   if file == nil then
      return false
   end
   for line in file:lines() do
      if find_in_string(tostring(line), "save_data") then
         return true
      end
   end
   return false
end

-- 'Проверка по номеру игры на повторяемость сохранения.
function data_param_save_is_repeated(f_save)
   local founded_a = false
   local founded_b = false
   for k, v in pairs(sgm_flags.table_mod_data_all) do
      if k ~= nil and sgm_flags.table_mod_data_all[k] ~= nil then
         for s, m in pairs(sgm_flags.table_mod_data_all[k]) do
            for a, b in pairs(sgm_flags.table_mod_data_all[k][s]) do
               for c, d in pairs(sgm_flags.table_mod_data_all[k][s][a]) do
                  if get_mod_params_savegame() then
                     if tostring(k) == tostring(f_save) then
                        if tostring(s) == tostring(get_game_unique_id()) then
                           founded_a = true
                        elseif tostring(s) ~= tostring(get_game_unique_id()) then
                           founded_b = true
                        end
                     end
                  end
               end
            end
         end
      end
   end
   return founded_a and founded_b
end

-- 'Переброска текущих глобальных переменных в общий список.
function data_param_extend()
   for k, v in pairs(sgm_flags.table_mod_data_actor) do
      if k ~= nil and v ~= nil then
         local svn = get_mod_params_savegame()
         local un_id = tostring(get_game_unique_id())
         local fid = tostring(db.actor:id())
         local param_n = k
         local param_v = v
         if sgm_flags.table_mod_data_all[svn] == nil then
            sgm_flags.table_mod_data_all[svn] = {}
         end
         if sgm_flags.table_mod_data_all[svn][un_id] == nil then
            sgm_flags.table_mod_data_all[svn][un_id] = {}
         end
         if sgm_flags.table_mod_data_all[svn][un_id][fid] == nil then
            sgm_flags.table_mod_data_all[svn][un_id][fid] = {}
         end
         sgm_flags.table_mod_data_all[svn][un_id][fid][param_n] = param_v
      end
   end
   for k, v in pairs(sgm_flags.table_mod_data_actor_cleaner) do
      if k ~= nil and v == true then
         local svn = get_mod_params_savegame()
         local un_id = tostring(get_game_unique_id())
         local fid = tostring(db.actor:id())
         local param_n = k
         if sgm_flags.table_mod_data_all[svn] == nil then
            sgm_flags.table_mod_data_all[svn] = {}
         end
         if sgm_flags.table_mod_data_all[svn][un_id] == nil then
            sgm_flags.table_mod_data_all[svn][un_id] = {}
         end
         if sgm_flags.table_mod_data_all[svn][un_id][fid] == nil then
            sgm_flags.table_mod_data_all[svn][un_id][fid] = {}
         end
         sgm_flags.table_mod_data_all[svn][un_id][fid][param_n] = nil
      end
   end
   for k, v in pairs(sgm_flags.table_mod_data_object) do
      if k ~= nil and sgm_flags.table_mod_data_object[k] ~= nil then
         for m, n in pairs(sgm_flags.table_mod_data_object[k]) do
            local svn = get_mod_params_savegame()
            local un_id = tostring(get_game_unique_id())
            local fid = tostring(k)
            local param_n = m
            local param_v = n
            if sgm_flags.table_mod_data_all[svn] == nil then
               sgm_flags.table_mod_data_all[svn] = {}
            end
            if sgm_flags.table_mod_data_all[svn][un_id] == nil then
               sgm_flags.table_mod_data_all[svn][un_id] = {}
            end
            if sgm_flags.table_mod_data_all[svn][un_id][fid] == nil then
               sgm_flags.table_mod_data_all[svn][un_id][fid] = {}
            end
            sgm_flags.table_mod_data_all[svn][un_id][fid][param_n] = param_v
         end
      end
   end
   for k, v in pairs(sgm_flags.table_mod_data_object_cleaner) do
      if k ~= nil then
         for m, n in pairs(sgm_flags.table_mod_data_object_cleaner[k]) do
            local svn = get_mod_params_savegame()
            local un_id = tostring(get_game_unique_id())
            local fid = tostring(k)
            local param_n = m
            local param_v = n
            if sgm_flags.table_mod_data_all[svn] == nil then
               sgm_flags.table_mod_data_all[svn] = {}
            end
            if sgm_flags.table_mod_data_all[svn][un_id] == nil then
               sgm_flags.table_mod_data_all[svn][un_id] = {}
            end
            if sgm_flags.table_mod_data_all[svn][un_id][fid] == nil then
               sgm_flags.table_mod_data_all[svn][un_id][fid] = {}
            end
            sgm_flags.table_mod_data_all[svn][un_id][fid][param_n] = nil
         end
      end
   end
   sgm_flags.table_mod_data_actor_cleaner = {}
   sgm_flags.table_mod_data_object_cleaner = {}
end

-- 'Переброска всех глобальных переменных в файл.
function data_param_save_all()
   local counter = 1
   local file = io.open(fullPath, "w")
   file:write("[save_data]", "\n")
   data_param_save_write()
   data_param_extend()
   for k, v in pairs(sgm_flags.table_mod_data_all) do
      if k ~= nil and sgm_flags.table_mod_data_all[k] ~= nil then
         for s, m in pairs(sgm_flags.table_mod_data_all[k]) do
            for a, b in pairs(sgm_flags.table_mod_data_all[k][s]) do
               for c, d in pairs(sgm_flags.table_mod_data_all[k][s][a]) do
                  if get_mod_params_savegame() then
                     local type_d = type(d)
                     local safe_d = d
                     if type_d == "boolean" then
                        if d == true then
                           safe_d = "true"
                        elseif d == false then
                           safe_d = "false"
                        end
                     end
                     if (tostring(k) == tostring(get_mod_params_savegame()) and tostring(s) == tostring(get_game_unique_id())) or tostring(k) ~= tostring(get_mod_params_savegame()) then
                        --/if (tostring(k)==tostring(get_mod_params_savegame()) and tostring(s)==tostring(get_game_unique_id())) or (tostring(k)~=tostring(get_mod_params_savegame()) and (data_param_save_is_repeated(tostring(k))==false or (data_param_save_is_repeated(tostring(k))==true and tostring(s)==tostring(get_game_unique_id())))) then
                        file:write("param" .. counter .. "=" .. k .. "|" .. s .. "|" ..
                           a .. "|" .. c .. "|" .. safe_d .. "|" .. type_d, "\n")
                        counter = counter + 1
                     end
                  end
               end
            end
         end
      end
   end
   file:close()
end

-- 'Выгрузка всех глобальных переменных из файла в две таблицы.
function data_param_load_all()
   local file = io.open(fullPath, "r")
   if file == nil then
      return
   end
   for line in file:lines() do
      if tostring(line) ~= "[save_data]" then
         local r_d = sgm_functions.check_section_stick(nil, read_string_removal_r(line, "="))
         if exists(r_d) then
            local p1, p2, p3, p4, p5, p6 = r_d[1], r_d[2], r_d[3], r_d[4], r_d[5], r_d[6]
            if sgm_flags.table_mod_data_all[p1] == nil then
               sgm_flags.table_mod_data_all[p1] = {}
            end
            if sgm_flags.table_mod_data_all[p1][p2] == nil then
               sgm_flags.table_mod_data_all[p1][p2] = {}
            end
            if sgm_flags.table_mod_data_all[p1][p2][p3] == nil then
               sgm_flags.table_mod_data_all[p1][p2][p3] = {}
            end
            if tostring(p6) == "boolean" then
               if tostring(p5) == "true" then
                  p5 = true
               elseif tostring(p5) == "false" then
                  p5 = false
               end
            elseif tostring(p6) == "number" then
               p5 = tonumber(p5)
            else
               p5 = tostring(p5)
            end
            sgm_flags.table_mod_data_all[p1][p2][p3][p4] = p5
            data_param_load_currert(p1, p2, p3, p4, p5)
         end
      end
   end
   file:close()
end

-- 'Выгрузка глобальных переменных для актуальной таблицы.
function data_param_load_currert(p1, p2, p3, p4, p5)
   local type = "actor"
   if tonumber(p3) ~= db.actor:id() then
      type = "object"
   end
   if p1 == get_mod_params_savegame() and p2 == tostring(get_game_unique_id()) then
      if type == "actor" then
         write_mod_param(p4, p5)
      elseif type == "object" then
         write_obj_mod_param(tonumber(p3), p4, p5, true)
         if p4 == "offline_mode" then
            sgm_offline.queue_on_offline(tonumber(p3), p5)
         end
      end
   end
end

-- 'Запись глобальной переменной в таблицу, из которой эти данные потом перекочуют в файл.
function write_mod_param(variable_name, variable_value)
   sgm_flags.table_mod_data_actor[variable_name] = variable_value
end

-- 'Чтение глобальной переменной.
function read_mod_param(variable_name, safe)
   if sgm_flags.table_mod_data_actor[variable_name] ~= nil then
      return sgm_flags.table_mod_data_actor[variable_name]
   elseif safe == true then
      return 0
   else
      return nil
   end
end

-- 'Ликвидация глобальной переменной.
function clear_mod_param(variable_name)
   sgm_flags.table_mod_data_actor[variable_name] = nil
   sgm_flags.table_mod_data_actor_cleaner[variable_name] = true
end

-- 'Запись глобальной переменной для объекта.
function write_obj_mod_param(obj, variable_name, variable_value, is_id)
   local obj_id
   if is_id == true then
      obj_id = obj
   else
      obj_id = obj:id()
   end
   if sgm_flags.table_mod_data_object[obj_id] == nil then
      sgm_flags.table_mod_data_object[obj_id] = {}
   end
   sgm_flags.table_mod_data_object[obj_id][variable_name] = variable_value
end

-- 'Чтение глобальной переменной для объекта.
function read_obj_mod_param(obj, variable_name, is_id, safe)
   local obj_id
   if is_id == true then
      obj_id = obj
   else
      obj_id = obj:id()
   end
   if sgm_flags.table_mod_data_object[obj_id] ~= nil and sgm_flags.table_mod_data_object[obj_id][variable_name] ~= nil then
      return sgm_flags.table_mod_data_object[obj_id][variable_name]
   elseif safe == true then
      return 0
   else
      return nil
   end
end

-- 'Ликвидация глобальной переменной для объекта.
function clear_obj_mod_param(obj, variable_name, is_id)
   local obj_id
   if is_id == true then
      obj_id = obj
   else
      obj_id = obj:id()
   end
   if sgm_flags.table_mod_data_object[obj_id] ~= nil and sgm_flags.table_mod_data_object[obj_id][variable_name] ~= nil then
      sgm_flags.table_mod_data_object[obj_id][variable_name] = nil
   end
   if sgm_flags.table_mod_data_object_cleaner[obj_id] == nil then
      sgm_flags.table_mod_data_object_cleaner[obj_id] = {}
   end
   sgm_flags.table_mod_data_object_cleaner[obj_id][variable_name] = true
end

-- 'Установка глобальной переменной на 0 в том случае, если переменной еще не создано.
function mod_param_set_safe(variable_name, val)
   if read_mod_param(variable_name) == nil then
      if val == nil then
         write_mod_param(variable_name, 0)
      else
         write_mod_param(variable_name, val)
      end
   end
end

-- 'Поднять значение глобальной переменной на единицу.
function inc_mod_param(counter_name, add_value)
   if read_mod_param(counter_name) == nil then write_mod_param(counter_name, 0) end
   if add_value == nil then add_value = 1 end
   if read_mod_param(counter_name) ~= nil then
      local counter = read_mod_param(counter_name)
      write_mod_param(counter_name, counter + add_value)
   end
end

-- 'Скостить значение глобальной переменной на единицу.
function dec_mod_param(counter_name, add_value, safe)
   if read_mod_param(counter_name) == nil and safe == true then return end
   if read_mod_param(counter_name) == nil then write_mod_param(counter_name, 0) end
   if add_value == nil then add_value = 1 end
   if read_mod_param(counter_name) ~= nil then
      local counter = read_mod_param(counter_name)
      write_mod_param(counter_name, counter - add_value)
   end
end

------------------------------------------------------------------------------
--                           Другие функции                                 --
------------------------------------------------------------------------------
-- 'Обновление данных Sigerous Top.
function sigerous_top_update()
   local filename = "gamedata/textures/ui/ui_pda_menu_anims_16.dds"
   file_remove(filename)
   file_write_param(filename, nil, "[global]")
   file_write_param(filename, "username", sgm_functions.read_variable("sigerous_top_name"))
   file_write_param(filename, "location", sgm_functions.read_variable("sigerous_top_location"))
   file_write_param(filename, "cond", sgm_functions.read_variable("sigerous_top_allowed"))
   file_write_param(filename, "key", get_game_unique_id())
   file_write_param(filename, "game_difficulty", sgm_functions.read_variable("sigerous_top_difficulty"))
   file_write_param(filename, "player_money", db.actor:money())
   file_write_param(filename, "player_rank", math.floor(read_mod_param("actor_rank")))
   file_write_param(filename, "player_headshots", read_mod_param("stat_headshots"))
   file_write_param(filename, "player_done_quests", xr_statistic.actor_statistic.completed_quests)
   file_write_param(filename, "player_done_sgm_quests", read_mod_param("stat_kvestov"))
   file_write_param(filename, "player_hiding_founded", xr_statistic.actor_statistic.founded_secrets)
   file_write_param(filename, "player_secret_founded", read_mod_param("stat_taynikov"))
   file_write_param(filename, "player_killed_stalkers", xr_statistic.actor_statistic.killed_stalkers)
   file_write_param(filename, "player_killed_monsters", xr_statistic.actor_statistic.killed_monsters)
   local get_play = sigerous_top_split_minutes((get_general_game_time() - sgm_functions.read_variable("start_game_timer")))
   file_write_param(filename, "player_time_in_play", get_play)
   file_write_param(filename, "mod_version", get_mod_version())
end

function sigerous_top_split_minutes(r_time)
   local s_h = r_time / 60
   local s_m = r_time - (math.floor(s_h) * 60)
   if math.floor(s_h) < 10 and math.floor(s_m) < 10 then
      return "0" .. math.floor(s_h) .. ":0" .. math.floor(s_m)
   elseif math.floor(s_h) < 10 and math.floor(s_m) >= 10 then
      return "0" .. math.floor(s_h) .. ":" .. math.floor(s_m)
   elseif math.floor(s_m) < 10 then
      return math.floor(s_h) .. ":0" .. math.floor(s_m)
   end
   return math.floor(s_h) .. ":" .. math.floor(s_m)
end

-- 'Проверка уровня сложности.
function get_difficulty()
   if level.get_game_difficulty() == 0 then
      return "novice"
   elseif level.get_game_difficulty() == 1 then
      return "stalker"
   elseif level.get_game_difficulty() == 2 then
      return "veteran"
   elseif level.get_game_difficulty() == 3 then
      return "master"
   end
   return "nil"
end

-- 'Удаление глобальных переменных для НПС.
function clear_mod_params_for_npc(npc_id)
   if npc_id ~= nil then
      clear_obj_mod_param(npc_id, "currert_path", true)
      clear_obj_mod_param(npc_id, "currert_dest", true)
      clear_obj_mod_param(npc_id, "currert_path_wait", true)
      clear_obj_mod_param(npc_id, "shooter_clip_counter", true)
      clear_obj_mod_param(npc_id, "issued_medkit", true)
      clear_obj_mod_param(npc_id, "issued_pistol_weapon", true)
      clear_obj_mod_param(npc_id, "issued_rifle_weapon", true)
   end
end

-- 'Убийство сквада.
function set_squad_killed(squad_name)
   xr_effects.kill_squad(db.actor, nil, { squad_name })
end

-- 'Удаление сквада.
function set_squad_removed(squad_name)
   xr_effects.remove_squad(db.actor, nil, { squad_name })
end

-- 'Получить название секции сквада по обьекту.
function get_object_squad_name(object)
   local squad = get_object_squad(object)
   if squad == nil then
      return nil
   end
   return squad.settings_id
end

-- 'Проверка обновления скриптов мода.
function mod_update()
   return sgm_flags.bool_mod_update == nil or sgm_flags.bool_mod_update == true
end

-- 'Выброс из игры.
function mod_abort(fmt, ...)
   local reason = string.format(fmt, ...)
   error_log(reason)
end

-- 'Проверка версии мода.
function get_mod_version()
   return r_mod_params("string", "mod_version", "2.2")
end

-- 'Проверка глобального шаблона.
function get_global_pattern()
   if read_mod_param("global_pattern") == nil then return 0 end
   return read_mod_param("global_pattern")
end

-- 'Проверка по типу оружия.
function get_weapon_type(section_name)
   return sgm_functions.ReadWeaponType(section_name)
end

-- 'Проверка на крепления аддонов.
function get_installed_addon(wpn, type)
   if wpn ~= nil and type ~= nil then
      if type == "scope" then
         result = wpn:weapon_is_scope()
      elseif type == "silencer" then
         result = wpn:weapon_is_silencer()
      elseif type == "launcher" then
         result = wpn:weapon_is_grenadelauncher()
      end
   end
   return result
end

-- 'Проверка предмета на доступность.
function check_death_item(item_section)
   local ini = ini_file("misc\\death_items_control.ltx")
   if ini:line_exist("death_items_control", item_section) then
      local checker = to_string(sgm_functions.check_section_condlist(ini, "death_items_control", item_section, "true"))
      if checker == "true" then
         return true
      else
         return false
      end
   end
   return true
end

-- 'Проверка текущей локации.
function on_level(this_level)
   local level_name = level.name()
   if level_name == this_level then
      return true
   end
   return false
end

-- 'Проверка старых локаций.
function check_default_location()
   local level_name = level.name()
   if level_name == "zaton" or level_name == "jupiter" or level_name == "pripyat" or level_name == "jupiter_underground" or level_name == "labx8" then
      return true
   end
   return false
end

-- 'Проверка локации, на которой находится game vertex.
function get_level_by_game_vertex(gv)
   return alife():level_name(game_graph():vertex(gv):level_id())
end

-- 'Проверка количества переменных в pstor.
function get_pstor_capacity()
   return get_table_lines(db.storage[db.actor:id()].pstor)
end

-- 'Уникальный ID текущей игры. Генерируется когда игрок начинает новую игру.
function get_game_unique_id()
   local readed = sgm_functions.read_variable("new_game_unique_id")
   if readed ~= nil then
      return readed
   end
   return nil
end

ammo_section                        = {}
ammo_section["ammo_9x18_fmj"]       = true
ammo_section["ammo_9x18_pmm"]       = true
ammo_section["ammo_9x19_fmj"]       = true
ammo_section["ammo_9x19_pbp"]       = true
ammo_section["ammo_5.45x39_fmj"]    = true
ammo_section["ammo_5.45x39_ap"]     = true
ammo_section["ammo_5.56x45_ss190"]  = true
ammo_section["ammo_5.56x45_ap"]     = true
ammo_section["ammo_5.7x28_fmj"]     = true
ammo_section["ammo_5.7x28_ap"]      = true
ammo_section["ammo_7.62x54_7h1"]    = true
ammo_section["ammo_9x39_pab9"]      = true
ammo_section["ammo_gauss"]          = true
ammo_section["ammo_9x39_ap"]        = true
ammo_section["ammo_11.43x23_fmj"]   = true
ammo_section["ammo_11.43x23_hydro"] = true
ammo_section["ammo_12x70_buck"]     = true
ammo_section["ammo_12x76_zhekan"]   = true
ammo_section["ammo_pkm_100"]        = true
ammo_section["ammo_box_10_vog"]     = true
ammo_section["ammo_box_10_m209"]    = true
ammo_section["ammo_dumdum"]         = true
